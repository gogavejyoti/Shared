execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;
    const s = this;
    
    // Initialize helpers
    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    // Store explicit value if provided
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // Update cross-sheet references before recalculation
    if (typeof _shiftCrossSheetReference === 'function') {
        _shiftCrossSheetReference({
            type: 'recalc',
            sheetIndex: l
        });
    }

    // Get all function group cells and sheet info
    let allFuncCells = [];
    let sheetIndices = null;
    if (e && n) {
        const formulaOrValue = (window.luckysheet_getcelldata_cache && Object.keys(window.luckysheet_getcelldata_cache).join("+")) || null;
        sheetIndices = s.getAllDependentSheetsFromSheet(l, formulaOrValue);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    }
    else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    const sheetsInfo = Ft() || [];
    const sheetMap = {};
    for (let i = 0; i < sheetsInfo.length; i++) {
        sheetMap[sheetsInfo[i].index] = sheetsInfo[i].data;
    }

    // Build execSet
    const execSet = {};
    if (s.execFunctionExist == null) {
        execSet["r" + e + "c" + n + "i" + l] = 1;
    } else {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const T = s.execFunctionExist[i];
            execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
        }
    }

    const nodes = {};
    const rangeToKeysCache = {};

    // Helper: get keys in a rectangular range
    function keysForRange(R, sheetMap) {
        const cacheKey = `r${R.row[0]}_${R.row[1]}_c${R.column[0]}_${R.column[1]}_i${R.sheetIndex}`;
        if (rangeToKeysCache[cacheKey]) return rangeToKeysCache[cacheKey];
        const aRow = sheetMap[R.sheetIndex] && R.row[1] > sheetMap[R.sheetIndex].length - 1 ? sheetMap[R.sheetIndex].length - 1 : R.row[1];

        const list = [];
        for (let rr = R.row[0]; rr <= aRow; rr++) {
            for (let cc = R.column[0]; cc <= R.column[1]; cc++) {
                const k = "r" + rr + "c" + cc + "i" + R.sheetIndex;
                list.push({ key: k, r: rr, c: cc, sheetIndex: R.sheetIndex });
            }
        }
        rangeToKeysCache[cacheKey] = list;
        return list;
    }
    
    const fmrSplit = /==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/;
    
    // Build nodes
    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const nodeKey = "r" + T.r + "c" + T.c + "i" + T.index;
        const R = zl(T.r, T.c, T.index)
        || ve.getSheetByIndex(T.index)?.celldata?.find(x => x?.r === T.r && x?.c === T.c)?.v.f;
        if (!R) continue;

        const upper = R.toUpperCase();
        const formulaRanges = [];
        if (!(R.substr(0, 2) === '="' && R.substr(R.length - 1, 1) === '"')) {
            const tokens = R.split(fmrSplit).filter(Boolean);
            for (let ti = 0; ti < tokens.length; ti++) {
                let tk = tokens[ti].trim();
                if (!tk) continue;
                if (tk.length <= 1 && !(s.iscelldata && s.iscelldata(tk))) continue;
                const rg = s.getcellrange($.trim(tk), T.index);
                if (rg) formulaRanges.push(rg);
            }
        }

        nodes[nodeKey] = {
            formulaArray: formulaRanges,
            calc_funcStr: R,
            key: nodeKey,
            r: T.r,
            c: T.c,
            index: T.index,
            parents: {},
            children: {},
            color: "w"
        };
    }

    // === FIXED: Build dependency graph with correct parent-child relationships ===
    const nodeKeys = Object.keys(nodes);
    for (let i = 0; i < nodeKeys.length; i++) {
        const node = nodes[nodeKeys[i]];
        const ranges = node.formulaArray || [];
        for (let ri = 0; ri < ranges.length; ri++) {
            const rect = ranges[ri];
            const keys = keysForRange(rect, sheetMap);
            for (let ki = 0; ki < keys.length; ki++) {
                const cellInfo = keys[ki];
                const A = cellInfo.key;
                
                // FIXED: Correct parent-child relationship
                node.parents[A] = 1;  // node depends on A
                
                if (A in nodes) {
                    nodes[A].children[node.key] = 1;  // A is used by node
                }
            }
        }
    }

    // === FIXED: Find all cells that need recalculation ===
    const y = [];
    
    if (o) {
        // Recalculate all formula cells
        for (let i = 0; i < nodeKeys.length; i++) {
            y.push(nodes[nodeKeys[i]]);
        }
    } else {
        // Find all direct and indirect dependencies of changed cells
        const visited = {};
        const queue = [];
        
        // Start from cells in execSet
        const execKeys = Object.keys(execSet);
        for (let i = 0; i < execKeys.length; i++) {
            const changedKey = execKeys[i];
            
            if (changedKey in nodes) {
                // Changed cell is a formula - add it directly
                queue.push(nodes[changedKey]);
            } else {
                // Changed cell is a value - find all formulas that reference it
                for (let j = 0; j < nodeKeys.length; j++) {
                    const node = nodes[nodeKeys[j]];
                    if (node.parents && node.parents[changedKey]) {
                        queue.push(node);
                    }
                }
            }
        }
        
        // BFS to find all direct and indirect dependencies
        while (queue.length > 0) {
            const cur = queue.shift();
            if (!cur || visited[cur.key]) continue;
            
            visited[cur.key] = 1;
            y.push(cur);
            
            // Add all children (cells that depend on this cell)
            const childKeys = Object.keys(cur.children || {});
            for (let ci = 0; ci < childKeys.length; ci++) {
                const childKey = childKeys[ci];
                if (nodes[childKey] && !visited[childKey]) {
                    queue.push(nodes[childKey]);
                }
            }
        }
    }

    // === FIXED: Topological sort - only consider parents that need recalculation ===
    const S = {};
    const stack = y.slice();
    const ordered = [];
    const ySet = {};
    for (let i = 0; i < y.length; i++) {
        ySet[y[i].key] = 1;
    }
    
    while (stack.length > 0) {
        const cur = stack.pop();
        if (!cur || S[cur.key]) continue;
        
        if (cur.color === "b") {
            ordered.push(cur);
            S[cur.key] = 1;
            continue;
        }

        const parentKeys = Object.keys(cur.parents || {});
        const parentNodes = [];
        for (let pi = 0; pi < parentKeys.length; pi++) {
            const pk = parentKeys[pi];
            // Only include parents that are in y (need recalculation)
            if (nodes[pk] && ySet[pk]) {
                parentNodes.push(nodes[pk]);
            }
        }

        if (parentNodes.length === 0) {
            ordered.push(cur);
            S[cur.key] = 1;
        } else {
            cur.color = "b";
            stack.push(cur);
            for (let p = 0; p < parentNodes.length; p++) {
                stack.push(parentNodes[p]);
            }
        }
    }

    ordered.reverse();

    // Evaluate nodes
    const indexMap = {};
    for (let i = 0; i < ordered.length; i++) {
        indexMap[ordered[i].key] = { idx: i, count: 0};
        console.log(`${ordered[i].index}=>${s.getExcelAddr(ordered[i].r, ordered[i].c)}=>${ordered[i].calc_funcStr}`);
    }

    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];
        window.luckysheet_getcelldata_cache = null;
        const oldValue = sheetMap[T.index][T.r][T.c]?.v;
        const Rres = s.execfunction(T.calc_funcStr, T.r, T.c, T.index);
        if (oldValue == Rres[1]) {
            continue;
        }

        s.execFunctionGlobalData[`${T.r}_${T.c}_${T.index}`] = {
            v: Rres[1],
            f: Rres[2]
        };
        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: Rres[1],
            f: Rres[2],
            spe: Rres[3],
            index: T.index
        });
        
        const parents = T.parents ? Object.keys(T.parents) : [];
        for (const k of parents) {
            const parentIdx = indexMap[k]?.idx ?? -1;
            if (parentIdx !== -1 && parentIdx < i && indexMap[k].count < 5) {
                ordered.push(ordered[parentIdx]);
                indexMap[k].idx = ordered.length - 1;
                indexMap[k].count = indexMap[k].count + 1;
                if (indexMap[k].count == 5)
                    console.log(ordered[parentIdx].calc_funcStr);
            }
        }
    }
    s.execFunctionExist = null;
}
