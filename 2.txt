// ---------- helpers ----------
function isLookupFormula(formula) {
    return /(?:VLOOKUP|HLOOKUP)\s*\(/i.test(formula);
}

function extractLookupKey(formula) {
    const m = formula.match(/(?:VLOOKUP|HLOOKUP)\s*\(\s*([^,]+)/i);
    return m ? m[1].trim() : null;
}

/**
 * Resolve exact matched row/column for VLOOKUP / HLOOKUP (exact match only)
 */
function resolveExactLookupRange(formula, sheetIndex) {
    const m = formula.match(
        /(VLOOKUP|HLOOKUP)\s*\(\s*([^,]+)\s*,\s*([^,]+)/i
    );
    if (!m) return null;

    const fn = m[1].toUpperCase();
    const lookupExpr = m[2].trim();
    const rangeExpr = m[3].trim();

    // lookup value
    let lookupValue = null;
    const lookupCell = s.getusedcellrange(lookupExpr, sheetIndex);

    if (lookupCell) {
        lookupValue = window.luckysheet_getcelldata(
            lookupCell.row[0],
            lookupCell.column[0],
            lookupCell.sheetIndex
        )?.v;
    } else {
        lookupValue = Ua(lookupExpr);
    }

    if (lookupValue == null) return null;

    const rg = s.getusedcellrange(rangeExpr, sheetIndex);
    if (!rg) return null;

    const r0 = rg.row[0], r1 = rg.row[1];
    const c0 = rg.column[0], c1 = rg.column[1];

    // VLOOKUP → matched ROW
    if (fn === "VLOOKUP") {
        for (let r = r0; r <= r1; r++) {
            const cell = window.luckysheet_getcelldata(r, c0, sheetIndex);
            if (cell && cell.v === lookupValue) {
                return { row: [r, r], column: [c0, c1], sheetIndex };
            }
        }
    }

    // HLOOKUP → matched COLUMN
    if (fn === "HLOOKUP") {
        for (let c = c0; c <= c1; c++) {
            const cell = window.luckysheet_getcelldata(r0, c, sheetIndex);
            if (cell && cell.v === lookupValue) {
                return { row: [r0, r1], column: [c, c], sheetIndex };
            }
        }
    }

    return null;
}


const formulaRanges = [];

// ---------- LOOKUP FORMULAS ----------
if (isLookupFormula(R)) {

    // 1️⃣ lookup key cell (E2)
    const keyRef = extractLookupKey(R);
    if (keyRef) {
        const kr = s.getusedcellrange(keyRef, T.index);
        if (kr) formulaRanges.push(kr);
    }

    // 2️⃣ exact matched row / column
    const exactRange = resolveExactLookupRange(R, T.index);
    if (exactRange) {
        formulaRanges.push(exactRange);
    }

    // 3️⃣ lazy fallback table range (C:D)
    s.isFunctionRange(R, null, null, T.index, null, function (ref) {
        const rg = s.getusedcellrange(ref.trim(), T.index);
        if (rg) formulaRanges.push({ ...rg, __lazy__: true });
    });

}
// ---------- ALL OTHER FORMULAS ----------
else if (!(R.substr(0, 2) === '="' && R.substr(R.length - 1, 1) === '"')) {

    const tokens = R
        .split(/==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/)
        .filter(Boolean);

    for (let ti = 0; ti < tokens.length; ti++) {
        let tk = tokens[ti].trim();
        if (!tk) continue;
        if (tk.length <= 1 && !(s.iscelldata && s.iscelldata(tk))) continue;

        const rg = s.getusedcellrange(tk, T.index);
        if (rg) formulaRanges.push(rg);
    }
}
