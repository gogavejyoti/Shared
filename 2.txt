execFunctionGroup: function (triggerRow, triggerCol, triggerValue, triggerSheetIndex, explicitValue = null, skip = false) {
    if (skip) return;

    const self = this;

    // ── Helpers & globals ───────────────────────────────────────────────
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith      = ja;
        window.luckysheet_getarraydata     = wc;
        window.luckysheet_getcelldata      = nr;
        window.luckysheet_parseData        = Ua;
        window.luckysheet_getValue         = qn;
        window.luckysheet_indirect_check   = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check     = Cc;
        window.luckysheet_calcADPMM        = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!self.execFunctionGlobalData) self.execFunctionGlobalData = {};

    const currentSheet = triggerSheetIndex ?? h.currentSheetIndex;
    const explicitKey = explicitValue != null ? `${triggerRow}_${triggerCol}_${currentSheet}` : null;

    // Store explicit value if provided (forced recalculation point)
    if (explicitValue != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, explicitValue);
        self.execFunctionGlobalData[explicitKey] = tmp[0][0];
    }

    // ── 1. Collect ALL formula cells we might ever need ──────────────────
    const allFormulaCells = self.getAllFunctionGroup() || []; // {r,c,index, ...}

    // ── 2. Build fast lookup maps ─────────────────────────────────────────
    const sheetDataMap = {}; // index → data
    (Ft() || []).forEach(sheet => {
        sheetDataMap[sheet.index] = sheet.data;
    });

    // ── 3. Build dependency graph ─────────────────────────────────────────
    const nodes = {};           // key → node
    const refToDependents = {}; // "rXcXiY" → Set<dependent formula keys>

    const RANGE_TOKEN_SPLIT = /==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/;

    for (const cell of allFormulaCells) {
        const key = `r${cell.r}c${cell.c}i${cell.index}`;

        let formula = zl(cell.r, cell.c, cell.index) ||
                      ve.getSheetByIndex(cell.index)?.celldata
                        ?.find(cd => cd.r === cell.r && cd.c === cell.c)
                        ?.v?.f;

        if (!formula || formula.startsWith('="') && formula.endsWith('"')) {
            continue; // skip string literals
        }

        nodes[key] = {
            key,
            r: cell.r,
            c: cell.c,
            index: cell.index,
            formula,
            parents: new Set(),
            children: new Set(),
            address: self.getExcelAddr(cell.r, cell.c)
        };

        // Find referenced ranges
        const tokens = formula.split(RANGE_TOKEN_SPLIT).filter(t => t.trim());
        for (const token of tokens) {
            const trimmed = $.trim(token);
            if (trimmed.length <= 1) continue;

            const range = self.getcellrange(trimmed, cell.index);
            if (!range) continue;

            const rangeKeys = self._rangeToCellKeys(range, sheetDataMap);
            for (const refKey of rangeKeys) {
                // Every referenced cell knows who depends on it
                if (!refToDependents[refKey]) refToDependents[refKey] = new Set();
                refToDependents[refKey].add(key);

                // If referenced cell is also formula → proper graph edge
                if (refKey in nodes) {
                    nodes[key].parents.add(refKey);
                    nodes[refKey].children.add(key);
                }
            }
        }
    }

    // ── 4. Find starting points (changed cells + explicit) ────────────────
    const changedKeys = new Set();

    // Explicit change
    if (explicitKey) {
        changedKeys.add(explicitKey);
    }

    // Cells from execFunctionExist (old changed cells mechanism)
    if (self.execFunctionExist?.length > 0) {
        for (const item of self.execFunctionExist) {
            changedKeys.add(`r${item.r}c${item.c}i${item.i}`);
        }
    } else if (triggerRow != null && triggerCol != null) {
        changedKeys.add(`r${triggerRow}c${triggerCol}i${currentSheet}`);
    }

    // ── 5. Build transitive closure of impacted formula cells ─────────────
    const impacted = new Set();

    const queue = [...changedKeys];
    const visited = new Set();

    while (queue.length > 0) {
        const current = queue.shift();
        if (visited.has(current)) continue;
        visited.add(current);

        // If this is a formula cell → it is impacted
        if (current in nodes) {
            impacted.add(current);
        }

        // All formulas that depend on this cell are also impacted
        const dependents = refToDependents[current];
        if (dependents) {
            for (const depKey of dependents) {
                if (!visited.has(depKey)) {
                    queue.push(depKey);
                }
            }
        }
    }

    if (impacted.size === 0) {
        // Safety net - something went wrong → full recalc
        console.warn("[calc] No impacted formulas detected → full recalculation");
        for (const k in nodes) impacted.add(k);
    }

    // ── 6. Topological order using Kahn's algorithm (BFS + indegree) ──────
    const indegree = {};
    for (const key of impacted) {
        indegree[key] = 0;
    }

    for (const key of impacted) {
        const node = nodes[key];
        if (!node) continue;
        for (const childKey of node.children) {
            if (impacted.has(childKey)) {
                indegree[childKey]++;
            }
        }
    }

    const orderQueue = [];
    for (const key of impacted) {
        if (indegree[key] === 0) {
            orderQueue.push(nodes[key]);
        }
    }

    const calculationOrder = [];

    while (orderQueue.length > 0) {
        const node = orderQueue.shift();
        calculationOrder.push(node);

        for (const childKey of node.children) {
            if (impacted.has(childKey)) {
                indegree[childKey]--;
                if (indegree[childKey] === 0) {
                    orderQueue.push(nodes[childKey]);
                }
            }
        }
    }

    // Cycle / disconnected component protection
    if (calculationOrder.length < impacted.size) {
        console.warn(`[calc] Cycle or disconnected component detected! ${impacted.size - calculationOrder.length} nodes not ordered. Falling back to arbitrary order.`);
        for (const key of impacted) {
            if (!calculationOrder.some(n => n.key === key)) {
                calculationOrder.push(nodes[key]);
            }
        }
    }

    // ── 7. Execute in topological order ───────────────────────────────────
    window.luckysheet_getcelldata_cache = null; // important!

    for (const node of calculationOrder) {
        const oldValue = sheetDataMap[node.index]?.[node.r]?.[node.c]?.v;

        const result = self.execfunction(node.formula, node.r, node.c, node.index);
        const [ok, newValue, newFormula, special] = result;

        if (oldValue == newValue) continue; // optimization

        // Update caches
        self.execFunctionGlobalData[`${node.r}_${node.c}_${node.index}`] = {
            v: newValue,
            f: newFormula
        };

        self.groupValuesRefreshData.push({
            r: node.r,
            c: node.c,
            v: newValue,
            f: newFormula,
            spe: special,
            index: node.index
        });
    }

    self.execFunctionExist = null;
},
