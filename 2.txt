execfunction: function (e, n, t, l, a, o) {
    let s = this, d = Q().formulaMore;

    // quick error check
    if (e.indexOf(s.error.r) > -1) return [!1, s.error.r, e];
    if (!s.checkBracketNum(e)) e += ")";

    // ðŸ”¹ Normalize Excel-style percent literals: 10% â†’ (10/100), 12.5% â†’ (12.5/100)
    // Only touch formulas (starting with "=")
    if (typeof e === "string" && e.charAt(0) === "=") {
        // Replace number% patterns with (number/100)
        // e.g. =BX109*30% â†’ =BX109*(30/100)
        e = e.replace(/(\d+(\.\d+)?)%/g, "($1/100)");
    }

    if (l == null) l = h.currentSheetIndex;
    h.calculateSheetIndex = l;

    let f = $.trim(s.functionParserExe(e));

    if ((f.substr(0, 20) == "luckysheet_function." || f.substr(0, 22) == "luckysheet_compareWith") && (s.functionHTMLIndex = 0),
        !s.testFunction(e, f) || f == "")
        return U.info("", d.execfunctionError),
            [!1, s.error.n, e];

    let m = null;
    window.luckysheetCurrentRow = n;
    window.luckysheetCurrentColumn = t;
    window.luckysheetCurrentIndex = l;
    window.luckysheetCurrentFunction = e;
    let g = null;

    try {
        // self-reference detection (keeps behavior)
        if (f.indexOf("luckysheet_getcelldata") > -1) {
            const parts = f.split("luckysheet_getcelldata('");
            for (let k = 1; k < parts.length; k++) {
                const b = parts[k].split("')")[0];
                const w = s.getcellrange(b);
                if (w == null || w.row[0] < 0 || w.column[0] < 0) return [!0, s.error.r, e];
                if (w.sheetIndex == h.calculateSheetIndex && n >= w.row[0] && n <= w.row[1] && t >= w.column[0] && t <= w.column[1])
                    return de() ? alert(d.execfunctionSelfError) : U.info("", d.execfunctionSelfErrorResult),
                        [!1, 0, e];
            }
        }

        m = new Function("return " + f)();
        if (typeof m == "string") m = m.replace(/\x7F/g, '"');
        if (f.indexOf("SPLINES") > -1) { g = m; m = ""; }
    } catch (err) {
        console.log(err, f);
        const k = s.errorInfo(err);
        m = [s.error.n, k];
    }

    // normalize object return type
    if (L(m) == "object" && m.startCell != null) {
        if (L(m.data) == "array") m = s.error.v;
        else if (L(m.data) == "object" && !fe(m.data.v)) m = m.data.v;
        else if (fe(m.data)) m = 0;
        else if (m.cell > 1 || m.rowl > 1 || L(m.data) == "string" || L(m.data) == "number") m = m.data;
        else m = 0;
    }

    let y = null;
    if (L(m) == "array") {
        let simple = !(L(m[0]) == "array") && m.length == 2 && H(m[0]);
        if (simple) m = m[0];
        else if (L(m[0]) == "array" && m.length == 1 && m[0].length == 1) m = m[0][0];
        else {
            y = {
                r: n,
                c: t,
                f: e,
                index: l,
                data: m
            };
            m = "";
        }
    }

    // reset globals
    window.luckysheetCurrentRow = null;
    window.luckysheetCurrentColumn = null;
    window.luckysheetCurrentIndex = null;
    window.luckysheetCurrentFunction = null;

    // update groups if needed
    if (n != null && t != null) {
        if (a) s.execFunctionGroup(n, t, m, l);
        if (!o) s.insertUpdateFunctionGroup(n, t, l);
    }

    if (g) return [!0, m, e, { type: "sparklines", data: g }];
    if (y) return [!0, m, e, { type: "dynamicArrayItem", data: y }];
    return [!0, m, e];
},
