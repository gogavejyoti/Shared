fixCrossSheetReferencesAfterRename(y, g);

/**
 * Fix all cross-sheet formula references when a sheet is renamed in LuckySheet.
 * Updates sheet.data, sheet.m, and calcChain efficiently.
 */
function fixCrossSheetReferencesAfterRename(oldName, newName) {
    const files = luckysheet.getLuckysheetfile();
    if (!files || files.length === 0) return;

    // Match both 'Old Name'! and OldName! in formulas
    const quoted = oldName.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&'); // escape regex specials
    const pattern = new RegExp(`('?${quoted}'?)!`, 'g');

    for (let s = 0; s < files.length; s++) {
        const sheet = files[s];
        if (!sheet || !sheet.data) continue;

        const data = sheet.data;
        const mMap = sheet.m || {};
        const calcChain = sheet.calcChain || [];

        for (let r = 0; r < data.length; r++) {
            const row = data[r];
            if (!row) continue;

            for (let c = 0; c < row.length; c++) {
                const cell = row[c];
                if (!cell || !cell.f) continue;

                if (pattern.test(cell.f)) {
                    // --- Update formula in data ---
                    cell.f = cell.f.replace(pattern, `'${newName}'!`);

                    // --- Update formula in m ---
                    const key = `${r}_${c}`;
                    if (mMap[key] && mMap[key].f) {
                        mMap[key].f = mMap[key].f.replace(pattern, `'${newName}'!`);
                    }

                    // --- Clean calcChain entry ---
                    const idx = calcChain.findIndex(cc => cc.r === r && cc.c === c);
                    if (idx !== -1) {
                        calcChain.splice(idx, 1);
                    }
                }
            }
        }
    }

    // Trigger refresh (LuckySheet lazy recalculates)
    luckysheet.refresh();
}

