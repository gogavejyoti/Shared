pasteHandler: function (e, n) {
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex) || h.allowEdit === false) return;

    let lang = Q().paste;

    if (h.luckysheet_select_save.length > 1 &&
        (de() ? alert(lang.errorNotAllowMulti)
              : U.info(`<i class="fa fa-exclamation-triangle"></i>${lang.warning}`, lang.errorNotAllowMulti))) {
        return;
    }

    // ======================================
    // CASE 1: COPY-OBJECT PASTE (Luckysheet internal copy)
    // ======================================
    if (typeof e === "object") {
        if (e.length === 0) return;

        let cfg = $.extend(true, {}, h.config);
        if (!cfg.merge) cfg.merge = {};
        if (JSON.stringify(n).length > 2 && !cfg.borderInfo) cfg.borderInfo = [];

        let rows = e.length,
            cols = e[0].length,
            r1 = h.luckysheet_select_save[0].row[0],
            r2 = r1 + rows - 1,
            c1 = h.luckysheet_select_save[0].column[0],
            c2 = c1 + cols - 1;

        if (cfg.merge && Dt(cfg, r1, r2, c1, c2)) {
            de() ? alert(lang.errorNotAllowMerged)
                 : U.info(`<i class="fa fa-exclamation-triangle"></i>${lang.warning}`, lang.errorNotAllowMerged);
            return;
        }

        let data = we.deepCopyFlowData(h.flowdata),
            grow = r2 - data.length + 1,
            gcol = c2 - data[0].length + 1;

        if (grow > 0 || gcol > 0) data = il([].concat(data), grow, gcol, true);

        if (!cfg.rowlen) cfg.rowlen = {};
        let rowHeightChanged = false, mergeMap = {};

        // PASTE LOOP
        for (let r = r1; r <= r2; r++) {
            let row = [].concat(data[r]);
            let rowHeight = cfg.rowlen[r] || h.defaultrowlen;

            for (let c = c1; c <= c2; c++) {
                let oldCell = row[c];

                // Remove old merge anchors
                if (oldCell && typeof oldCell === "object" && oldCell.mc) {
                    if (oldCell.mc.rs) delete cfg.merge[oldCell.mc.r + "_" + oldCell.mc.c];
                    delete oldCell.mc;
                }

                let newCell = (e[r - r1] && e[r - r1][c - c1]) ? $.extend(true, {}, e[r - r1][c - c1]) : null;

                // Fix merge structure
                if (newCell && newCell.mc) {
                    if (newCell.mc.rs != null) {
                        newCell.mc.r = r;
                        newCell.mc.c = c;
                        cfg.merge[newCell.mc.r + "_" + newCell.mc.c] = newCell.mc;
                        mergeMap[e[r - r1][c - c1].mc.r + "_" + e[r - r1][c - c1].mc.c] = [r, c];
                    } else {
                        let p = mergeMap[e[r - r1][c - c1].mc.r + "_" + e[r - r1][c - c1].mc.c];
                        newCell = { mc: { r: p[0], c: p[1] } };
                    }
                }

                // Add border metadata
                if (n[r - r1 + "_" + (c - c1)]) {
                    cfg.borderInfo.push({
                        rangeType: "cell",
                        value: {
                            row_index: r,
                            col_index: c,
                            ...n[r - r1 + "_" + (c - c1)]
                        }
                    });
                }

                // --- NEW: Formula detection for internal object paste ---
                if (newCell && typeof newCell.v === "string") {
                    let cleaned = newCell.v.replace(/^\uFEFF/, "").trim();
                    if (cleaned.startsWith("=")) {
                        newCell.f = cleaned;
                        newCell.v = null;
                        newCell.m = cleaned;
                    }
                }

                row[c] = newCell;

                // Adjust row height
                let fontSet = ra(newCell);
                let hTest = be.getTextSize("ç”°", fontSet)[1];
                if (hTest > rowHeight) {
                    rowHeight = hTest;
                    rowHeightChanged = true;
                }
            }

            data[r] = row;
            if (rowHeight !== h.defaultrowlen) cfg.rowlen[r] = rowHeight;
        }

        h.luckysheet_select_save = [{ row: [r1, r2], column: [c1, c2] }];

        if (grow > 0 || gcol > 0 || rowHeightChanged) {
            Ye(data, h.luckysheet_select_save, { cfg, RowlChange: true });
        } else {
            Ye(data, h.luckysheet_select_save, { cfg });
            tt();
        }

        return;
    }

    // ======================================
    // CASE 2: PLAIN TEXT PASTE (From Notepad, Excel, browser, etc.)
    // ======================================
    e = e.replace(/\r/g, "");
    let lines = e.split("\n"),
        table = [],
        colCount = lines[0].split("\t").length;

    for (let L of lines)
        if (L.split("\t").length >= colCount)
            table.push(L.split("\t"));

    let data = we.deepCopyFlowData(h.flowdata),
        sel = h.luckysheet_select_save[h.luckysheet_select_save.length - 1],
        r1 = sel.row ? sel.row[0] : 0,
        c1 = sel.column ? sel.column[0] : 0;

    let rows = table.length,
        cols = table[0].length;

    // Check merge blocking
    if (h.config.merge && Dt(h.config, r1, r1 + rows - 1, c1, c1 + cols - 1)) {
        de() ? alert(lang.errorNotAllowMerged)
             : U.info(`<i class="fa fa-exclamation-triangle"></i>${lang.warning}`, lang.errorNotAllowMerged);
        return;
    }

    let grow = r1 + rows - data.length,
        gcol = c1 + cols - data[0].length;

    if (grow > 0 || gcol > 0)
        data = il([].concat(data), grow, gcol, true);

    // ======================================
    // TEXT PASTE LOOP
    // ======================================
    for (let r = 0; r < rows; r++) {
        let row = [].concat(data[r + r1]);

        for (let c = 0; c < cols; c++) {
            let oldCell = row[c + c1];
            let txt = table[r][c];

            // --- UNIVERSAL CLEANING ---
            txt = txt.replace(/^\uFEFF/, "").trim();  // Remove BOM + whitespace

            // === FORMULA DETECTION (Important: BEFORE ANY OTHER LOGIC) ===
            if (txt.startsWith("=")) {
                oldCell = oldCell || {};
                oldCell.f = txt;
                oldCell.v = null;
                oldCell.m = txt;
                row[c + c1] = oldCell;
                continue;
            }

            // === NORMAL VALUE ===
            if (B(txt) && (oldCell && oldCell.ct && oldCell.ct.fa === "@" ? txt = String(txt) : txt = parseFloat(txt)));

            if (oldCell instanceof Object) {
                oldCell.v = txt;
                oldCell.m = oldCell.ct && oldCell.ct.fa ? mt(oldCell.ct.fa, txt) : txt;

                if (oldCell.f) {
                    oldCell.f = "";
                    p.delFunctionGroup(r + r1, c + c1, h.currentSheetIndex);
                }
            } else {
                let newCell = {};
                let parsed = it(txt);
                newCell.v = parsed[2];
                newCell.ct = parsed[1];
                newCell.m = parsed[0];
                row[c + c1] = newCell;
            }
        }

        data[r + r1] = row;
    }

    sel.row = [r1, r1 + rows - 1];
    sel.column = [c1, c1 + cols - 1];

    if (grow > 0 || gcol > 0)
        Ye(data, h.luckysheet_select_save, { RowlChange: true });
    else {
        Ye(data, h.luckysheet_select_save);
        tt();
    }
}
