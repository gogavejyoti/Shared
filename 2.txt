(function($) {
    class DynamicTable {
        constructor(container, options) {
            this.container = container;
            this.options = options;
            this.columnGroups = JSON.parse(JSON.stringify(options.columnGroups || []));
            this.masterGroups = options.masterGroups || [];
            this.data = options.data || {};
            this.expandedRows = new Set();
            this._handleRowToggle = this._handleRowToggle.bind(this);

            this.init();
        }

        init() {
            this.container.html(`
                <div class="plugin-container">
                    <div class="table-controls">
                        <button data-action="expand-cols">Expand All Columns</button>
                        <button data-action="collapse-cols">Collapse All Columns</button>
                        <button data-action="expand-rows">Expand All Rows</button>
                        <button data-action="collapse-rows">Collapse All Rows</button>
                    </div>
                    <div class="table-container">
                        <table id="dynamicTable-${this.container.attr("id")}">
                            <thead class="table-head"></thead>
                            <tbody class="table-body"></tbody>
                        </table>
                    </div>
                </div>
            `);

            this.thead = this.container.find('.table-head')[0];
            this.tbody = this.container.find('.table-body')[0];

            this._addEventListeners();
            this.buildTable();
        }

        destroy() {
            this.container.off('click', this._handleRowToggle);
            this.container.empty();
            console.log("DynamicTable instance destroyed.");
        }

        refresh(newOptions) {
            if (newOptions.data) this.data = newOptions.data;
            if (newOptions.columnGroups) this.columnGroups = JSON.parse(JSON.stringify(newOptions.columnGroups));
            if (newOptions.masterGroups) this.masterGroups = newOptions.masterGroups;
            if (newOptions.data) this.expandedRows.clear();
            this.buildTable();
        }

        _addEventListeners() {
            this.container.on('click', this._handleRowToggle);
        }

        _handleRowToggle(event) {
            const target = $(event.target);
            const action = target.data('action');

            if (action) {
                switch (action) {
                    case 'expand-cols': this.expandAllColumns(); break;
                    case 'collapse-cols': this.collapseAllColumns(); break;
                    case 'expand-rows': this.expandAllRows(); break;
                    case 'collapse-rows': this.collapseAllRows(); break;
                }
            }

            if (target.hasClass('toggle-icon')) {
                const th = target.closest('th');
                const td = target.closest('td');
                if (th.length && target.data('groupIndex') !== undefined) {
                    this.toggleColumnGroup(parseInt(target.data('groupIndex')));
                }
                if (td.length && target.data('path')) {
                    this.toggleRow(target.data('path'));
                }
            }
        }

        buildTable() {
            this.thead.innerHTML = "";
            this.tbody.innerHTML = "";

            const masterGroupRow = document.createElement("tr");
            const groupRow = document.createElement("tr");
            const headerRow = document.createElement("tr");

            const cornerTh = document.createElement("th");
            cornerTh.classList.add("frozen");
            cornerTh.rowSpan = 3;
            cornerTh.textContent = "Project";
            masterGroupRow.appendChild(cornerTh);

            let lastMasterGroupEnd = -1;
            this.masterGroups.sort((a, b) => a.start - b.start).forEach(mg => {
                const gapStart = lastMasterGroupEnd + 1;
                const gapEnd = mg.start - 1;
                if (gapStart <= gapEnd) {
                    let gapColspan = 0;
                    for (let i = gapStart; i <= gapEnd; i++) {
                        gapColspan += this.columnGroups[i].expanded ? this.columnGroups[i].columns.length : 1;
                    }
                    if (gapColspan > 0) {
                        const spacerTh = document.createElement("th");
                        spacerTh.colSpan = gapColspan;
                        masterGroupRow.appendChild(spacerTh);
                    }
                }
                const th = document.createElement("th");
                th.textContent = mg.title;
                let colspan = 0;
                for (let i = mg.start; i <= mg.end; i++) {
                    colspan += this.columnGroups[i].expanded ? this.columnGroups[i].columns.length : 1;
                }
                th.colSpan = colspan;
                masterGroupRow.appendChild(th);
                lastMasterGroupEnd = mg.end;
            });

            const postStart = lastMasterGroupEnd + 1;
            if (postStart < this.columnGroups.length) {
                let postMasterGroupColspan = 0;
                for (let i = postStart; i < this.columnGroups.length; i++) {
                    postMasterGroupColspan += this.columnGroups[i].expanded ? this.columnGroups[i].columns.length : 1;
                }
                if (postMasterGroupColspan > 0) {
                    const spacerTh = document.createElement("th");
                    spacerTh.colSpan = postMasterGroupColspan;
                    masterGroupRow.appendChild(spacerTh);
                }
            }

            this.columnGroups.forEach((group, groupIndex) => {
                const th = document.createElement("th");
                th.colSpan = group.expanded ? group.columns.length : 1;
                th.innerHTML = `<span class="toggle-icon" data-group-index="${groupIndex}">[${group.expanded ? "-" : "+"}]</span>${group.title}`;
                groupRow.appendChild(th);
            });

            this.columnGroups.forEach((group) => {
                group.columns.forEach((col, colIndex) => {
                    const th = document.createElement("th");
                    th.textContent = col;
                    if (!group.expanded && colIndex !== 0) th.classList.add("hidden");
                    headerRow.appendChild(th);
                });
            });

            this.thead.appendChild(masterGroupRow);
            this.thead.appendChild(groupRow);
            this.thead.appendChild(headerRow);

            const createRow = (name, rowData, level, path) => {
                const tr = document.createElement("tr");
                tr.dataset.path = path;
                if (level > 0) {
                    tr.classList.add("child-row");
                    const parentPath = path.substring(0, path.lastIndexOf('-'));
                    if (this.expandedRows.has(parentPath)) tr.classList.add("visible");
                }

                const td = document.createElement("td");
                td.classList.add("frozen");
                td.style.paddingLeft = (level * 20) + "px";
                if (rowData.children) {
                    const isExpanded = this.expandedRows.has(path);
                    td.innerHTML = `<span class="toggle-icon" data-path="${path}">${isExpanded ? "▼" : "▶"}</span> ${name}`;
                } else {
                    td.textContent = name;
                }
                tr.appendChild(td);

                this.columnGroups.forEach((group) => {
                    group.columns.forEach((col, colIndex) => {
                        const cell = document.createElement("td");
                        cell.textContent = rowData.data[col] || "";
                        if (!group.expanded && colIndex !== 0) cell.classList.add("hidden");
                        tr.appendChild(cell);
                    });
                });

                this.tbody.appendChild(tr);

                if (rowData.children) {
                    for (const child in rowData.children) {
                        createRow(child, rowData.children[child], level + 1, path + "-" + child);
                    }
                }
            };

            for (const key in this.data) {
                createRow(key, this.data[key], 0, key);
            }
        }

        toggleRow(path) {
            if (this.expandedRows.has(path)) {
                this.expandedRows.delete(path);
                const descendants = Array.from(this.expandedRows).filter(p => p.startsWith(path + '-'));
                descendants.forEach(d => this.expandedRows.delete(d));
            } else {
                this.expandedRows.add(path);
            }
            this.buildTable();
        }

        toggleColumnGroup(index) {
            this.columnGroups[index].expanded = !this.columnGroups[index].expanded;
            this.buildTable();
        }

        expandAllColumns() {
            this.columnGroups.forEach(g => g.expanded = true);
            this.buildTable();
        }

        collapseAllColumns() {
            this.columnGroups.forEach(g => g.expanded = false);
            this.buildTable();
        }

        expandAllRows() {
            const findAllParentPaths = (node, currentPath, paths) => {
                if (node.children) {
                    paths.add(currentPath);
                    Object.keys(node.children).forEach(key => {
                        findAllParentPaths(node.children[key], currentPath + '-' + key, paths);
                    });
                }
            };
            Object.keys(this.data).forEach(key => findAllParentPaths(this.data[key], key, this.expandedRows));
            this.buildTable();
        }

        collapseAllRows() {
            this.expandedRows.clear();
            this.buildTable();
        }
    }

    $.fn.dynamicTable = function(optionsOrMethod, methodArg) {
        return this.each(function() {
            const $el = $(this);
            let instance = $el.data('dynamicTable');

            if (!instance) {
                instance = new DynamicTable($el, optionsOrMethod);
                $el.data('dynamicTable', instance);
            } else if (typeof optionsOrMethod === 'string' && typeof instance[optionsOrMethod] === 'function') {
                instance[optionsOrMethod](methodArg);
            } else if (typeof optionsOrMethod === 'object') {
                instance.refresh(optionsOrMethod);
            }
        });
    };
})(jQuery);
