execFunctionGroup: function (e, n, t, l, a, o = !1) {
    const s = this;

    // === FAST INIT ===
    if (!a) a = h.flowdata;
    if (!l) l = h.currentSheetIndex;

    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }
    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};

    if (t) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[`${e}_${n}_${l}`] = tmp[0][0];
    }

    // === CACHES ===
    const rangeCache = Object.create(null);
    const formulaCache = Object.create(null);
    const blockCache = Object.create(null);
    const key = (r, c, i) => `r${r}c${c}i${i}`;
    const getRange = (ref, idx) => {
        const k = `${idx}|${ref}`;
        if (rangeCache[k]) return rangeCache[k];
        return (rangeCache[k] = s.getcellrange(ref, idx));
    };

    // === FORMULA PARSER ===
    const parseRefs = (f, idx) => {
        const ck = `${idx}|${f}`;
        if (formulaCache[ck]) return formulaCache[ck];
        if (!/[A-Z]/i.test(f)) return (formulaCache[ck] = []);
        if (/INDIRECT\(|OFFSET\(|INDEX\(/i.test(f)) {
            const out = [];
            s.isFunctionRange(f, null, null, idx, null, r => {
                const g = getRange($.trim(r), idx);
                if (g) out.push(g);
            });
            return (formulaCache[ck] = out);
        }
        const tokens = f
            .replace(/'[^']*'/g, " ")
            .replace(/"[^"]*"/g, " ")
            .split(/==|!=|<>|<=|>=|[,()=+\-*/%&^><]/)
            .map(x => x.trim())
            .filter(Boolean);
        const out = [];
        for (let i = 0; i < tokens.length; i++) {
            const r = getRange(tokens[i], idx);
            if (r) out.push(r);
        }
        return (formulaCache[ck] = out);
    };

    // === BLOCK EXPANDER ===
    const expandBlock = b => {
        const id = `${b.row[0]}:${b.row[1]}-${b.column[0]}:${b.column[1]}-${b.sheetIndex}`;
        if (blockCache[id]) return blockCache[id];
        const arr = [];
        for (let r = b.row[0]; r <= b.row[1]; r++) {
            for (let c = b.column[0]; c <= b.column[1]; c++) {
                arr.push({ key: key(r, c, b.sheetIndex), r, c, sheetIndex: b.sheetIndex });
            }
        }
        return (blockCache[id] = arr);
    };

    // === BUILD NODE GRAPH ===
    const fnCells = s.getAllFunctionGroup();
    const nodes = Object.create(null);
    for (let i = 0; i < fnCells.length; i++) {
        const cell = fnCells[i];
        const k = key(cell.r, cell.c, cell.index);
        const f = zl(cell.r, cell.c, cell.index);
        if (!f) continue;
        nodes[k] = {
            key: k, r: cell.r, c: cell.c, index: cell.index,
            formula: f, refs: parseRefs(f, cell.index),
            parents: Object.create(null), children: Object.create(null),
            color: "w"
        };
    }

    // === TARGET CELLS ===
    const targets = Object.create(null);
    if (!s.execFunctionExist) {
        targets[key(e, n, l)] = 1;
    } else {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const c = s.execFunctionExist[i];
            targets[key(c.r, c.c, c.i)] = 1;
        }
    }

    // === BUILD DEPENDENCIES ===
    const start = [];
    for (const id in nodes) {
        const node = nodes[id];
        for (let i = 0; i < node.refs.length; i++) {
            const expanded = expandBlock(node.refs[i]);
            for (let j = 0; j < expanded.length; j++) {
                const ref = expanded[j];
                const dep = nodes[ref.key];
                if (dep) {
                    node.children[ref.key] = 1;
                    dep.parents[id] = 1;
                }
                if (!o && targets[ref.key]) start.push(node);
            }
        }
        if (o) start.push(node);
    }

    // === TOPO SORT ===
    const order = [], stack = start.slice();
    const seen = Object.create(null);
    while (stack.length) {
        const cur = stack.pop();
        if (!cur || seen[cur.key]) continue;
        if (cur.color === "b") {
            seen[cur.key] = 1; order.push(cur); continue;
        }
        const ps = [];
        for (const p in cur.parents) if (nodes[p]) ps.push(nodes[p]);
        if (!ps.length) {
            seen[cur.key] = 1; order.push(cur);
        } else {
            cur.color = "b"; stack.push(cur, ...ps);
        }
    }
    order.reverse();

    // === EVALUATE ===
    window.luckysheet_getcelldata_cache = null;
    for (let i = 0; i < order.length; i++) {
        const node = order[i];
        const R = s.execfunction(node.formula, node.r, node.c, node.index);
        s.groupValuesRefreshData.push({
            r: node.r, c: node.c, v: R[1], f: R[2], spe: R[3], index: node.index
        });
        s.execFunctionGlobalData[`${node.r}_${node.c}_${node.index}`] = { v: R[1], f: R[2] };
    }
    s.execFunctionExist = null;
},
