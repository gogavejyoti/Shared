execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;
    const s = this;

    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    if (typeof _shiftCrossSheetReference === "function") {
        _shiftCrossSheetReference({ type: "recalc", sheetIndex: l });
    }

    let allFuncCells = [];
    if (e != null && n != null) {
        allFuncCells = s.getAllDependentFunctionGroup(
            s.getAllDependentSheetsFromSheet(l)
        ) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    const execSet = {};
    if (!s.execFunctionExist) {
        execSet["r" + e + "c" + n + "i" + l] = 1;
    } else {
        for (const T of s.execFunctionExist) {
            execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
        }
    }

    const forceLookupInvalidate = (e != null && n != null);
    const nodes = {};
    const rangeToKeysCache = {};

    function keysForRange(R) {
        const k = `r${R.row[0]}_${R.row[1]}_c${R.column[0]}_${R.column[1]}_i${R.sheetIndex}`;
        if (rangeToKeysCache[k]) return rangeToKeysCache[k];
        const out = [];
        for (let r = R.row[0]; r <= R.row[1]; r++)
            for (let c = R.column[0]; c <= R.column[1]; c++)
                out.push({ key: "r" + r + "c" + c + "i" + R.sheetIndex, r, c, sheetIndex: R.sheetIndex });
        return (rangeToKeysCache[k] = out);
    }

    function isLookupFormula(f) {
        return /^(?:\s*=)?\s*(VLOOKUP|HLOOKUP)\s*\(/i.test(f);
    }

    function resolveLookupApplicableRange(formula, sheetIndex) {
        const m = formula.match(/(VLOOKUP|HLOOKUP)\s*\(\s*([^,]+)\s*,\s*([^,]+)\s*,\s*([^,]+)/i);
        if (!m) return null;

        const fn = m[1].toUpperCase();
        const lookupRef = m[2].trim();
        const tableRef = m[3].trim();
        const idx = parseInt(m[4], 10);
        if (!idx) return null;

        const table = s.getcellrange(tableRef, sheetIndex);
        if (!table) return null;

        let lookupValue;
        const lk = s.getcellrange(lookupRef, sheetIndex);
        lookupValue = lk
            ? window.luckysheet_getcelldata(lk.row[0], lk.column[0], sheetIndex)?.v
            : Ua(lookupRef);

        if (lookupValue == null) return null;

        if (fn === "VLOOKUP") {
            const sc = table.column[0];
            for (let r = table.row[0]; r <= table.row[1]; r++) {
                const v = window.luckysheet_getcelldata(r, sc, sheetIndex)?.v;
                if (v === lookupValue) {
                    const rc = table.column[0] + idx - 1;
                    return { row: [r, r], column: [rc, rc], sheetIndex };
                }
            }
        } else {
            const sr = table.row[0];
            for (let c = table.column[0]; c <= table.column[1]; c++) {
                const v = window.luckysheet_getcelldata(sr, c, sheetIndex)?.v;
                if (v === lookupValue) {
                    const rr = table.row[0] + idx - 1;
                    return { row: [rr, rr], column: [c, c], sheetIndex };
                }
            }
        }
        return null;
    }

    function getLookupAxisRange(formula, sheetIndex) {
        const m = formula.match(/(VLOOKUP|HLOOKUP)\s*\(\s*[^,]+,\s*([^,]+)/i);
        if (!m) return null;
        const table = s.getcellrange(m[2].trim(), sheetIndex);
        if (!table) return null;

        return m[1].toUpperCase() === "VLOOKUP"
            ? { row: table.row, column: [table.column[0], table.column[0]], sheetIndex }
            : { row: [table.row[0], table.row[0]], column: table.column, sheetIndex };
    }

    /* ================= BUILD NODES ================= */

    for (const T of allFuncCells) {
        const nodeKey = "r" + T.r + "c" + T.c + "i" + T.index;
        const R = zl(T.r, T.c, T.index);
        if (!R) continue;

        const formulaRanges = [];

        if (isLookupFormula(R)) {
            const m = R.match(/\(\s*([^,]+)/);
            if (m) {
                const kr = s.getcellrange(m[1].trim(), T.index);
                if (kr) formulaRanges.push(kr);
            }

            const match = resolveLookupApplicableRange(R, T.index);
            if (match) formulaRanges.push(match);

            const axis = getLookupAxisRange(R, T.index);
            if (axis) formulaRanges.push({ ...axis, __lazy__: true });
        } else {
            s.isFunctionRange(R, null, null, T.index, null, function (ref) {
                const rg = s.getcellrange($.trim(ref), T.index);
                if (rg) formulaRanges.push(rg);
            });
        }

        nodes[nodeKey] = {
            key: nodeKey,
            r: T.r,
            c: T.c,
            index: T.index,
            calc_funcStr: R,
            formulaArray: formulaRanges,
            parents: {},
            chidren: {},
            color: "w"
        };
    }

    /* ================= BUILD DEP GRAPH ================= */

    const y = [];

    for (const node of Object.values(nodes)) {
        for (const rect of node.formulaArray) {
            if (rect.__lazy__) {
                if (forceLookupInvalidate && rect.sheetIndex === l) y.push(node);
                continue;
            }
            for (const k of keysForRange(rect)) {
                if (nodes[k.key]) {
                    node.chidren[k.key] = 1;
                    nodes[k.key].parents[node.key] = 1;
                }
                if (!o && execSet[k.key]) y.push(node);
            }
        }
        if (o) y.push(node);
    }

    /* ================= TOPO SORT + EXEC ================= */

    const seen = {};
    const stack = y.slice();
    const ordered = [];

    while (stack.length) {
        const cur = stack.pop();
        if (!cur || seen[cur.key]) continue;
        if (cur.color === "b") {
            seen[cur.key] = 1;
            ordered.push(cur);
            continue;
        }
        const parents = Object.keys(cur.parents).map(k => nodes[k]).filter(Boolean);
        if (!parents.length) {
            seen[cur.key] = 1;
            ordered.push(cur);
        } else {
            cur.color = "b";
            stack.push(cur);
            parents.forEach(p => stack.push(p));
        }
    }

    ordered.reverse();

    for (const T of ordered) {
        window.luckysheet_getcelldata_cache = null;
        const Rres = s.execfunction(T.calc_funcStr, T.r, T.c, T.index);
        s.execFunctionGlobalData[`${T.r}_${T.c}_${T.index}`] = { v: Rres[1], f: Rres[2] };
        s.groupValuesRefreshData.push({
            r: T.r, c: T.c, v: Rres[1], f: Rres[2], spe: Rres[3], index: T.index
        });
    }

    s.execFunctionExist = null;
}
