execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o && !this.getAllFunctionGroup) return; // Basic safety check
    const s = this;

    // 1. Initialize Helpers & Global Data
    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    // Store explicit value for the trigger cell if provided
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // 2. Identify all potential formula cells
    let allFuncCells = [];
    if (e != null && n != null && !o) {
        const formulaCache = (window.luckysheet_getcelldata_cache && Object.keys(window.luckysheet_getcelldata_cache).join("+")) || null;
        const sheetIndices = s.getAllDependentSheetsFromSheet(l, formulaCache);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    // 3. Build the Dependency Graph (Node Map)
    const nodes = {};
    const rangeToKeysCache = {};

    // Inline Helper: Convert range object to unique cell keys
    const getKeysInRect = (R) => {
        const cacheKey = `r${R.row[0]}_${R.row[1]}_c${R.column[0]}_${R.column[1]}_i${R.sheetIndex}`;
        if (rangeToKeysCache[cacheKey]) return rangeToKeysCache[cacheKey];
        const list = [];
        for (let rr = R.row[0]; rr <= R.row[1]; rr++) {
            for (let cc = R.column[0]; cc <= R.column[1]; cc++) {
                list.push("r" + rr + "c" + cc + "i" + R.sheetIndex);
            }
        }
        rangeToKeysCache[cacheKey] = list;
        return list;
    };

    // Populate nodes and extract dependencies
    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const nodeKey = "r" + T.r + "c" + T.c + "i" + T.index;
        const formula = zl(T.r, T.c, T.index);
        if (!formula) continue;

        const deps = [];
        const upper = formula.toUpperCase();
        
        // Handle complex vs simple ranges
        if (upper.includes("INDIRECT(") || upper.includes("OFFSET(") || upper.includes("INDEX(")) {
            this.isFunctionRange(formula, null, null, T.index, null, (ref) => {
                const rg = s.getcellrange($.trim(ref), T.index);
                if (rg) getKeysInRect(rg).forEach(k => deps.push(k));
            });
        } else {
            const tokens = formula.split(/==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/).filter(Boolean);
            for (let tk of tokens) {
                const rg = s.getcellrange($.trim(tk), T.index);
                if (rg) getKeysInRect(rg).forEach(k => deps.push(k));
            }
        }

        nodes[nodeKey] = {
            key: nodeKey, r: T.r, c: T.c, index: T.index,
            formula: formula,
            dependencies: deps, // Cells this node points to
            dependents: []      // Cells that point to this node
        };
    }

    // Link the graph (invert dependencies to find children)
    Object.keys(nodes).forEach(key => {
        nodes[key].dependencies.forEach(depKey => {
            if (nodes[depKey]) nodes[depKey].dependents.push(key);
        });
    });

    // 4. Determine which nodes need recalculation
    let affectedKeys = new Set();
    if (o) {
        // Recalculate everything
        Object.keys(nodes).forEach(k => affectedKeys.add(k));
    } else {
        // Recalculate only downstream of the changed cell
        const triggerKey = "r" + e + "c" + n + "i" + l;
        const stack = [triggerKey];
        // Note: Even if the trigger cell isn't a formula, 
        // we check what depends on it.
        const findDependents = (key) => {
            Object.keys(nodes).forEach(nodeKey => {
                if (nodes[nodeKey].dependencies.includes(key) && !affectedKeys.has(nodeKey)) {
                    affectedKeys.add(nodeKey);
                    findDependents(nodeKey);
                }
            });
        };
        findDependents(triggerKey);
    }

    // 5. Topological Sort (Post-order DFS)
    const ordered = [];
    const visited = new Set();

    const visit = (key) => {
        if (visited.has(key)) return;
        visited.add(key);

        const node = nodes[key];
        if (node) {
            // Visit precedents first
            node.dependencies.forEach(depKey => {
                if (affectedKeys.has(depKey)) visit(depKey);
            });
            ordered.push(node);
        }
    };

    affectedKeys.forEach(key => visit(key));

    // 6. Execute in Order
    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];
        window.luckysheet_getcelldata_cache = null;
        const Rres = s.execfunction(T.formula, T.r, T.c, T.index, undefined, undefined, true);

        s.groupValuesRefreshData.push({
            r: T.r, c: T.c, v: Rres[1], f: Rres[2], spe: Rres[3], index: T.index
        });

        s.execFunctionGlobalData[T.r + "_" + T.c + "_" + T.index] = {
            v: Rres[1], f: Rres[2]
        };
    }

    s.execFunctionExist = null;
},
