execFunctionGroup: function (e, n, t, l, a, o = !1) {

    if (o) return;
    const s = this;

    if (a == null) a = h.flowdata;

    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    // === LOOKUP OPTIMIZATION (global lookup table versions) ===
    if (!window.luckysheet_lookupTableVersion) {
        window.luckysheet_lookupTableVersion = {};
    }

    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    if (typeof _shiftCrossSheetReference === 'function') {
        _shiftCrossSheetReference({ type: 'recalc', sheetIndex: l });
    }

    let allFuncCells = [];
    let sheetIndices = null;

    if (e && n) {
        const formulaOrValue =
            (window.luckysheet_getcelldata_cache &&
                Object.keys(window.luckysheet_getcelldata_cache).join("+")) || null;
        sheetIndices = s.getAllDependentSheetsFromSheet(l, formulaOrValue);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    const nodes = {};
    const rangeToKeysCache = {};
    const fmrSplit = /==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/;

    function keysForRange(R) {
        const cacheKey = `r${R.row[0]}_${R.row[1]}_c${R.column[0]}_${R.column[1]}_i${R.sheetIndex}`;
        if (rangeToKeysCache[cacheKey]) return rangeToKeysCache[cacheKey];
        const list = [];
        for (let rr = R.row[0]; rr <= R.row[1]; rr++) {
            for (let cc = R.column[0]; cc <= R.column[1]; cc++) {
                list.push({ key: "r" + rr + "c" + cc + "i" + R.sheetIndex });
            }
        }
        rangeToKeysCache[cacheKey] = list;
        return list;
    }

    // ================= BUILD NODES =================
    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const nodeKey = "r" + T.r + "c" + T.c + "i" + T.index;
        const R =
            zl(T.r, T.c, T.index) ||
            ve.getSheetByIndex(T.index)?.celldata?.find(
                x => x?.r === T.r && x?.c === T.c
            )?.v.f;

        if (!R) continue;

        const upper = R.toUpperCase();
        const formulaRanges = [];

        // === LOOKUP OPTIMIZATION (detect lookup) ===
        const hasLookup =
            upper.indexOf("VLOOKUP(") !== -1 ||
            upper.indexOf("HLOOKUP(") !== -1;

        let lookupKeyRange = null;
        let lookupTableSig = null;
        let lookupTableSheet = T.index;

        if (hasLookup) {
            // lookup key (1st argument)
            const keyMatch = R.match(/\(([^,]+)/);
            if (keyMatch && keyMatch[1]) {
                lookupKeyRange = s.getcellrange($.trim(keyMatch[1]), T.index);
            }

            // lookup table (2nd argument)
            const tableMatch = R.match(/\([^,]+,([^,]+)/);
            if (tableMatch && tableMatch[1]) {
                let tableRef = $.trim(tableMatch[1]);

                // === LOOKUP OPTIMIZATION (cross-sheet support) ===
                if (tableRef.indexOf("!") !== -1) {
                    const parts = tableRef.split("!");
                    tableRef = parts[1];
                    const sheetObj = ve.getSheetByName(parts[0]);
                    if (sheetObj) lookupTableSheet = sheetObj.index;
                }

                lookupTableSig = tableRef + "@sheet" + lookupTableSheet;

                if (!window.luckysheet_lookupTableVersion[lookupTableSig]) {
                    window.luckysheet_lookupTableVersion[lookupTableSig] = 0;
                }
            }
        }

        // === NORMAL RANGE PARSING (skip lookup table only) ===
        if (!(R.substr(0, 2) === '="' && R.substr(R.length - 1, 1) === '"')) {
            const tokens = R.split(fmrSplit).filter(Boolean);
            for (let ti = 0; ti < tokens.length; ti++) {
                const tk = tokens[ti].trim();
                if (!tk) continue;
                if (tk.length <= 1 && !(s.iscelldata && s.iscelldata(tk))) continue;

                if (lookupTableSig && tk === lookupTableSig.split("@")[0]) continue;

                const rg = s.getcellrange(tk, T.index);
                if (rg) formulaRanges.push(rg);
            }
        }

        if (lookupKeyRange) {
            formulaRanges.push(lookupKeyRange);
        }

        nodes[nodeKey] = {
            formulaArray: formulaRanges,
            calc_funcStr: R,
            key: nodeKey,
            r: T.r,
            c: T.c,
            index: T.index,
            parents: {},
            chidren: {},
            color: "w",
            lookupTable: lookupTableSig
        };
    }

    // ================= BUILD GRAPH =================
    const y = [];
    Object.keys(nodes).forEach(k => {
        const node = nodes[k];
        node.formulaArray.forEach(rect => {
            keysForRange(rect).forEach(c => {
                if (nodes[c.key]) {
                    node.chidren[c.key] = 1;
                    nodes[c.key].parents[node.key] = 1;
                }
                if (!o && (c.key in nodes)) y.push(node);
            });
        });
    });

    // ================= EXECUTION =================
    for (const k in nodes) {
        const T = nodes[k];

        // === LOOKUP OPTIMIZATION (version check) ===
        if (T.lookupTable) {
            const v = window.luckysheet_lookupTableVersion[T.lookupTable] || 0;
            if (T._lastLookupTableVersion === v) continue;
            T._lastLookupTableVersion = v;
        }

        window.luckysheet_getcelldata_cache = null;
        const Rres = s.execfunction(T.calc_funcStr, T.r, T.c, T.index);

        s.execFunctionGlobalData[`${T.r}_${T.c}_${T.index}`] = {
            v: Rres[1],
            f: Rres[2]
        };

        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: Rres[1],
            f: Rres[2],
            spe: Rres[3],
            index: T.index
        });
    }

    // === LOOKUP OPTIMIZATION (bump table version on sheet change) ===
    for (const k in window.luckysheet_lookupTableVersion) {
        if (k.endsWith("@sheet" + l)) {
            window.luckysheet_lookupTableVersion[k]++;
        }
    }

    s.execFunctionExist = null;
},
