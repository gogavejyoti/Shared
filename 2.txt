execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;
    const s = this;

    if (a == null) a = h.flowdata;
    if (l == null) l = h.currentSheetIndex;

    // ----------------------------
    // 1Ô∏è‚É£ explicit value injection
    // ----------------------------
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);

        const sd = h.flowdata[l];
        if (sd && sd[e] && sd[e][n]) {
            sd[e][n].v = tmp[0][0].v;
            sd[e][n].f = null;
        }
    }

    // ----------------------------
    // 2Ô∏è‚É£ dependency graph (CACHED)
    // ----------------------------
    if (!s._execFGCache) {
        s._execFGCache = { graph: null, dirty: true };
    }

    let nodes;

    if (!s._execFGCache.dirty && s._execFGCache.graph) {
        // üî• FAST PATH
        nodes = s._execFGCache.graph;
    } else {
        // ‚ùó SLOW PATH (same logic as before)
        nodes = {};
        const rangeToKeysCache = {};

        function keysForRange(R) {
            const k = `${R.sheetIndex}_${R.row[0]}_${R.row[1]}_${R.column[0]}_${R.column[1]}`;
            if (rangeToKeysCache[k]) return rangeToKeysCache[k];
            const list = [];
            for (let rr = R.row[0]; rr <= R.row[1]; rr++) {
                for (let cc = R.column[0]; cc <= R.column[1]; cc++) {
                    list.push("r" + rr + "c" + cc + "i" + R.sheetIndex);
                }
            }
            rangeToKeysCache[k] = list;
            return list;
        }

        const allFuncCells = s.getAllFunctionGroup() || [];

        for (let i = 0; i < allFuncCells.length; i++) {
            const T = allFuncCells[i];
            const key = "r" + T.r + "c" + T.c + "i" + T.index;

            const f =
                zl(T.r, T.c, T.index) ||
                ve.getSheetByIndex(T.index)?.celldata?.find(
                    x => x?.r === T.r && x?.c === T.c
                )?.v?.f;

            if (!f) continue;

            nodes[key] = {
                key,
                r: T.r,
                c: T.c,
                index: T.index,
                calc_funcStr: f,
                parents: {},
                color: 0
            };

            const tokens = f.split(/==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/).filter(Boolean);
            for (let ti = 0; ti < tokens.length; ti++) {
                const rg = s.getcellrange(tokens[ti].trim(), T.index);
                if (!rg) continue;

                const deps = keysForRange(rg);
                for (let di = 0; di < deps.length; di++) {
                    if (deps[di] !== key) {
                        nodes[key].parents[deps[di]] = 1;
                    }
                }
            }
        }

        s._execFGCache.graph = nodes;
        s._execFGCache.dirty = false;
    }

    // ----------------------------
    // 3Ô∏è‚É£ topological order (FAST)
    // ----------------------------
    const ordered = [];
    const stack = Object.values(nodes);

    while (stack.length) {
        const cur = stack.pop();
        if (cur.color === 2) continue;

        if (cur.color === 1) {
            cur.color = 2;
            ordered.push(cur);
            continue;
        }

        cur.color = 1;
        stack.push(cur);
        for (const pk in cur.parents) {
            if (nodes[pk]) stack.push(nodes[pk]);
        }
    }

    ordered.reverse();

    // ----------------------------
    // 4Ô∏è‚É£ execute (ACCURATE)
    // ----------------------------
    window.luckysheet_getcelldata_cache = null;

    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];

        const Rres = s.execfunction(
            T.calc_funcStr,
            T.r,
            T.c,
            T.index
        );

        // üîë authoritative updates
        const sd = h.flowdata[T.index];
        if (sd && sd[T.r] && sd[T.r][T.c]) {
            sd[T.r][T.c].v = Rres[1];
            sd[T.r][T.c].f = Rres[2];
        }

        const sheet = ve.getSheetByIndex(T.index);
        if (sheet && Array.isArray(sheet.calcChain)) {
            for (let ci = 0; ci < sheet.calcChain.length; ci++) {
                const cc = sheet.calcChain[ci];
                if (cc.r === T.r && cc.c === T.c) {
                    cc.func[1] = Rres[1];
                    break;
                }
            }
        }

        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: Rres[1],
            f: Rres[2],
            spe: Rres[3],
            index: T.index
        });

        window.luckysheet_getcelldata_cache = null;
    }

    s.execFunctionExist = null;
},
