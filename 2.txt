// Required NuGet Packages:
// - Dapper
// - Microsoft.ML
// - Microsoft.ML.TimeSeries
// - System.Data.SqlClient

using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using Dapper;
using Microsoft.ML;
using Microsoft.ML.TimeSeries;

namespace WfmForecasting
{
    public class WfmMetric
    {
        public string Program { get; set; }
        public int AccountType { get; set; }
        public DateTime Month { get; set; }

        public float? OfferedToForecast { get; set; }
        public float? HandledToForecast { get; set; }
        public float? HandledToOffered { get; set; }
        public float? HandledToStaffing { get; set; }
        public float? Shrinkage { get; set; }
        public float? Attrition { get; set; }
        public float? Staffing { get; set; }
    }

    public class ForecastInput { public float Value { get; set; } }
    public class ForecastOutput { public float[] ForecastedValues { get; set; } }

    class Program
    {
        static void Main(string[] args)
        {
            string connString = "your_connection_string_here";
            var rawMetrics = LoadMetricsFromDatabase(connString);

            // Filter out bad entries early
            var validMetrics = rawMetrics
                .Where(m => !string.IsNullOrWhiteSpace(m.Program) && m.Month != default)
                .ToList();

            var byProgram = validMetrics.GroupBy(m => m.Program);

            foreach (var programGroup in byProgram)
            {
                string program = programGroup.Key;
                int accountType = programGroup.First().AccountType;
                Console.WriteLine($"\nðŸ”µ Forecast for Program: {program} (AccountType = {accountType})");

                if (accountType == 0)
                {
                    ForecastAndPrint(programGroup.ToList(), "OfferedToForecast", m => m.OfferedToForecast);
                    ForecastAndPrint(programGroup.ToList(), "HandledToForecast", m => m.HandledToForecast);
                    ForecastAndPrint(programGroup.ToList(), "HandledToOffered", m => m.HandledToOffered);
                    ForecastAndPrint(programGroup.ToList(), "HandledToStaffing", m => m.HandledToStaffing);
                }

                ForecastAndPrint(programGroup.ToList(), "Shrinkage", m => m.Shrinkage);
                ForecastAndPrint(programGroup.ToList(), "Attrition", m => m.Attrition);
                ForecastAndPrint(programGroup.ToList(), "Staffing", m => m.Staffing);
            }
        }

        static List<WfmMetric> LoadMetricsFromDatabase(string connectionString)
        {
            using var conn = new SqlConnection(connectionString);
            string sql = @"SELECT Program, AccountType, Month,
                            OfferedToForecast, HandledToForecast,
                            HandledToOffered, HandledToStaffing,
                            Shrinkage, Attrition, Staffing
                         FROM WfmMetrics";
            return conn.Query<WfmMetric>(sql).ToList();
        }

        static void ForecastAndPrint(List<WfmMetric> data, string metricName, Func<WfmMetric, float?> selector)
        {
            var cleanedSeries = data
                .OrderBy(x => x.Month)
                .Select(selector)
                .Where(v => v.HasValue && v.Value > 0 && v.Value < 1000) // filter nulls, zeros, garbage
                .Select(v => v.Value)
                .ToList();

            if (cleanedSeries.Count < 10)
            {
                Console.WriteLine($"âš ï¸ Skipping {metricName}: Not enough valid data points ({cleanedSeries.Count}).");
                return;
            }

            var forecast = Forecast(cleanedSeries);
            Console.WriteLine($"\nðŸ“ˆ {metricName} Forecast:");
            foreach (var (value, i) in forecast.Select((v, i) => (v, i + 1)))
                Console.WriteLine($"  Month +{i}: {value:F2}");
        }

        static List<float> Forecast(List<float> values, int horizon = 3)
        {
            var context = new MLContext();

            var data = values.Select(v => new ForecastInput { Value = v }).ToList();
            var dataView = context.Data.LoadFromEnumerable(data);

            var pipeline = context.Forecasting.ForecastBySsa(
                outputColumnName: nameof(ForecastOutput.ForecastedValues),
                inputColumnName: nameof(ForecastInput.Value),
                windowSize: 6,
                seriesLength: values.Count,
                trainSize: values.Count,
                horizon: horizon);

            var model = pipeline.Fit(dataView);
            var engine = model.CreateTimeSeriesEngine<ForecastInput, ForecastOutput>(context);
            return engine.Predict().ForecastedValues.ToList();
        }
    }
}
