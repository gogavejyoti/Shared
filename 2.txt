function buildStaffingTableMetricsFull(data, containerId, drillMode = "GeoToLob", viewMode = "Monthly") {
    const container = document.querySelector("#" + containerId);
    container.innerHTML = '';

    // Determine period key
    const timeKey = viewMode === "Weekly" ? "weekFormat" : "monthFormat";
    const chartData = (viewMode === "Weekly" && typeof weeklyData !== 'undefined') ? weeklyData
                    : (viewMode === "Monthly" && typeof monthData !== 'undefined') ? monthData
                    : data;

    // Collect and sort periods
    const periods = [...new Set(chartData.map(d => d[timeKey]).filter(x => x))]
        .map(p => ({ period: p, date: new Date(p) }))
        .sort((a,b) => a.date - b.date)
        .map(x => x.period);

    // Top dropdown row
    const topRow = document.createElement('div');
    topRow.style.marginBottom = '8px';

    const drillSelector = document.createElement("select");
    drillSelector.className = "form-select d-inline-block me-2";
    drillSelector.style.width = "180px";
    ["GeoToLob", "LobToGeo"].forEach(mode => {
        const opt = document.createElement("option");
        opt.value = mode;
        opt.innerText = mode === "GeoToLob" ? "Geo → LOB" : "LOB → Geo";
        if (mode === drillMode) opt.selected = true;
        drillSelector.appendChild(opt);
    });

    const viewSelector = document.createElement("select");
    viewSelector.className = "form-select d-inline-block";
    viewSelector.style.width = "140px";
    ["Weekly", "Monthly"].forEach(mode => {
        const opt = document.createElement("option");
        opt.value = mode;
        opt.innerText = mode;
        if (mode === viewMode) opt.selected = true;
        viewSelector.appendChild(opt);
    });

    drillSelector.addEventListener("change", () => buildStaffingTableMetricsFull(data, containerId, drillSelector.value, viewSelector.value));
    viewSelector.addEventListener("change", () => buildStaffingTableMetricsFull(data, containerId, drillSelector.value, viewSelector.value));

    topRow.appendChild(drillSelector);
    topRow.appendChild(viewSelector);
    container.appendChild(topRow);

    // Groups
    const groups = drillMode === "GeoToLob"
        ? [...new Set(chartData.map(d => d.geo))]
        : [...new Set(chartData.map(d => d.lob))];

    // Table
    const table = document.createElement('table');
    table.className = 'table table-bordered';
    table.style.minWidth = (Math.max(1, periods.length) * 150 + 160) + 'px';

    // Header
    const thead = document.createElement('thead');
    const tr1 = document.createElement('tr');
    const thGroup = document.createElement('th');
    thGroup.rowSpan = 2;
    thGroup.innerText = drillMode === "GeoToLob" ? "Geo" : "LOB";
    tr1.appendChild(thGroup);

    periods.forEach(p => {
        const th = document.createElement('th');
        th.colSpan = 5;
        th.innerText = p;
        tr1.appendChild(th);
    });
    thead.appendChild(tr1);

    const tr2 = document.createElement('tr');
    periods.forEach(() => ['Planned Shrinkage','Actual Shrinkage','Planned Attrition','Actual Attrition','OTF %'].forEach(h=>{
        const th = document.createElement('th');
        th.innerText = h;
        tr2.appendChild(th);
    }));
    thead.appendChild(tr2);
    table.appendChild(thead);

    // Body
    const tbody = document.createElement('tbody');

    // Overall summary row
    const trSummary = document.createElement("tr");
    trSummary.className = "table-primary fw-bold";
    const tdSummary = document.createElement("td");
    tdSummary.innerText = "Overall Summary";
    trSummary.appendChild(tdSummary);

    periods.forEach(period=>{
        const recs = chartData.filter(d=>d[timeKey]===period);
        const totalAvailable = recs.reduce((s,r)=>s+(r.availableHC||0),0);
        const plannedShrinkage = totalAvailable>0 ? Math.round(recs.reduce((s,r)=>s+(r.availableHC*(r.plannedShrinkage||0)),0)/totalAvailable) : 0;
        const actualShrinkage = totalAvailable>0 ? Math.round(recs.reduce((s,r)=>s+(r.availableHC*(r.actualShrinkage||0)),0)/totalAvailable) : 0;
        const plannedAttrition = totalAvailable>0 ? Math.round(recs.reduce((s,r)=>s+(r.availableHC*(r.plannedAttrition||0)),0)/totalAvailable) : 0;
        const actualAttrition = totalAvailable>0 ? Math.round(recs.reduce((s,r)=>s+(r.availableHC*(r.actualAttrition||0)),0)/totalAvailable) : 0;
        const otf = recs.reduce((s,r)=>s+(r.actualHours||0),0)>0
                    ? Math.round(recs.reduce((s,r)=>s+(r.forecastedHours||0),0)/recs.reduce((s,r)=>s+(r.actualHours||0),0)*100)
                    : 0;

        [plannedShrinkage, actualShrinkage, plannedAttrition, actualAttrition, otf].forEach(val=>{
            const td = document.createElement('td');
            td.innerText = val + "%";
            trSummary.appendChild(td);
        });
    });
    tbody.appendChild(trSummary);

    // Drilldown
    groups.forEach(group=>{
        const tr = document.createElement('tr');
        tr.className = 'groupRow';
        tr.style.cursor = 'pointer';
        const tdGroup = document.createElement('td');
        tdGroup.innerText = group;
        tr.appendChild(tdGroup);

        periods.forEach(period=>{
            const recs = chartData.filter(d =>
                (drillMode==="GeoToLob"?d.geo===group:d.lob===group) && d[timeKey]===period
            );
            const totalAvailable = recs.reduce((s,r)=>s+(r.availableHC||0),0);
            const plannedShrinkage = totalAvailable>0 ? Math.round(recs.reduce((s,r)=>s+(r.availableHC*(r.plannedShrinkage||0)),0)/totalAvailable) : 0;
            const actualShrinkage = totalAvailable>0 ? Math.round(recs.reduce((s,r)=>s+(r.availableHC*(r.actualShrinkage||0)),0)/totalAvailable) : 0;
            const plannedAttrition = totalAvailable>0 ? Math.round(recs.reduce((s,r)=>s+(r.availableHC*(r.plannedAttrition||0)),0)/totalAvailable) : 0;
            const actualAttrition = totalAvailable>0 ? Math.round(recs.reduce((s,r)=>s+(r.availableHC*(r.actualAttrition||0)),0)/totalAvailable) : 0;
            const otf = recs.reduce((s,r)=>s+(r.actualHours||0),0)>0
                        ? Math.round(recs.reduce((s,r)=>s+(r.forecastedHours||0),0)/recs.reduce((s,r)=>s+(r.actualHours||0),0)*100)
                        : 0;

            [plannedShrinkage, actualShrinkage, plannedAttrition, actualAttrition, otf].forEach(val=>{
                const td = document.createElement('td');
                td.innerText = val + "%";
                tr.appendChild(td);
            });
        });
        tbody.appendChild(tr);

        // Child rows
        const children = drillMode==="GeoToLob"
            ? [...new Set(chartData.filter(d=>d.geo===group).map(d=>d.lob))]
            : [...new Set(chartData.filter(d=>d.lob===group).map(d=>d.geo))];

        children.forEach(child=>{
            const trChild = document.createElement('tr');
            trChild.className="childRow";
            trChild.style.display="none";
            trChild.style.background="#525252";
            trChild.style.fontStyle="italic";
            trChild.style.fontSize="0.85em";
            const tdChild = document.createElement('td');
            tdChild.innerText = "   └ "+child;
            trChild.appendChild(tdChild);

            periods.forEach(period=>{
                const recs = chartData.filter(d =>
                    (drillMode==="GeoToLob"?d.geo===group && d.lob===child:d.lob===group && d.geo===child)
                    && d[timeKey]===period
                );
                const totalAvailable = recs.reduce((s,r)=>s+(r.availableHC||0),0);
                const plannedShrinkage = totalAvailable>0 ? Math.round(recs.reduce((s,r)=>s+(r.availableHC*(r.plannedShrinkage||0)),0)/totalAvailable) : 0;
                const actualShrinkage = totalAvailable>0 ? Math.round(recs.reduce((s,r)=>s+(r.availableHC*(r.actualShrinkage||0)),0)/totalAvailable) : 0;
                const plannedAttrition = totalAvailable>0 ? Math.round(recs.reduce((s,r)=>s+(r.availableHC*(r.plannedAttrition||0)),0)/totalAvailable) : 0;
                const actualAttrition = totalAvailable>0 ? Math.round(recs.reduce((s,r)=>s+(r.availableHC*(r.actualAttrition||0)),0)/totalAvailable) : 0;
                const otf = recs.reduce((s,r)=>s+(r.actualHours||0),0)>0
                            ? Math.round(recs.reduce((s,r)=>s+(r.forecastedHours||0),0)/recs.reduce((s,r)=>s+(r.actualHours||0),0)*100)
                            : 0;

                [plannedShrinkage, actualShrinkage, plannedAttrition, actualAttrition, otf].forEach(val=>{
                    const td = document.createElement('td');
                    td.innerText = val + "%";
                    trChild.appendChild(td);
                });
            });
            tbody.appendChild(trChild);
        });

        tr.addEventListener('click', ()=>{
            let next = tr.nextElementSibling;
            while(next && next.classList.contains("childRow")){
                next.style.display = (next.style.display==="none")?"table-row":"none";
                next = next.nextElementSibling;
            }
        });
    });

    table.appendChild(tbody);
    container.appendChild(table);
}
