pasteHandlerOfCopyPaste: async function (e) {
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex)) return;

    const self = this;
    const t = Q().paste;

    let l = $.extend(!0, {}, h.config);
    l.merge == null && (l.merge = {});

    let a = e.HasMC,
        o = e.RowlChange,
        s = e.dataSheetIndex,
        u = e.copyRange[0].row[0],
        d = e.copyRange[0].row[1],
        f = e.copyRange[0].column[0],
        m = e.copyRange[0].column[1],
        g = [],
        y = !1;

    /* -------------------------------
       Build copied matrix
    -------------------------------- */
    for (let se = 0; se < e.copyRange.length; se++) {
        let ie = Nt({ row: e.copyRange[se].row, column: e.copyRange[se].column }, s);

        if (e.copyRange.length > 1) {
            if (u === e.copyRange[1].row[0] && d === e.copyRange[1].row[1]) {
                ie = ie[0].map((_, idx) => ie.map(r => r[idx]));
                g = g.concat(ie);
                y = !0;
            } else if (f === e.copyRange[1].column[0] && m === e.copyRange[1].column[1]) {
                g = g.concat(ie);
            }
        } else {
            g = ie;
        }
    }

    if (y) {
        g = g[0].map((_, idx) => g.map(r => r[idx]));
    }

    let v = $.extend(!0, [], g);

    // remove formula metadata when multi-range copy
    if (e.copyRange.length > 1) {
        for (let r = 0; r < v.length; r++) {
            for (let c = 0; c < v[r].length; c++) {
                if (v[r][c]?.f != null) {
                    delete v[r][c].f;
                    delete v[r][c].spl;
                }
            }
        }
    }

    let k = v.length,
        b = v[0].length,
        sel = h.luckysheet_select_save.at(-1),
        x = sel.row[0],
        C = sel.row[1],
        S = sel.column[0],
        _ = sel.column[1];

    let T = (C - x + 1) % k,
        A = (_ - S + 1) % b;

    if (T !== 0 || A !== 0) {
        C = x + k - 1;
        _ = S + b - 1;
    }

    if (l.merge && Dt(l, x, C, S, _)) {
        de()
            ? alert(t.errorNotAllowMerged)
            : U.info(`<i class="fa fa-exclamation-triangle"></i>${t.warning}`, t.errorNotAllowMerged);
        return;
    }

    /* -------------------------------
       Clone and expand flowdata
    -------------------------------- */
    let N = we.deepCopyFlowData(h.flowdata);
    let addRow = k + x - N.length;
    let addCol = b + S - N[0].length;
    (addRow > 0 || addCol > 0) && (N = il([].concat(N), addRow, addCol, !0));

    let borderMap = Ur(s);
    let dvSource = $.extend(!0, {}, h.luckysheetfile[K(s)].dataVerification);
    let dvTarget = null;

    /* -------------------------------
       Paste loop
    -------------------------------- */
    for (let r = x; r <= C; r++) {
        let row = [].concat(N[r]);
        for (let c = S; c <= _; c++) {
            let src = v[r - x]?.[c - S];
            let cell = src ? $.extend(!0, {}, src) : null;

            // formula shift + recalc
            if (cell?.f) {
                let fr = r - u;
                let fc = c - f;
                let F = cell.f;

                fr > 0 && (F = "=" + self.functionCopy(F, "down", fr));
                fr < 0 && (F = "=" + self.functionCopy(F, "up", -fr));
                fc > 0 && (F = "=" + self.functionCopy(F, "right", fc));
                fc < 0 && (F = "=" + self.functionCopy(F, "left", -fc));

                let res = self.execfunction(F, r, c, void 0, !0);
                cell.f = res[2];
                cell.v = res[1];
                cell.ct?.fa && (cell.m = mt(cell.ct.fa, res[1]));
            }

            row[c] = cell;
        }
        N[r] = row;
    }

    // update selection
    sel.row = [x, C];
    sel.column = [S, _];

    /* ------------------------------------------------
       ✅ CRITICAL FIX
       Recalculate using UPDATED flowdata
    ------------------------------------------------ */
    await Promise.resolve(
        self.execFunctionGroup(
            x,                   // start row
            S,                   // start column
            null,
            h.currentSheetIndex,
            N                    // ✅ UPDATED flowdata
        )
    );

    /* -------------------------------
       Apply UI changes AFTER calc
    -------------------------------- */
    if (o || addRow > 0 || addCol > 0) {
        l = yl(N, x, C, l);
        Ye(N, h.luckysheet_select_save, { cfg: l, RowlChange: !0 });
    } else {
        Ye(N, h.luckysheet_select_save, { cfg: l });
        tt();
    }
}
