update: function () {
    const e = this;

    if (!gr([e.applyRange], h.currentSheetIndex) || h.allowEdit === false) return;

    const sheetIndex = h.currentSheetIndex;
    const sheet = h.luckysheetfile[K(sheetIndex)];

    // ðŸ”´ DO NOT deep copy whole sheet
    const data = h.flowdata;

    const cfg = $.extend(true, {}, h.config);
    if (!cfg.merge) cfg.merge = {};

    const borders = Ur();
    const dataVerification = $.extend(true, {}, sheet.dataVerification);

    const dir = e.direction;
    const copyRange = e.copyRange;

    const src = {
        r1: copyRange.row[0],
        r2: copyRange.row[1],
        c1: copyRange.column[0],
        c2: copyRange.column[1]
    };

    const dst = {
        r1: e.applyRange.row[0],
        r2: e.applyRange.row[1],
        c1: e.applyRange.column[0],
        c2: e.applyRange.column[1]
    };

    const copyData = e.getCopyData(
        data,
        src.r1, src.r2,
        src.c1, src.c2,
        dir
    );

    const span =
        dir === "left" || dir === "right"
            ? src.c2 - src.c1 + 1
            : src.r2 - src.r1 + 1;

    // ðŸŸ¢ Track dirty cells
    const dirtyCells = [];

    // =========================
    // APPLY FORMULAS (NO EVAL)
    // =========================

    if (dir === "right" || dir === "left") {
        const width = dst.c2 - dst.c1 + 1;

        for (let r = dst.r1; r <= dst.r2; r++) {
            const template = copyData[r - dst.r1];
            const applied = e.getApplyData(template, span, width);

            for (
                let c = dir === "right" ? dst.c1 : dst.c2;
                dir === "right" ? c <= dst.c2 : c >= dst.c1;
                dir === "right" ? c++ : c--
            ) {
                const idx = dir === "right" ? c - dst.c1 : dst.c2 - c;
                const cell = applied[idx];

                if (cell.f != null) {
                    cell.f =
                        "=" +
                        p.functionCopy(
                            cell.f,
                            dir,
                            idx + 1
                        );
                    cell.v = null;
                    cell.m = null;
                }

                data[r][c] = cell;
                dirtyCells.push({ r, c, index: sheetIndex });

                // borders
                const srcCol =
                    dir === "right"
                        ? src.c1 + (c - dst.c1) % span
                        : src.c2 - (dst.c2 - c) % span;

                if (borders[r + "_" + srcCol]) {
                    cfg.borderInfo.push({
                        rangeType: "cell",
                        value: {
                            row_index: r,
                            col_index: c,
                            ...borders[r + "_" + srcCol]
                        }
                    });
                }

                if (dataVerification[r + "_" + srcCol]) {
                    dataVerification[r + "_" + c] =
                        dataVerification[r + "_" + srcCol];
                }
            }
        }
    }

    if (dir === "down" || dir === "up") {
        const height = dst.r2 - dst.r1 + 1;

        for (let c = dst.c1; c <= dst.c2; c++) {
            const template = copyData[c - dst.c1];
            const applied = e.getApplyData(template, span, height);

            for (
                let r = dir === "down" ? dst.r1 : dst.r2;
                dir === "down" ? r <= dst.r2 : r >= dst.r1;
                dir === "down" ? r++ : r--
            ) {
                const idx = dir === "down" ? r - dst.r1 : dst.r2 - r;
                const cell = applied[idx];

                if (cell.f != null) {
                    cell.f =
                        "=" +
                        p.functionCopy(
                            cell.f,
                            dir,
                            idx + 1
                        );
                    cell.v = null;
                    cell.m = null;
                }

                data[r][c] = cell;
                dirtyCells.push({ r, c, index: sheetIndex });

                const srcRow =
                    dir === "down"
                        ? src.r1 + (r - dst.r1) % span
                        : src.r2 - (dst.r2 - r) % span;

                if (borders[srcRow + "_" + c]) {
                    cfg.borderInfo.push({
                        rangeType: "cell",
                        value: {
                            row_index: r,
                            col_index: c,
                            ...borders[srcRow + "_" + c]
                        }
                    });
                }

                if (dataVerification[srcRow + "_" + c]) {
                    dataVerification[r + "_" + c] =
                        dataVerification[srcRow + "_" + c];
                }
            }
        }
    }

    // =========================
    // SINGLE DEPENDENCY BUILD
    // =========================

    window.luckysheet_getcelldata_cache = null;

    // ðŸ”¥ ONE graph build + topo evaluation
    p.execFunctionGroup(
        null,
        null,
        null,
        sheetIndex,
        data,
        true
    );

    // =========================
    // FINAL APPLY
    // =========================

    const conditionFormat = $.extend(true, [], sheet.luckysheet_conditionformat_save);

    Ye(data, h.luckysheet_select_save, {
        cfg,
        cdformat: conditionFormat,
        dataVerification
    });

    tt();
}
