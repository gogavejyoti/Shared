pasteHandlerOfCopyPaste: function (e) {
    const d = Store.luckysheetfile[getSheetIndex(Store.currentSheetIndex)];
    if (!d || !d.data || !Store.clipboard || !Store.clipboard.data) return;

    const clipboard = Store.clipboard;
    const range = getPasteRange(e, clipboard.range);
    if (!range) return;

    const r1 = range.row[0], r2 = range.row[1];
    const c1 = range.column[0], c2 = range.column[1];
    const data = d.data;

    const cache = new Map(); // formulaText -> value
    const depMap = new Map(); // "r,c" -> { f, deps:[] }
    const indegree = new Map(); // "r,c" -> number
    const formulaCells = [];
    const keyOf = (r, c) => r + "," + c;

    // --- STEP 1: Paste & collect dependency info ---
    for (let r = r1; r <= r2; r++) {
        for (let c = c1; c <= c2; c++) {
            const clipR = r - r1;
            const clipC = c - c1;
            const clipCell = clipboard.data[clipR]?.[clipC];
            if (!clipCell) continue;

            const cell = {};
            if (clipCell.f) {
                const shiftedF = p.functionCopy(
                    clipCell.f,
                    r - clipboard.range.row[0],
                    c - clipboard.range.column[0]
                );
                cell.f = shiftedF;

                // collect dependencies within pasted range
                const deps = [];
                const refRegex = /\$?[A-Z]+\$?\d+/g;
                let m;
                while ((m = refRegex.exec(shiftedF)) !== null) {
                    const ref = m[0];
                    const colLetters = ref.match(/[A-Z]+/)[0];
                    const rowNumber = parseInt(ref.match(/\d+/)[0], 10);
                    const refR = rowNumber - 1;
                    const refC = colLetters.split('').reduce((acc, ch) => acc * 26 + (ch.charCodeAt(0) - 64), 0) - 1;
                    if (refR >= r1 && refR <= r2 && refC >= c1 && refC <= c2) {
                        deps.push(keyOf(refR, refC));
                    }
                }

                const key = keyOf(r, c);
                depMap.set(key, { r, c, f: shiftedF, deps });
                indegree.set(key, deps.length);
                formulaCells.push(key);
            } else {
                if (clipCell.v !== undefined) cell.v = clipCell.v;
                if (clipCell.m !== undefined) cell.m = clipCell.m;
            }
            data[r][c] = cell;
        }
    }

    // --- STEP 2: Topological sort (Kahnâ€™s algorithm) ---
    const queue = [];
    for (const key of formulaCells) {
        if (indegree.get(key) === 0) queue.push(key);
    }

    const topoOrder = [];
    while (queue.length) {
        const nodeKey = queue.shift();
        topoOrder.push(nodeKey);
        const { r, c } = depMap.get(nodeKey);

        // Find formulas that depend on this cell
        for (const [k, val] of depMap) {
            if (val.deps.includes(nodeKey)) {
                indegree.set(k, indegree.get(k) - 1);
                if (indegree.get(k) === 0) queue.push(k);
            }
        }
    }

    // --- STEP 3: Evaluate formulas in dependency order ---
    for (const key of topoOrder) {
        const { r, c, f } = depMap.get(key);

        if (cache.has(f)) {
            const v = cache.get(f);
            data[r][c].v = v;
            data[r][c].m = v;
            continue;
        }

        try {
            const v = p.execfunction(f, r, c, undefined, true);
            data[r][c].v = v;
            data[r][c].m = v;
            cache.set(f, v);
        } catch (err) {
            console.error("Formula error at", key, f, err);
            data[r][c].v = null;
            data[r][c].m = "#ERROR!";
        }
    }

    // --- STEP 4: Refresh grid once ---
    luckysheetrefreshgrid();
}
