execFunctionGroup: function (e, n, t, l, a, o = false) {
    if (o) return;

    const s = this;
    if (a == null) a = h.flowdata;
    if (l == null) l = h.currentSheetIndex;

    // ---------- Init helpers ----------
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    // ---------- Store explicit value ----------
    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // ---------- Collect function cells ----------
    const allFuncCells = s.getAllFunctionGroup() || [];
    const nodes = {};
    const rangeCache = {};

    function keysForRange(R) {
        const key = `${R.row[0]}_${R.row[1]}_${R.column[0]}_${R.column[1]}_${R.sheetIndex}`;
        if (rangeCache[key]) return rangeCache[key];
        const list = [];
        for (let r = R.row[0]; r <= R.row[1]; r++) {
            for (let c = R.column[0]; c <= R.column[1]; c++) {
                list.push("r" + r + "c" + c + "i" + R.sheetIndex);
            }
        }
        return (rangeCache[key] = list);
    }

    // ---------- Build nodes ----------
    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const key = "r" + T.r + "c" + T.c + "i" + T.index;
        const formula = zl(T.r, T.c, T.index);
        if (!formula) continue;

        nodes[key] = {
            key,
            r: T.r,
            c: T.c,
            index: T.index,
            formula,
            parents: {},
            children: {}
        };
    }

    // ---------- Build dependency graph ----------
    for (const k in nodes) {
        const node = nodes[k];
        const refs = [];

        if (/INDIRECT|OFFSET|INDEX/i.test(node.formula)) {
            this.isFunctionRange(node.formula, null, null, node.index, null, ref => {
                const rg = s.getcellrange($.trim(ref), node.index);
                rg && refs.push(rg);
            });
        } else {
            const tokens = node.formula.split(/[,()=+\-/*^%&<>]/);
            for (let i = 0; i < tokens.length; i++) {
                const rg = s.getcellrange(tokens[i].trim(), node.index);
                rg && refs.push(rg);
            }
        }

        for (let i = 0; i < refs.length; i++) {
            const keys = keysForRange(refs[i]);
            for (let j = 0; j < keys.length; j++) {
                const dep = keys[j];
                if (nodes[dep]) {
                    node.children[dep] = 1;
                    nodes[dep].parents[k] = 1;
                }
            }
        }
    }

    // ---------- Initial changed cells ----------
    const execSet = {};
    if (s.execFunctionExist) {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const T = s.execFunctionExist[i];
            execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
        }
    } else if (e != null && n != null) {
        execSet["r" + e + "c" + n + "i" + l] = 1;
    }

    // ---------- Expand ALL downstream dependents ----------
    const queue = Object.keys(execSet);
    while (queue.length) {
        const k = queue.shift();
        const node = nodes[k];
        if (!node) continue;
        for (const ch in node.children) {
            if (!execSet[ch]) {
                execSet[ch] = 1;
                queue.push(ch);
            }
        }
    }

    // ---------- Topological sort ----------
    const visited = {};
    const order = [];

    function dfs(k) {
        if (visited[k]) return;
        visited[k] = 1;
        const node = nodes[k];
        if (!node) return;
        for (const p in node.parents) dfs(p);
        order.push(node);
    }

    for (const k in execSet) dfs(k);

    // ---------- Recalculate ----------
    window.luckysheet_getcelldata_cache = null;
    for (let i = 0; i < order.length; i++) {
        const T = order[i];
        const R = s.execfunction(T.formula, T.r, T.c, T.index);
        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: R[1],
            f: R[2],
            spe: R[3],
            index: T.index
        });
        s.execFunctionGlobalData[T.r + "_" + T.c + "_" + T.index] = {
            v: R[1],
            f: R[2]
        };
    }

    s.execFunctionExist = null;
}
