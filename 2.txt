function fixCrossSheetReferencesAfterRename(oldName, newName) {
    const allSheets = Ft() || [];
    let sheetChanged = false;

    // Matches both quoted ('Sheet 1') and unquoted (Sheet1) names, with optional ranges
    const referenceRegex = /(?:'([^']+)'|([A-Za-z0-9_]+))!([A-Z]+)(\d+)(:([A-Z]+)(\d+))?/g;

    // --- 1️⃣ Update formulas in each sheet's data
    for (let s = 0; s < allSheets.length; s++) {
        const sheet = allSheets[s];
        const data = sheet.data;
        if (!data) continue;

        for (let r = 0; r < data.length; r++) {
            if (!data[r]) continue;

            for (let c = 0; c < data[r].length; c++) {
                const cell = data[r][c];
                if (!cell || !cell.f) continue;

                let originalFormula = cell.f;
                let modifiedFormula = originalFormula;

                modifiedFormula = modifiedFormula.replace(referenceRegex, function(
                    match, quotedSheet, unquotedSheet, startCol, startRow, _range, endCol, endRow
                ) {
                    let sheetName = quotedSheet || unquotedSheet;
                    if (sheetName !== oldName) return match; // only rename target sheet

                    // Build new reference with newName
                    let startRef = `${_columnIndexToLetter(_columnLetterToIndex(startCol))}${startRow}`;
                    let endRef = endCol ? `${_columnIndexToLetter(_columnLetterToIndex(endCol))}${endRow}` : startRef;

                    return startRef === endRef
                        ? `'${newName}'!${startRef}`
                        : `'${newName}'!${startRef}:${endRef}`;
                });

                if (modifiedFormula !== originalFormula) {
                    cell.f = modifiedFormula;
                    sheetChanged = true;
                }
            }
        }
    }

    // --- 2️⃣ Update calcChain / m
    if (typeof Store !== "undefined" && Store.luckysheetfile) {
        for (let i = 0; i < Store.luckysheetfile.length; i++) {
            const sheet = Store.luckysheetfile[i];
            const m = sheet.calcChain || sheet.m; // depends on LuckySheet version
            if (!m || !Array.isArray(m)) continue;

            for (let j = 0; j < m.length; j++) {
                const chainItem = m[j];
                if (!chainItem || !chainItem.f) continue;

                let originalFormula = chainItem.f;
                let modifiedFormula = originalFormula.replace(referenceRegex, function(
                    match, quotedSheet, unquotedSheet, startCol, startRow, _range, endCol, endRow
                ) {
                    let sheetName = quotedSheet || unquotedSheet;
                    if (sheetName !== oldName) return match;

                    let startRef = `${_columnIndexToLetter(_columnLetterToIndex(startCol))}${startRow}`;
                    let endRef = endCol ? `${_columnIndexToLetter(_columnLetterToIndex(endCol))}${endRow}` : startRef;

                    return startRef === endRef
                        ? `'${newName}'!${startRef}`
                        : `'${newName}'!${startRef}:${endRef}`;
                });

                if (modifiedFormula !== originalFormula) {
                    chainItem.f = modifiedFormula;
                    sheetChanged = true;
                }
            }
        }
    }

    // --- 3️⃣ Trigger workbook recalculation if needed
    if (sheetChanged) {
        if (typeof jf !== "undefined" && jf.refresh) {
            jf.refresh();
        } else if (typeof luckysheetrefreshgrid === "function") {
            luckysheetrefreshgrid();
        }
    }

    // --- Helper functions ---
    function _columnLetterToIndex(col) {
        let index = 0;
        for (let i = 0; i < col.length; i++) {
            index = index * 26 + (col.charCodeAt(i) - 65 + 1);
        }
        return index - 1;
    }

    function _columnIndexToLetter(index) {
        let col = "";
        index += 1;
        while (index > 0) {
            let rem = (index - 1) % 26;
            col = String.fromCharCode(65 + rem) + col;
            index = Math.floor((index - 1) / 26);
        }
        return col;
    }
}
