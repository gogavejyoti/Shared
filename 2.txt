
// Paste handler with support for "Paste Special: Values"
pasteHandler: function (e, n, options = { mode: 'normal' }) {
    // guardrails
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex) || h.allowEdit === !1) return;

    const l = Q().paste;
    const isValuesOnly = options.mode === 'values';

    // multiple selections not allowed
    if (h.luckysheet_select_save.length > 1) {
        de() ? alert(l.errorNotAllowMulti) : U.info(`<i class="fa fa-exclamation-triangle"></i>${l.warning}`, l.errorNotAllowMulti);
        return;
    }

    // helper: derive value-only payload while keeping destination format
    function pasteValueOnly(srcCell, dstCell) {
        let v;

        // source may be Luckysheet cell object or primitive
        if (srcCell && typeof srcCell === 'object') {
            // Prefer computed value if present
            if (srcCell.v !== undefined && srcCell.v !== null) {
                v = srcCell.v;
            } else if (srcCell.m !== undefined && srcCell.m !== null) {
                // fallback: try parsing m if numeric else keep string
                v = B(srcCell.m) ? parseFloat(srcCell.m) : srcCell.m;
            } else {
                v = null;
            }
        } else {
            v = srcCell; // primitive from text branch etc.
        }

        // Keep destination number format if present
        const dstFa = dstCell && dstCell.ct && dstCell.ct.fa ? dstCell.ct.fa : null;

        // Keep destination ct if present, otherwise infer a general type
        const inferred = it(v); // [m, ct, v]; Luckysheet helper
        const ct = dstCell && dstCell.ct ? dstCell.ct : inferred[1];

        // Render m using destination format if available, otherwise use inferred/general
        const m = dstFa ? mt(dstFa, v) : (ct && ct.fa ? mt(ct.fa, v) : (v === null || v === undefined ? "" : String(v)));

        return { v, m, ct };
    }

    // OBJECT CLIPBOARD (structured 2D array of cells)
    if (typeof e === "object") {
        if (e.length == 0) return;

        let a = $.extend(!0, {}, h.config);
        // For values-only we DO NOT copy borderInfo nor rowlen changes
        a.merge == null && (a.merge = {});
        JSON.stringify(n).length > 2 && !isValuesOnly && a.borderInfo == null && (a.borderInfo = []);

        const o = e.length;
        const s = e[0].length;
        const u = h.luckysheet_select_save[0].row[0];
        const d = u + o - 1;
        const f = h.luckysheet_select_save[0].column[0];
        const m = f + s - 1;

        // disallow paste into merged intersections
        let intersectsMerge = !1;
        if (a.merge != null) intersectsMerge = Dt(a, u, d, f, m);
        if (intersectsMerge) {
            de() ? alert(l.errorNotAllowMerged) : U.info(`<i class="fa fa-exclamation-triangle"></i>${l.warning}`, l.errorNotAllowMerged);
            return;
        }

        // expand flowdata if needed
        let y = we.deepCopyFlowData(h.flowdata);
        const v = y.length, k = y[0].length;
        const addRows = d - v + 1;
        const addCols = m - k + 1;
        (addRows > 0 || addCols > 0) && (y = il([].concat(y), addRows, addCols, !0));

        // Values-only: do NOT auto-change row heights
        a.rowlen == null && (a.rowlen = {});
        let C = {}; // merge mapping temp

        for (let S = u; S <= d; S++) {
            let row = [].concat(y[S]);

            for (let A = f; A <= m; A++) {
                // strip destination merge markers in target range
                if (L(row[A]) === "object" && "mc" in row[A]) {
                    if ("rs" in row[A].mc) delete a.merge[row[A].mc.r + "_" + row[A].mc.c];
                    delete row[A].mc;
                }

                // source cell from clipboard shape
                const src = e[S - u] && e[S - u][A - f] != null ? e[S - u][A - f] : null;

                if (isValuesOnly) {
                    // paste ONLY values; preserve destination formatting
                    const dst = row[A];
                    const newCell = pasteValueOnly(src, dst);

                    // clear destination formula if any (Excel behavior when overwriting)
                    if (dst && dst.f && dst.f.length > 0) {
                        newCell.f = ""; // or omit entirely
                        p.delFunctionGroup(S, A, h.currentSheetIndex);
                    }

                    // ensure merges from source are not propagated
                    if (newCell.mc) delete newCell.mc;

                    row[A] = newCell;
                } else {
                    // original behavior (formats + merges + borders)
                    let R = null;
                    if (src != null) R = src;
                    row[A] = $.extend(!0, {}, R);

                    // rewire merge anchors
                    if (R != null && "mc" in row[A]) {
                        if (row[A].mc.rs != null) {
                            row[A].mc.r = S;
                            row[A].mc.c = A;
                            a.merge[row[A].mc.r + "_" + row[A].mc.c] = row[A].mc;
                            C[R.mc.r + "_" + R.mc.c] = [row[A].mc.r, row[A].mc.c];
                        } else {
                            row[A] = { mc: { r: C[R.mc.r + "_" + R.mc.c][0], c: C[R.mc.r + "_" + R.mc.c][1] } };
                        }
                    }

                    // copy borders if provided
                    if (n[S - u + "_" + (A - f)]) {
                        a.borderInfo.push({
                            rangeType: "cell",
                            value: {
                                row_index: S,
                                col_index: A,
                                l: n[S - u + "_" + (A - f)].l,
                                r: n[S - u + "_" + (A - f)].r,
                                t: n[S - u + "_" + (A - f)].t,
                                b: n[S - u + "_" + (A - f)].b
                            }
                        });
                    }

                    // auto row height by text (original behavior)
                    const font = ra(row[A]);
                    const textH = be.getTextSize("ç”°", font)[1];
                    let T = h.defaultrowlen;
                    a.rowlen[S] != null && (T = a.rowlen[S]);
                    if (textH > T) a.rowlen[S] = textH;
                }
            }

            y[S] = row;
        }

        // update selection to pasted region
        h.luckysheet_select_save = [{ row: [u, d], column: [f, m] }];

        const payload = isValuesOnly ? { cfg: a } : { cfg: a, RowlChange: !0 };
        // If only expanding rows/cols due to overflow, we can still mark RowlChange for layout
        const needExpand = (addRows > 0 || addCols > 0);
        Ye(y, h.luckysheet_select_save, needExpand ? { cfg: a, RowlChange: !0 } : payload);
        if (!needExpand && !isValuesOnly) tt();

    } else {
        // STRING CLIPBOARD (tab-delimited text)
        e = e.replace(/\r/g, "");
        let a = [];
        const o = e.split(`\n`);
        const s = o[0].split("\t").length;

        for (let w = 0; w < o.length; w++) {
            if (o[w].split("\t").length >= s) {
                a.push(o[w].split("\t"));
            }
        }

        let u = we.deepCopyFlowData(h.flowdata);
        const d = h.luckysheet_select_save[h.luckysheet_select_save.length - 1];
        const f = d.row == null ? 0 : d.row[0];
        const m = d.column == null ? 0 : d.column[0];

        const g = a.length;
        const y = a[0].length;

        // disallow paste into merged intersections
        let intersectsMerge = !1;
        if (h.config.merge != null) intersectsMerge = Dt(h.config, f, f + g - 1, m, m + y - 1);
        if (intersectsMerge) {
            de() ? alert(l.errorNotAllowMerged) : U.info(`<i class="fa fa-exclamation-triangle"></i>${l.warning}`, l.errorNotAllowMerged);
            return;
        }

        // expand canvas if needed
        const addRows = f + g - u.length;
        const addCols = m + y - u[0].length;
        (addRows > 0 || addCols > 0) && (u = il([].concat(u), addRows, addCols, !0));

        for (let w = 0; w < g; w++) {
            let row = [].concat(u[w + f]);
            for (let C = 0; C < y; C++) {
                let dst = row[C + m];
                let srcVal = a[w][C];

                // numeric detection same as original
                if (B(srcVal)) {
                    // If destination explicitly has text format '@', keep as string
                    srcVal = (dst && dst.ct && dst.ct.fa === "@") ? String(srcVal) : parseFloat(srcVal);
                }

                if (dst instanceof Object) {
                    // Values-only behavior:
                    // - set only v
                    // - render m using DESTINATION format if present
                    // - keep dst.ct; DO NOT overwrite formatting
                    dst.v = srcVal;
                    dst.m = (dst.ct && dst.ct.fa) ? mt(dst.ct.fa, srcVal) : (srcVal === null || srcVal === undefined ? "" : String(srcVal));

                    // Overwriting a formula clears it (Excel behavior)
                    if (dst.f != null && dst.f.length > 0) {
                        dst.f = "";
                        p.delFunctionGroup(w + f, C + m, h.currentSheetIndex);
                    }
                } else {
                    // Destination empty: create a minimal cell with general type for rendering
                    const parsed = it(srcVal); // [m, ct, v]
                    row[C + m] = { v: parsed[2], m: parsed[0], ct: parsed[1] };
                }
            }
            u[w + f] = row;
        }

        // update selection bounds
        d.row = [f, f + g - 1];
        d.column = [m, m + y - 1];

        // apply changes; only mark RowlChange if we expanded grid
        if (addRows > 0 || addCols > 0) {
            Ye(u, h.luckysheet_select_save, { RowlChange: !0 });
        } else {
            Ye(u, h.luckysheet_select_save);
            tt();
        }
    }
},
