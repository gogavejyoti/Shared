$("#luckysheet-icon-excel").click(async function () {
    try {

        // ===================== INLINE HELPERS =====================

        function hexToARGB(color) {
            if (!color) return undefined;
            if (color.startsWith("rgb")) {
                const nums = color.match(/\d+/g).map(Number);
                const [r, g, b] = nums;
                return "FF" + [r, g, b].map(n => n.toString(16).padStart(2, "0")).join("").toUpperCase();
            }
            let hex = color.replace("#", "");
            if (hex.length === 3) hex = hex.split("").map(h => h + h).join("");
            if (!/^[0-9A-Fa-f]{6}$/.test(hex)) return undefined;
            return "FF" + hex.toUpperCase();
        }

        function pxToExcelWidth(px) {
            if (!px) return 10;
            return Math.max(3, Math.round(px / 7));
        }

        function normalizeFormula(formula, sheetNames) {
            if (!formula) return formula;
            sheetNames.forEach(name => {
                if (/\s/.test(name) && formula.includes(name + "!")) {
                    const re = new RegExp(
                        name.replace(/[-\/\\^$*+?.()|[\]{ }]/g, '\\$&') + '!',
                        'g'
                    );
                    formula = formula.replace(re, `'${name}'!`);
                }
            });
            return formula;
        }

        function colIndexToName(i) {
            let s = '';
            i++;
            while (i > 0) {
                let m = (i - 1) % 26;
                s = String.fromCharCode(65 + m) + s;
                i = Math.floor((i - m) / 26);
            }
            return s;
        }

        // üî• Create Excel Table (FOOL-PROOF)
        function createTable(ws, sheet, tableIndex) {
            const data = sheet.data || [];
            if (!data.length) return null;

            let maxCol = 0;
            data.forEach(r => maxCol = Math.max(maxCol, r?.length || 0));
            if (maxCol === 0) return null;

            const headers = [];
            for (let c = 0; c < maxCol; c++) {
                headers.push(colIndexToName(c));
            }

            const rows = [];
            for (let r = 1; r < data.length; r++) {
                const row = [];
                for (let c = 0; c < maxCol; c++) {
                    row.push(data[r]?.[c]?.v ?? null);
                }
                rows.push(row);
            }

            const tableName = `Table_${tableIndex}`;

            ws.addTable({
                name: tableName,
                ref: 'A1',
                headerRow: true,
                totalsRow: false,
                style: { theme: 'TableStyleLight9', showRowStripes: false },
                columns: headers.map(h => ({ name: h })),
                rows
            });

            return { tableName, headers };
        }

        // üî• Rewrite MINIFS ‚Üí structured reference
        function rewriteMinifs(formula, tableInfo) {
            if (!tableInfo) return formula;
            const { tableName, headers } = tableInfo;

            return formula.replace(/([A-Z]+):\1/g, (_, col) => {
                const idx = col.charCodeAt(0) - 65;
                return headers[idx]
                    ? `${tableName}[${headers[idx]}]`
                    : _;
            });
        }

        // ===================== MAIN LOGIC =====================

        const sheets = luckysheet.getAllSheets();
        const workbook = new ExcelJS.Workbook();
        workbook.creator = "LuckySheet";
        workbook.created = new Date();
        const sheetNames = sheets.map(s => s.name || 'Sheet');

        for (let si = 0; si < sheets.length; si++) {
            const sheet = sheets[si];
            const ws = workbook.addWorksheet(sheet.name || `Sheet${si + 1}`);
            const data = sheet.data || [];

            // üî• CREATE TABLE FIRST (CRITICAL)
            const tableInfo = createTable(ws, sheet, si + 1);

            // Column widths
            if (sheet.config?.columnlen) {
                for (const [colIndex, px] of Object.entries(sheet.config.columnlen)) {
                    ws.getColumn(Number(colIndex) + 1).width = pxToExcelWidth(px);
                }
            }

            // Cells
            for (let r = 0; r < data.length; r++) {
                const row = data[r] || [];
                for (let c = 0; c < row.length; c++) {
                    const cell = row[c];
                    if (!cell) continue;

                    const cellRef = ws.getCell(r + 1, c + 1);

                    // Normalize values
                    if (!cell.f && cell.v != null) {
                        const strVal = String(cell.v).trim();
                        if (/^-?\d+(\.\d+)?%$/.test(strVal)) {
                            cell.v = parseFloat(strVal) / 100;
                            cell.ct = cell.ct || {};
                            cell.ct.fa = "0.00%";
                        } else if (/^-?\d+(\.\d+)?$/.test(strVal)) {
                            cell.v = parseFloat(strVal);
                        }
                    }

                    // Formula / Value
                    if (cell.f) {
                        let f = normalizeFormula(cell.f, sheetNames);
                        if (f.startsWith('=')) f = f.slice(1);

                        f = f.replace(/\bMINIF\b/gi, 'MINIFS');

                        // üî• FOOL-PROOF FIX
                        if (/\bMINIFS\s*\(/i.test(f)) {
                            f = rewriteMinifs(f, tableInfo);
                        }

                        cellRef.value = { formula: f, result: cell.v ?? null };
                    } else {
                        cellRef.value = cell.v ?? null;
                    }

                    // Font
                    if (cell.fc || cell.bl || cell.it || cell.ff || cell.fs) {
                        cellRef.font = {};
                        if (cell.fc) cellRef.font.color = { argb: hexToARGB(cell.fc) };
                        if (cell.bl) cellRef.font.bold = true;
                        if (cell.it) cellRef.font.italic = true;
                        if (cell.ff) cellRef.font.name = cell.ff;
                        if (cell.fs) cellRef.font.size = Number(cell.fs);
                    }

                    // Fill
                    if (cell.bg) {
                        cellRef.fill = {
                            type: 'pattern',
                            pattern: 'solid',
                            fgColor: { argb: hexToARGB(cell.bg) }
                        };
                    }

                    // Alignment
                    if (cell.ht || cell.vt || cell.tb) {
                        cellRef.alignment = {};
                        if (cell.ht) cellRef.alignment.horizontal = cell.ht;
                        if (cell.vt) cellRef.alignment.vertical = cell.vt;
                        if (cell.tb) cellRef.alignment.wrapText = cell.tb === 2;
                    }

                    // Border
                    if (cell.border) {
                        const border = {};
                        for (const [side, val] of Object.entries(cell.border)) {
                            if (val?.color) {
                                border[side] = {
                                    style: 'thin',
                                    color: { argb: hexToARGB(val.color) }
                                };
                            }
                        }
                        cellRef.border = border;
                    }

                    // Number format
                    if (cell.ct?.fa) {
                        cellRef.numFmt = cell.ct.fa;
                    }
                }
            }

            // Merges
            if (sheet.config?.merge) {
                Object.values(sheet.config.merge).forEach(m => {
                    if (!m) return;
                    try {
                        ws.mergeCells(
                            m.r + 1,
                            m.c + 1,
                            m.r + (m.rowspan || 1),
                            m.c + (m.colspan || 1)
                        );
                    } catch {}
                });
            }

            // Row heights
            if (sheet.config?.rowlen) {
                Object.entries(sheet.config.rowlen).forEach(([k, px]) => {
                    ws.getRow(Number(k) + 1).height = Math.round(px / 1.3333);
                });
            }

            // Hidden rows / columns
            if (sheet.config?.colhidden) {
                Object.keys(sheet.config.colhidden).forEach(k => {
                    ws.getColumn(Number(k) + 1).hidden = true;
                });
            }
            if (sheet.config?.rowhidden) {
                Object.keys(sheet.config.rowhidden).forEach(k => {
                    ws.getRow(Number(k) + 1).hidden = true;
                });
            }

            if (sheet.hide === 1) ws.state = 'hidden';
        }

        // Active tab
        const activeIndex = sheets.findIndex(s => s.status === 1) || 0;
        workbook.views = [{
            activeTab: activeIndex,
            visibility: 'visible'
        }];

        const buf = await workbook.xlsx.writeBuffer();
        const fileName = (h.exportFileName || 'Export') + '.xlsx';
        saveAs(new Blob([buf], { type: "application/octet-stream" }), fileName);

    } catch (err) {
        console.error("‚ùå Export failed:", err);
        alert("Export failed. See console for details.");
    }
});
