pasteHandlerOfCopyPaste: function (e) {
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex)) return;

    const t = Q().paste;
    let l = $.extend(true, {}, h.config);
    if (!l.merge) l.merge = {};

    const s = e.dataSheetIndex,
        copyRanges = e.copyRange,
        firstRange = copyRanges[0],
        row0 = firstRange.row[0], row1 = firstRange.row[1],
        col0 = firstRange.column[0], col1 = firstRange.column[1];

    // ✅ Preload copied data once
    let copied = [];
    if (copyRanges.length === 1) {
        copied = Nt({ row: firstRange.row, column: firstRange.column }, s);
    } else {
        for (let i = 0; i < copyRanges.length; i++) {
            let data = Nt({ row: copyRanges[i].row, column: copyRanges[i].column }, s);
            copied = copied.concat(data);
        }
    }

    // ✅ Handle multi-range transpose only once
    if (copyRanges.length > 1 && row0 === copyRanges[1].row[0] && row1 === copyRanges[1].row[1]) {
        copied = copied[0].map((_, c) => copied.map(r => r[c]));
    }

    const v = $.extend(true, [], copied),
        rowCount = v.length,
        colCount = v[0].length;

    // ✅ Clean formulas if multi-range
    if (copyRanges.length > 1) {
        for (let r = 0; r < rowCount; r++) {
            for (let c = 0; c < colCount; c++) {
                const cell = v[r][c];
                if (cell && cell.f) {
                    delete cell.f;
                    delete cell.spl;
                }
            }
        }
    }

    const sel = h.luckysheet_select_save[h.luckysheet_select_save.length - 1],
        x0 = sel.row[0], x1 = sel.row[1],
        y0 = sel.column[0], y1 = sel.column[1];

    // ✅ Adjust paste area size to match copied data
    let heightMod = (x1 - x0 + 1) % rowCount,
        widthMod = (y1 - y0 + 1) % colCount;
    if (heightMod !== 0 || widthMod !== 0) {
        sel.row[1] = x0 + rowCount - 1;
        sel.column[1] = y0 + colCount - 1;
    }

    // ✅ Merge conflict check early exit
    if (l.merge && Dt(l, x0, sel.row[1], y0, sel.column[1])) {
        if (de()) alert(t.errorNotAllowMerged);
        else U.info(`<i class="fa fa-exclamation-triangle"></i>${t.warning}`, t.errorNotAllowMerged);
        return;
    }

    const I = (sel.row[1] - x0 + 1) / rowCount,
        F = (sel.column[1] - y0 + 1) / colCount;

    let N = we.deepCopyFlowData(h.flowdata);
    const addRows = rowCount + x0 - N.length;
    const addCols = colCount + y0 - N[0].length;
    if (addRows > 0 || addCols > 0) {
        N = il([].concat(N), addRows, addCols, true);
    }

    const borderMap = Ur(s),
        verifSource = $.extend(true, {}, h.luckysheetfile[K(s)].dataVerification),
        verifTarget = $.extend(true, {}, h.luckysheetfile[K(h.currentSheetIndex)].dataVerification || {}),
        formulaCache = new Map();  // ✅ cache for execfunction

    const copyRowSpan = row1 - row0 + 1;
    const copyColSpan = col1 - col0 + 1;
    const hasMC = e.HasMC;

    for (let rr = 0; rr < I; rr++) {
        for (let cc = 0; cc < F; cc++) {
            const startRow = x0 + rr * rowCount;
            const startCol = y0 + cc * colCount;

            for (let r = 0; r < rowCount; r++) {
                const targetRow = startRow + r;
                let rowArr = N[targetRow].slice();  // shallow clone once per row

                for (let c = 0; c < colCount; c++) {
                    const targetCol = startCol + c;
                    const srcCell = v[r][c];

                    // ✅ Apply border fast
                    const borderKeySrc = `${row0 + r}_${col0 + c}`;
                    const borderKeyTgt = `${targetRow}_${targetCol}`;
                    if (borderMap[borderKeySrc]) {
                        l.borderInfo = l.borderInfo || [];
                        const b = borderMap[borderKeySrc];
                        l.borderInfo.push({
                            rangeType: "cell",
                            value: { row_index: targetRow, col_index: targetCol, l: b.l, r: b.r, t: b.t, b: b.b }
                        });
                    } else if (borderMap[borderKeyTgt]) {
                        l.borderInfo = l.borderInfo || [];
                        l.borderInfo.push({
                            rangeType: "cell",
                            value: { row_index: targetRow, col_index: targetCol, l: null, r: null, t: null, b: null }
                        });
                    }

                    // ✅ Data validation copy
                    const verKeySrc = `${row0 + r}_${col0 + c}`;
                    if (verifSource[verKeySrc]) {
                        verifTarget[`${targetRow}_${targetCol}`] = verifSource[verKeySrc];
                    }

                    // ✅ Handle formulas with caching
                    let newCell = srcCell ? { ...srcCell } : null;
                    if (newCell && newCell.f) {
                        let fstr = newCell.f;
                        const rowOff = targetRow - (row0 + r);
                        const colOff = targetCol - (col0 + c);
                        const cacheKey = `${fstr}|${rowOff}|${colOff}`;

                        let execResult = formulaCache.get(cacheKey);
                        if (!execResult) {
                            if (rowOff > 0) fstr = "=" + p.functionCopy(fstr, "down", rowOff);
                            else if (rowOff < 0) fstr = "=" + p.functionCopy(fstr, "up", -rowOff);
                            if (colOff > 0) fstr = "=" + p.functionCopy(fstr, "right", colOff);
                            else if (colOff < 0) fstr = "=" + p.functionCopy(fstr, "left", -colOff);

                            execResult = p.execfunction(fstr, targetRow, targetCol, undefined, true);
                            formulaCache.set(cacheKey, execResult);
                        }

                        if (newCell.spl) {
                            newCell.f = execResult[2];
                            newCell.v = execResult[1];
                            newCell.spl = execResult[3].data;
                        } else {
                            newCell.f = execResult[2];
                            newCell.v = execResult[1];
                            if (newCell.ct && newCell.ct.fa) {
                                newCell.m = mt(newCell.ct.fa, execResult[1]);
                            }
                        }
                    }

                    rowArr[targetCol] = newCell ? newCell : null;
                }

                N[targetRow] = rowArr;
            }
        }
    }

    // ✅ Conditional formatting
    let ce = null;
    if (copyRanges.length === 1) {
        const srcSheet = h.luckysheetfile[K(s)];
        const tgtSheet = h.luckysheetfile[K(h.currentSheetIndex)];
        const cf = srcSheet.luckysheet_conditionformat_save;
        if (cf && cf.length) {
            ce = $.extend(true, [], tgtSheet.luckysheet_conditionformat_save);
            for (let cfItem of cf) {
                let newRanges = [];
                for (let rr = 0; rr < I; rr++) {
                    for (let cc = 0; cc < F; cc++) {
                        const sr = x0 + rr * rowCount, sc = y0 + cc * colCount;
                        const er = sr + rowCount - 1, ec = sc + colCount - 1;
                        for (let orig of cfItem.cellrange) {
                            const parts = $e.CFSplitRange(orig,
                                { row: [row0, row1], column: [col0, col1] },
                                { row: [sr, er], column: [sc, ec] },
                                "operatePart"
                            );
                            if (parts.length) newRanges = newRanges.concat(parts);
                        }
                    }
                }
                if (newRanges.length) {
                    const newItem = $.extend(true, {}, cfItem);
                    newItem.cellrange = newRanges;
                    ce.push(newItem);
                }
            }
        }
    }

    const finalParams = { cfg: yl(N, x0, sel.row[1], l), cdformat: ce, dataVerification: verifTarget };
    Ye(N, h.luckysheet_select_save, finalParams);
    tt();
}
