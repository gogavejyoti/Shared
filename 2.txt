            execFunctionGroup: function (e, n, t, l, a, o = !1) {
                if (o) return;
                const s = this;

                if (a == null) a = h.flowdata;
                if (!window.luckysheet_compareWith) {
                    window.luckysheet_compareWith = ja;
                    window.luckysheet_getarraydata = wc;
                    window.luckysheet_getcelldata = nr;
                    window.luckysheet_parseData = Ua;
                    window.luckysheet_getValue = qn;
                    window.luckysheet_indirect_check = xc;
                    window.luckysheet_indirect_check_return = _c;
                    window.luckysheet_offset_check = Cc;
                    window.luckysheet_calcADPMM = _t;
                    window.luckysheet_getSpecialReference = Tc;
                }

                if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
                if (l == null) l = h.currentSheetIndex;

                if (t != null) {
                    const tmp = [[{ v: null }]];
                    At(0, 0, tmp, t);
                    s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
                }

                if (typeof _shiftCrossSheetReference === "function") {
                    _shiftCrossSheetReference({ type: "recalc", sheetIndex: l });
                }

                let allFuncCells = [];
                let sheetIndices = null;

                if (e != null && n != null) {
                    const formulaOrValue =
                        (window.luckysheet_getcelldata_cache &&
                            Object.keys(window.luckysheet_getcelldata_cache).join("+")) ||
                        null;
                    sheetIndices = s.getAllDependentSheetsFromSheet(l, formulaOrValue);
                    allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
                } else {
                    allFuncCells = s.getAllFunctionGroup() || [];
                }

                const sheetsInfo = Ft() || [];
                const sheetMap = {};

                for (let i = 0; i < sheetsInfo.length; i++) {
                    if (!sheetIndices || sheetIndices.includes(sheetsInfo[i].index)) {
                        sheetMap[sheetsInfo[i].index] = sheetsInfo[i].data;
                    }
                }

                const execSet = {};
                if (s.execFunctionExist == null) {
                    execSet["r" + e + "c" + n + "i" + l] = 1;
                } else {
                    for (const T of s.execFunctionExist) {
                        execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
                    }
                }

                const nodes = {};
                const rangeToKeysCache = {};

                function keysForRange(R) {
                    const cacheKey =
                        `r${R.row[0]}_${R.row[1]}_c${R.column[0]}_${R.column[1]}_i${R.sheetIndex}`;
                    if (rangeToKeysCache[cacheKey]) return rangeToKeysCache[cacheKey];

                    const list = [];
                    for (let rr = R.row[0]; rr <= R.row[1]; rr++) {
                        for (let cc = R.column[0]; cc <= R.column[1]; cc++) {
                            list.push({
                                key: "r" + rr + "c" + cc + "i" + R.sheetIndex,
                                r: rr,
                                c: cc,
                                sheetIndex: R.sheetIndex
                            });
                        }
                    }
                    rangeToKeysCache[cacheKey] = list;
                    return list;
                }

                function extractLookupKey(formula) {
                    const m = formula.match(/(?:VLOOKUP|HLOOKUP|XLOOKUP)\s*\(\s*([^,]+)/i);
                    return m ? m[1].trim() : null;
                }

                /* ================= BUILD NODES ================= */

                for (const T of allFuncCells) {
                    const nodeKey = "r" + T.r + "c" + T.c + "i" + T.index;

                    const R =
                        zl(T.r, T.c, T.index) ||
                        ve.getSheetByIndex(T.index)?.celldata
                            ?.find(x => x?.r === T.r && x?.c === T.c)?.v?.f;

                    if (!R) continue;

                    const upper = R.toUpperCase();

                    const isLookup =
                        upper.includes("VLOOKUP(") ||
                        upper.includes("HLOOKUP(") ||
                        upper.includes("XLOOKUP(");

                    const needsDynamicRange =
                        upper.includes("INDIRECT(") ||
                        upper.includes("OFFSET(") ||
                        upper.includes("INDEX(");

                    const formulaRanges = [];

                    /* --- Lookup key MUST be hard dependency --- */
                    if (isLookup) {
                        const keyRef = extractLookupKey(R);
                        if (keyRef) {
                            const kr = s.getcellrange(keyRef, T.index);
                            if (kr) formulaRanges.push(kr);
                        }
                    }

                    /* --- Ranges --- */
                    if (needsDynamicRange || isLookup) {
                        s.isFunctionRange(R, null, null, T.index, null, function (ref) {
                            const rg = s.getcellrange($.trim(ref), T.index);
                            if (!rg) return;

                            if (isLookup) {
                                formulaRanges.push({ ...rg, __lazy__: true });
                            } else {
                                formulaRanges.push(rg);
                            }
                        });
                    } else {
                        const tokens = R
                            .split(/==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/)
                            .filter(Boolean);

                        for (const tk of tokens) {
                            const rg = s.getcellrange($.trim(tk), T.index);
                            if (rg) formulaRanges.push(rg);
                        }
                    }

                    nodes[nodeKey] = {
                        key: nodeKey,
                        r: T.r,
                        c: T.c,
                        index: T.index,
                        calc_funcStr: R,
                        formulaArray: formulaRanges,
                        parents: {},
                        chidren: {},
                        color: "w"
                    };
                }

                /* ================= BUILD DEP GRAPH ================= */

                const y = [];

                for (const node of Object.values(nodes)) {
                    for (const rect of node.formulaArray || []) {
                        if (rect.__lazy__) {
                            const lazyKey =
                                `lazy_${rect.sheetIndex}_${rect.row[0]}_${rect.row[1]}_${rect.column[0]}_${rect.column[1]}`;
                            node.parents[lazyKey] = 1;
                            continue;
                        }

                        for (const k of keysForRange(rect)) {
                            if (nodes[k.key]) {
                                node.chidren[k.key] = 1;
                                nodes[k.key].parents[node.key] = 1;
                            }
                            if (!o && execSet[k.key]) y.push(node);
                        }
                    }
                    if (o) y.push(node);
                }

                /* ================= TOPO SORT ================= */

                const seen = {};
                const stack = y.slice();
                const ordered = [];

                while (stack.length) {
                    const cur = stack.pop();
                    if (!cur || seen[cur.key]) continue;

                    if (cur.color === "b") {
                        seen[cur.key] = 1;
                        ordered.push(cur);
                        continue;
                    }

                    const parents = Object.keys(cur.parents).map(k => nodes[k]).filter(Boolean);

                    if (!parents.length) {
                        seen[cur.key] = 1;
                        ordered.push(cur);
                    } else {
                        cur.color = "b";
                        stack.push(cur);
                        for (const p of parents) stack.push(p);
                    }
                }

                ordered.reverse();

                /* ================= EXECUTE ================= */

                const indexMap = new Map(ordered.map((n, i) => [n.key, i]));
                const appended = new Set();

                for (let i = 0; i < ordered.length; i++) {
                    const T = ordered[i];
                    window.luckysheet_getcelldata_cache = null;

                    const Rres = s.execfunction(T.calc_funcStr, T.r, T.c, T.index);

                    s.execFunctionGlobalData[`${T.r}_${T.c}_${T.index}`] = {
                        v: Rres[1],
                        f: Rres[2]
                    };

                    s.groupValuesRefreshData.push({
                        r: T.r,
                        c: T.c,
                        v: Rres[1],
                        f: Rres[2],
                        spe: Rres[3],
                        index: T.index
                    });

                    for (const pk of Object.keys(T.parents)) {
                        const pi = indexMap.get(pk);
                        if (pi != null && pi < i && !appended.has(pk)) {
                            appended.add(pk);
                            ordered.push(ordered[pi]);
                        }
                    }
                }

                s.execFunctionExist = null;
            },
