function _shiftSameSheetReference({
    type,
    sheetIndex,
    rowIndex,
    rowCount = 1,
    colIndex,
    colCount = 1
}) {
    const sheet = (Ft() || [])[sheetIndex];
    if (!sheet || !sheet.data) return;

    let sheetChanged = false;

    // Capture $ exactly where it appears
    const refRegex = /(\$?)([A-Z]+)(\$?)(\d+)(?::(\$?)([A-Z]+)(\$?)(\d+))?/g;

    const data = sheet.data;

    for (let r = 0; r < data.length; r++) {
        for (let c = 0; c < (data[r] || []).length; c++) {
            const cell = data[r][c];
            if (!cell || !cell.f) continue;

            const original = cell.f;
            let updated = original;
            let error = false;

            updated = updated.replace(refRegex, function (
                _,
                sColAbs, sCol, sRowAbs, sRow,
                eColAbs, eCol, eRowAbs, eRow
            ) {
                let sc = colToIndex(sCol);
                let sr = +sRow;
                let ec = eCol ? colToIndex(eCol) : sc;
                let er = eRow ? +eRow : sr;

                /* ===== ROW OPS ===== */

                if (type === "insertRow") {
                    if (!sRowAbs && sr >= rowIndex + 1) sr += rowCount;
                    if (!eRowAbs && er >= rowIndex + 1) er += rowCount;
                }

                if (type === "deleteRow") {
                    const ds = rowIndex + 1;
                    const de = rowIndex + rowCount;

                    if ((sr >= ds && sr <= de) || (er >= ds && er <= de)) {
                        error = true;
                        return "#REF!";
                    }

                    if (!sRowAbs && sr > de) sr -= rowCount;
                    if (!eRowAbs && er > de) er -= rowCount;
                }

                /* ===== COL OPS ===== */

                if (type === "insertCol") {
                    if (!sColAbs && sc >= colIndex) sc += colCount;
                    if (!eColAbs && ec >= colIndex) ec += colCount;
                }

                if (type === "deleteCol") {
                    const ds = colIndex;
                    const de = colIndex + colCount - 1;

                    if ((sc >= ds && sc <= de) || (ec >= ds && ec <= de)) {
                        error = true;
                        return "#REF!";
                    }

                    if (!sColAbs && sc > de) sc -= colCount;
                    if (!eColAbs && ec > de) ec -= colCount;
                }

                const start =
                    `${sColAbs}${indexToCol(sc)}${sRowAbs}${sr}`;

                if (!eCol) return start;

                const end =
                    `${eColAbs}${indexToCol(ec)}${eRowAbs}${er}`;

                return `${start}:${end}`;
            });

            if (updated !== original) {
                cell.f = updated;
                sheetChanged = true;
                if (error) {
                    cell.v = "#REF!";
                    cell.ct = { fa: "General", t: "e" };
                }
            }
        }
    }

    if (sheetChanged) {
        if (jf?.refresh) jf.refresh();
        else if (typeof luckysheetrefreshgrid === "function")
            luckysheetrefreshgrid();
    }

    /* ===== helpers ===== */
    function colToIndex(col) {
        let n = 0;
        for (let i = 0; i < col.length; i++)
            n = n * 26 + col.charCodeAt(i) - 64;
        return n - 1;
    }

    function indexToCol(n) {
        let s = "";
        for (++n; n; n = Math.floor((n - 1) / 26))
            s = String.fromCharCode(((n - 1) % 26) + 65) + s;
        return s;
    }
}
