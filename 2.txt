execFunctionGroup: function (r, c, newValue, sheetIndex, data, isRepeat = false) {
    if (isRepeat) return;
    const self = this;
    const h = window.luckysheet;

    // 1. Core Data Initialization
    if (data == null) data = h.flowdata();
    if (sheetIndex == null) sheetIndex = h.currentSheetIndex;
    if (!self.execFunctionGlobalData) self.execFunctionGlobalData = {};
    if (!self.groupValuesRefreshData) self.groupValuesRefreshData = [];

    const allSheets = h.getluckysheetfile();
    const sheetMap = {};
    allSheets.forEach(sheet => { sheetMap[sheet.index] = sheet.data; });

    // 2. CRITICAL: Commit the initial change immediately
    // This ensures the first formulas in the chain "see" the new input.
    if (newValue !== undefined && r !== null && c !== null) {
        const targetSheetData = sheetMap[sheetIndex];
        if (targetSheetData && targetSheetData[r] && targetSheetData[r][c]) {
            targetSheetData[r][c].v = newValue;
        }
        self.execFunctionGlobalData[`${r}_${c}_${sheetIndex}`] = { v: newValue };
    }

    // 3. High-Speed Dependency Graph Building
    const RUN_ID = (self._execRunId || 0) + 1;
    self._execRunId = RUN_ID;
    const nodes = new Map();

    const getOrMakeNode = (row, col, idx, formula = null) => {
        const key = `${row}_${col}_${idx}`;
        let node = nodes.get(key);
        if (!node) {
            node = { r: row, c: col, i: idx, f: formula, children: [], color: 0, impacted: false };
            nodes.set(key, node);
        } else if (formula && !node.f) {
            node.f = formula;
        }
        return node;
    };

    // Build the spiderweb of all formulas
    const allFuncCells = self.getAllFunctionGroup() || [];
    for (let i = 0; i < allFuncCells.length; i++) {
        const item = allFuncCells[i];
        const sData = sheetMap[item.index];
        const cell = sData?.[item.r]?.[item.c];
        
        if (cell && cell.f) {
            const childNode = getOrMakeNode(item.r, item.c, item.index, cell.f);
            
            // Extract references using a robust regex that handles SheetNames!A1:B2
            const refs = cell.f.match(/(([a-zA-Z_$][a-zA-Z0-9_$]*|'([^']|'')*')!)?\$?[a-zA-Z]+\$?[0-9]+(:(\$?[a-zA-Z]+\$?[0-9]+))?/g);
            
            if (refs) {
                refs.forEach(ref => {
                    // Use your provided getcellrange logic
                    const range = self.getcellrange(ref, item.index);
                    if (!range) return;

                    for (let rr = range.row[0]; rr <= range.row[1]; rr++) {
                        for (let cc = range.column[0]; cc <= range.column[1]; cc++) {
                            const pNode = getOrMakeNode(rr, cc, range.sheetIndex);
                            pNode.children.push(childNode);
                        }
                    }
                });
            }
        }
    }

    // 4. Impact Tracing (BFS)
    // Find every cell that is affected by the change at (r, c)
    const queue = [];
    const startNode = getOrMakeNode(r, c, sheetIndex);
    startNode.impacted = true;
    queue.push(startNode);

    let head = 0;
    while (head < queue.length) {
        const curr = queue[head++];
        for (let i = 0; i < curr.children.length; i++) {
            const child = curr.children[i];
            if (!child.impacted) {
                child.impacted = true;
                queue.push(child);
            }
        }
    }

    // 5. Topological Sort (DFS)
    // Order the cells so that "Parents" are calculated before their "Children"
    const sortedList = [];
    const visit = (node) => {
        node.color = 1; // Visiting
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (child.impacted && child.color === 0) visit(child);
        }
        node.color = 2; // Finished
        if (node.f) sortedList.push(node);
    };

    // We only sort the nodes that were marked as 'impacted'
    queue.forEach(n => { if (n.color === 0) visit(n); });
    sortedList.reverse(); 

    // 6. Accurate Execution Loop
    for (let i = 0; i < sortedList.length; i++) {
        const node = sortedList[i];
        
        // Reset Luckysheet's internal lookup cache to force it to read our fresh 'v' updates
        window.luckysheet_getcelldata_cache = null;

        const result = self.execfunction(node.f, node.r, node.c, node.i);
        const computedValue = result[1];

        // SYNC: Update the physical data sheet immediately
        const sData = sheetMap[node.i];
        if (sData && sData[node.r] && sData[node.r][node.c]) {
            sData[node.r][node.c].v = computedValue;
        }

        // Update the refresh queue for the UI
        const key = `${node.r}_${node.c}_${node.i}`;
        self.execFunctionGlobalData[key] = { v: computedValue, f: node.f };
        self.groupValuesRefreshData.push({
            r: node.r, c: node.c, v: computedValue, f: node.f, index: node.i
        });
    }

    self.execFunctionExist = null;
};
