execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;
    const s = this;

    if (a == null) a = h.flowdata;
    if (l == null) l = h.currentSheetIndex;

    // ---------------- explicit value write (unchanged) ----------------
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // ==================================================================
    // 1️⃣ BUILD GLOBAL DEPENDENCY GRAPH (ONCE)
    // ==================================================================
    if (!s._calcGraph) {
        const nodes = new Map();
        const refIndex = new Map(); // sheetIndex → [{range,nodeKey}]

        const allFuncCells = s.getAllFunctionGroup() || [];
        const fmrSplit = /==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/;

        for (let i = 0; i < allFuncCells.length; i++) {
            const T = allFuncCells[i];
            const key = cellKey(T.r, T.c, T.index);

            const formula =
                zl(T.r, T.c, T.index) ||
                ve.getSheetByIndex(T.index)?.celldata?.find(
                    x => x?.r === T.r && x?.c === T.c
                )?.v?.f;

            if (!formula) continue;

            const node = {
                key,
                r: T.r,
                c: T.c,
                sheet: T.index,
                formula,
                parents: new Set(),
                children: new Set(),
                ranges: []
            };

            if (!(formula.startsWith('="') && formula.endsWith('"'))) {
                const tokens = formula.split(fmrSplit);
                for (let ti = 0; ti < tokens.length; ti++) {
                    const tk = tokens[ti].trim();
                    if (!tk) continue;
                    if (tk.length <= 1 && !(s.iscelldata && s.iscelldata(tk))) continue;

                    const rg = s.getcellrange(tk, T.index);
                    if (rg) node.ranges.push(rg);
                }
            }

            nodes.set(key, node);
        }

        // ---------- build parent/child + refIndex ----------
        for (const node of nodes.values()) {
            for (const rg of node.ranges) {
                if (!refIndex.has(rg.sheetIndex)) {
                    refIndex.set(rg.sheetIndex, []);
                }
                refIndex.get(rg.sheetIndex).push({
                    range: rg,
                    nodeKey: node.key
                });
            }
        }

        // ---------- connect formula-to-formula edges ----------
        for (const node of nodes.values()) {
            for (const rg of node.ranges) {
                const sheetNodes = nodes;
                for (let r = rg.row[0]; r <= rg.row[1]; r++) {
                    for (let c = rg.column[0]; c <= rg.column[1]; c++) {
                        const depKey = cellKey(r, c, rg.sheetIndex);
                        if (sheetNodes.has(depKey)) {
                            node.parents.add(depKey);
                            sheetNodes.get(depKey).children.add(node.key);
                        }
                    }
                }
            }
        }

        s._calcGraph = { nodes, refIndex };
    }

    const { nodes, refIndex } = s._calcGraph;

    // ==================================================================
    // 2️⃣ BUILD CHANGED CELL SET (multi-cell safe)
    // ==================================================================
    const changed = [];

    if (s.execFunctionExist) {
        for (const T of s.execFunctionExist) {
            changed.push({ r: T.r, c: T.c, sheet: T.i });
        }
    } else if (e != null && n != null) {
        changed.push({ r: e, c: n, sheet: l });
    }

    // ==================================================================
    // 3️⃣ RESOLVE IMPACTED FORMULAS (range-aware)
    // ==================================================================
    const impacted = new Set();
    const queue = [];

    function inRange(cell, rg) {
        return (
            cell.sheet === rg.sheetIndex &&
            cell.r >= rg.row[0] && cell.r <= rg.row[1] &&
            cell.c >= rg.column[0] && cell.c <= rg.column[1]
        );
    }

    for (const cell of changed) {
        const list = refIndex.get(cell.sheet) || [];
        for (const ref of list) {
            if (inRange(cell, ref.range)) {
                if (!impacted.has(ref.nodeKey)) {
                    impacted.add(ref.nodeKey);
                    queue.push(ref.nodeKey);
                }
            }
        }
    }

    // downstream closure
    while (queue.length) {
        const k = queue.pop();
        const node = nodes.get(k);
        if (!node) continue;

        for (const child of node.children) {
            if (!impacted.has(child)) {
                impacted.add(child);
                queue.push(child);
            }
        }
    }

    if (impacted.size === 0) {
        for (const k of nodes.keys()) impacted.add(k);
    }

    // ==================================================================
    // 4️⃣ DETERMINISTIC TOPO SORT (Excel-style)
    // ==================================================================
    const ordered = [];
    const visited = new Set();
    const temp = new Set();

    function visit(k) {
        if (visited.has(k)) return;
        if (temp.has(k)) return;

        temp.add(k);
        const node = nodes.get(k);
        for (const p of node.parents) {
            if (impacted.has(p)) visit(p);
        }
        temp.delete(k);
        visited.add(k);
        ordered.push(node);
    }

    Array.from(impacted).sort().forEach(visit);

    // ==================================================================
    // 5️⃣ EXECUTION PHASE (UNCHANGED SEMANTICS)
    // ==================================================================
    window.luckysheet_getcelldata_cache = null;

    for (const T of ordered) {
        const oldVal =
            ve.getSheetByIndex(T.sheet)?.data?.[T.r]?.[T.c]?.v;

        const res = s.execfunction(T.formula, T.r, T.c, T.sheet);
        if (oldVal === res[1]) continue;

        s.execFunctionGlobalData[`${T.r}_${T.c}_${T.sheet}`] = {
            v: res[1],
            f: res[2]
        };

        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: res[1],
            f: res[2],
            spe: res[3],
            index: T.sheet
        });
    }

    s.execFunctionExist = null;
}
