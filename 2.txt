INDEX: function () {
    if (arguments.length < this.m[0] || arguments.length > this.m[1])
        return p.error.na;

    for (let i = 0; i < arguments.length; i++) {
        const chk = p.errorParamCheck(this.p, arguments[i], i);
        if (!chk[0]) return p.error.v;
    }

    try {
        const t = arguments[0];
        let l = [];
        let isRangeObj = false;

        // ---------- Resolve array / range ----------
        if (L(t) === "array") {
            if (L(t[0]) === "array" && !M.isDyadicArr(t))
                return p.error.v;
            l = M.getDataDyadicArr(t);
        } else if (L(t) === "object" && t.startCell != null) {
            l = M.getCellDataDyadicArr(t, "number");
            isRangeObj = true;
        }

        const rowCount = l.length;
        const colCount = l[0].length;

        // ---------- Row index ----------
        let r = M.getFirstValue(arguments[1]);
        if (H(r)) return r;
        if (!B(r)) return p.error.v;
        r = parseInt(r);

        // ---------- Column index ----------
        let c = M.getFirstValue(arguments[2]);
        if (H(c)) return c;

        if (r < 0 || (B(c) && c < 0)) return p.error.v;

        // Excel behavior: single row range
        if (rowCount === 1 && c == null) {
            c = r;
            r = 1;
        }

        if (r > rowCount || (B(c) && c > colCount))
            return p.error.r;

        // ======================================================
        // ðŸ”¥ FIX STARTS HERE (column-only + cross-sheet safe)
        // ======================================================
        if (isRangeObj) {
            let d = p.getcellrange(t.startCell);
            let baseRow, baseCol;

            if (!d) {
                // Column-only reference like "C" or "Sheet2!C:C"
                const colOnly = /^[A-Z]+$/;
                if (typeof t.startCell === "string" && colOnly.test(t.startCell)) {

                    baseCol = p.getColumnIndex(t.startCell);

                    // derive first used row from dyadic array itself
                    baseRow = 0;
                    const rows = l.length;

                    while (baseRow < rows) {
                        let empty = true;
                        for (let x = 0; x < l[baseRow].length; x++) {
                            if (l[baseRow][x] != null) {
                                empty = false;
                                break;
                            }
                        }
                        if (!empty) break;
                        baseRow++;
                    }

                    if (baseRow >= rows) return p.error.r;
                } else {
                    return p.error.r;
                }
            } else {
                baseRow = d.row[0];
                baseCol = d.column[0];
            }

            // ---------- Excel semantics ----------
            let value;
            if (r === 0 || c === 0) {
                if (r === 0) {
                    value = l[0];
                    r = 1;
                } else {
                    value = l[r - 1];
                }

                if (B(c)) {
