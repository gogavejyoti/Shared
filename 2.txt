function buildWeightedMetricsTable(data, containerId, drillMode = "GeoToLob", viewMode = "Monthly") {
    const container = document.querySelector("#" + containerId);
    container.innerHTML = '';

    // Determine key for period
    const timeKey = viewMode === "Weekly" ? "weekFormat" : "monthFormat";

    // Collect and sort periods
    const periods = [...new Set(data.map(d => d[timeKey]).filter(x => x))]
        .map(p => ({ period: p, date: new Date(p) }))
        .sort((a, b) => a.date - b.date)
        .map(x => x.period);

    // Top dropdowns
    const topRow = document.createElement('div');
    topRow.style.marginBottom = '8px';

    const drillSelector = document.createElement("select");
    drillSelector.className = "form-select d-inline-block me-2";
    drillSelector.style.width = "180px";
    ["GeoToLob", "LobToGeo"].forEach(mode => {
        const opt = document.createElement("option");
        opt.value = mode;
        opt.innerText = mode === "GeoToLob" ? "Geo → LOB" : "LOB → Geo";
        if (mode === drillMode) opt.selected = true;
        drillSelector.appendChild(opt);
    });

    const viewSelector = document.createElement("select");
    viewSelector.className = "form-select d-inline-block";
    viewSelector.style.width = "140px";
    ["Weekly", "Monthly"].forEach(mode => {
        const opt = document.createElement("option");
        opt.value = mode;
        opt.innerText = mode;
        if (mode === viewMode) opt.selected = true;
        viewSelector.appendChild(opt);
    });

    drillSelector.addEventListener("change", () => {
        buildWeightedMetricsTable(data, containerId, drillSelector.value, viewSelector.value);
    });
    viewSelector.addEventListener("change", () => {
        buildWeightedMetricsTable(data, containerId, drillSelector.value, viewSelector.value);
    });

    topRow.appendChild(drillSelector);
    topRow.appendChild(viewSelector);
    container.appendChild(topRow);

    // Determine main groups
    const groups = drillMode === "GeoToLob"
        ? [...new Set(data.map(d => d.geo))]
        : [...new Set(data.map(d => d.lob))];

    // Create table
    const table = document.createElement('table');
    table.className = 'table table-bordered table-hover';
    table.style.minWidth = (Math.max(1, periods.length) * 200 + 160) + 'px';

    // Header
    const thead = document.createElement('thead');
    const tr1 = document.createElement('tr');
    const thGroup = document.createElement('th');
    thGroup.rowSpan = 2;
    thGroup.innerText = drillMode === "GeoToLob" ? "Geo" : "LOB";
    tr1.appendChild(thGroup);

    periods.forEach(p => {
        const th = document.createElement('th');
        th.colSpan = 5;
        th.innerText = p;
        tr1.appendChild(th);
    });
    thead.appendChild(tr1);

    const tr2 = document.createElement('tr');
    periods.forEach(() => {
        ['Planned Shrinkage', 'Actual Shrinkage', 'Planned Attrition', 'Actual Attrition', 'OTF%'].forEach(h => {
            const th = document.createElement('th');
            th.innerText = h;
            tr2.appendChild(th);
        });
    });
    thead.appendChild(tr2);
    table.appendChild(thead);

    // Body
    const tbody = document.createElement('tbody');

    // Overall summary row
    const trSummary = document.createElement("tr");
    trSummary.className = "table-primary fw-bold";
    const tdSummary = document.createElement("td");
    tdSummary.innerText = "Overall Summary";
    trSummary.appendChild(tdSummary);

    periods.forEach(period => {
        const recs = data.filter(d => d[timeKey] === period);

        const totalAvailable = recs.reduce((s, r) => s + (r.availableHC || 0), 0);
        const plannedShrinkage = totalAvailable ? Math.round(recs.reduce((s, r) => s + (r.availableHC * (r.plannedShrinkage || 0)), 0) / totalAvailable) : 0;
        const actualShrinkage = totalAvailable ? Math.round(recs.reduce((s, r) => s + (r.availableHC * (r.actualShrinkage || 0)), 0) / totalAvailable) : 0;

        const totalActualHours = recs.reduce((s, r) => s + (r.actualHours || 0), 0);
        const totalForecastedHours = recs.reduce((s, r) => s + (r.forecastedHours || 0), 0);
        const otfPct = totalActualHours ? Math.round((totalForecastedHours / totalActualHours) * 100) : 0;

        [plannedShrinkage, actualShrinkage, 0, 0, otfPct].forEach((val, i) => {
            const td = document.createElement("td");
            if (i === 0) td.innerText = plannedShrinkage + "%";
            else if (i === 1) td.innerText = actualShrinkage + "%";
            else if (i === 2) td.innerText = "-"; // Planned Attrition placeholder
            else if (i === 3) td.innerText = "-"; // Actual Attrition placeholder
            else td.innerText = otfPct + "%";
            trSummary.appendChild(td);
        });
    });
    tbody.appendChild(trSummary);

    // Drilldown groups
    groups.forEach(group => {
        const tr = document.createElement('tr');
        tr.className = 'groupRow';
        tr.style.cursor = 'pointer';
        const tdGroup = document.createElement('td');
        tdGroup.innerText = group;
        tr.appendChild(tdGroup);

        periods.forEach(period => {
            const recs = data.filter(d =>
                (drillMode === "GeoToLob" ? d.geo === group : d.lob === group) &&
                d[timeKey] === period
            );
            const totalAvailable = recs.reduce((s, r) => s + (r.availableHC || 0), 0);
            const plannedShrinkage = totalAvailable ? Math.round(recs.reduce((s, r) => s + (r.availableHC * (r.plannedShrinkage || 0)), 0) / totalAvailable) : 0;
            const actualShrinkage = totalAvailable ? Math.round(recs.reduce((s, r) => s + (r.availableHC * (r.actualShrinkage || 0)), 0) / totalAvailable) : 0;
            const totalActualHours = recs.reduce((s, r) => s + (r.actualHours || 0), 0);
            const totalForecastedHours = recs.reduce((s, r) => s + (r.forecastedHours || 0), 0);
            const otfPct = totalActualHours ? Math.round((totalForecastedHours / totalActualHours) * 100) : 0;

            [plannedShrinkage, actualShrinkage, 0, 0, otfPct].forEach((val, i) => {
                const td = document.createElement('td');
                if (i === 0) td.innerText = plannedShrinkage + "%";
                else if (i === 1) td.innerText = actualShrinkage + "%";
                else if (i === 2) td.innerText = "-";
                else if (i === 3) td.innerText = "-";
                else td.innerText = otfPct + "%";
                tr.appendChild(td);
            });
        });
        tbody.appendChild(tr);

        // Drilldown child rows
        const children = drillMode === "GeoToLob"
            ? [...new Set(data.filter(d => d.geo === group).map(d => d.lob))]
            : [...new Set(data.filter(d => d.lob === group).map(d => d.geo))];

        children.forEach(child => {
            const trChild = document.createElement("tr");
            trChild.style.background = "#525252";
            trChild.style.fontStyle = "italic";
            trChild.className = "childRow";
            trChild.style.display = "none";
            const tdChild = document.createElement("td");
            tdChild.innerText = "   └ " + child;
            tdChild.style.fontStyle = "italic";
            tdChild.style.fontSize = "0.85em";
            trChild.appendChild(tdChild);

            periods.forEach(period => {
                const recs = data.filter(d =>
                    (drillMode === "GeoToLob"
                        ? d.geo === group && d.lob === child
                        : d.lob === group && d.geo === child) &&
                    d[timeKey] === period
                );
                const totalAvailable = recs.reduce((s, r) => s + (r.availableHC || 0), 0);
                const plannedShrinkage = totalAvailable ? Math.round(recs.reduce((s, r) => s + (r.availableHC * (r.plannedShrinkage || 0)), 0) / totalAvailable) : 0;
                const actualShrinkage = totalAvailable ? Math.round(recs.reduce((s, r) => s + (r.availableHC * (r.actualShrinkage || 0)), 0) / totalAvailable) : 0;
                const totalActualHours = recs.reduce((s, r) => s + (r.actualHours || 0), 0);
                const totalForecastedHours = recs.reduce((s, r) => s + (r.forecastedHours || 0), 0);
                const otfPct = totalActualHours ? Math.round((totalForecastedHours / totalActualHours) * 100) : 0;

                [plannedShrinkage, actualShrinkage, 0, 0, otfPct].forEach((val, i) => {
                    const td = document.createElement('td');
                    if (i === 0) td.innerText = plannedShrinkage + "%";
                    else if (i === 1) td.innerText = actualShrinkage + "%";
                    else if (i === 2) td.innerText = "-";
                    else if (i === 3) td.innerText = "-";
                    else td.innerText = otfPct + "%";
                    trChild.appendChild(td);
                });
            });
            tbody.appendChild(trChild);
        });

        tr.addEventListener("click", () => {
            let next = tr.nextElementSibling;
            while (next && next.classList.contains("childRow")) {
                next.style.display = (next.style.display === "none") ? "table-row" : "none";
                next = next.nextElementSibling;
            }
        });
    });

    table.appendChild(tbody);
    container.appendChild(table);
}
