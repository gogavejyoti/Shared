            execfunction: function (e, n, t, l, a, o) {
                const s = this;
                const d = Q().formulaMore;

                if (e.includes(s.error.r)) return [false, s.error.r, e];
                if (!s.checkBracketNum(e)) e += ")";

                if (l == null) l = h.currentSheetIndex;
                h.calculateSheetIndex = l;

                // ---------- parsed formula cache (keyed by exact formula string) ----------
                if (!s._parsedFormulaCache) s._parsedFormulaCache = new Map();
                let f = s._parsedFormulaCache.get(e);
                if (!f) {
                    f = s.functionParserExe(e).trim();
                    s._parsedFormulaCache.set(e, f);
                }

                if (!f || !s.testFunction(e, f)) {
                    U.info("", d.execfunctionError);
                    return [false, s.error.n, e];
                }

                // ---------- compiled function cache (keyed by exact compiled string f) ----------
                if (!s._formulaCache) s._formulaCache = new Map();
                let compiledFn = s._formulaCache.get(f);
                if (!compiledFn) {
                    try {
                        compiledFn = new Function("return " + f);
                        s._formulaCache.set(f, compiledFn);
                    } catch (err) {
                        const errorMsg = s.errorInfo(err);
                        return [false, [s.error.n, errorMsg], e];
                    }
                }

                // ---------- cache cell ranges (keyed by exact formula string) ----------
                if (!s._cellRefCache) s._cellRefCache = new Map();
                let cellRefs = s._cellRefCache.get(e);
                if (!cellRefs && f.indexOf("luckysheet_getcelldata") !== -1) {
                    const regex = /luckysheet_getcelldata\('([^']+)'\)/g;
                    let match, refs = [];
                    while ((match = regex.exec(f)) !== null) {
                        refs.push(s.getcellrange(match[1]));
                    }
                    cellRefs = refs;
                    s._cellRefCache.set(e, cellRefs);
                }

                if (cellRefs) {
                    for (const w of cellRefs) {
                        if (w.row[0] < 0 || w.column[0] < 0) return [true, s.error.r, e];
                        if (w.sheetIndex === h.calculateSheetIndex &&
                            n >= w.row[0] && n <= w.row[1] &&
                            t >= w.column[0] && t <= w.column[1]) {
                            U.info("", d.execfunctionSelfErrorResult);
                            return [false, 0, e];
                        }
                    }
                }

                // ---------- execute ----------
                let m;
                try {
                    m = compiledFn();
                    if (typeof m === "string") m = m.replace(/\x7F/g, '"');
                } catch (err) {
                    const errorMsg = s.errorInfo(err);
                    return [false, [s.error.n, errorMsg], e];
                }

                // ---------- handle dynamic arrays (unchanged) ----------
                const mType = L(m);
                let g = null, y = null;
                if (mType === "object" && m.startCell != null) {
                    if (Array.isArray(m.data)) m = s.error.v;
                    else if (typeof m.data === "object" && !fe(m.data.v)) m = m.data.v;
                    else if (fe(m.data)) m = 0;
                    else m = m.cell > 1 || m.rowl > 1 ? m.data : 0;
                } else if (mType === "array") {
                    if (Array.isArray(m[0]) && m.length === 1 && m[0].length === 1) {
                        m = m[0][0];
                    } else {
                        y = { r: n, c: t, f: e, index: l, data: m };
                        m = "";
                    }
                }

                if (a) s.execFunctionGroup(n, t, m, l);
                if (!o) s.insertUpdateFunctionGroup(n, t, l);

                return g ? [true, m, e, { type: "sparklines", data: g }] :
                    y ? [true, m, e, { type: "dynamicArrayItem", data: y }] :
                        [true, m, e];
            },

