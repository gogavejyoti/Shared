// Re-exec earlier parents if required
execFunctionGroup: function (e, n, t, l, a, o = !1) {
    // ---------- original early return ----------
    if (o) return;

    const s = this;

    // ---------- helpers (UNCHANGED) ----------
    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    // ---------- explicit value store (UNCHANGED) ----------
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // ---------- collect function group cells (UNCHANGED LOGIC) ----------
    let allFuncCells = [];
    let sheetIndices = null;

    if (e != null && n != null) {
        const formulaOrValue =
            (window.luckysheet_getcelldata_cache &&
                Object.keys(window.luckysheet_getcelldata_cache).join("+")) ||
            null;
        sheetIndices = s.getAllDependentSheetsFromSheet(l, formulaOrValue);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    // ---------- build sheetMap (UNCHANGED) ----------
    const sheetsInfo = Ft() || [];
    const sheetMap = {};
    for (let i = 0; i < sheetsInfo.length; i++) {
        sheetMap[sheetsInfo[i].index] = sheetsInfo[i].data;
    }

    // ---------- execSet (UNCHANGED) ----------
    const execSet = {};
    if (s.execFunctionExist == null) {
        execSet["r" + e + "c" + n + "i" + l] = 1;
    } else {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const T = s.execFunctionExist[i];
            execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
        }
    }

    // =====================================================================
    // ðŸ”¥ OPTIMIZATION 1: dependency graph cache (NO logic change)
    // =====================================================================
    if (!s._execFuncDepCache) s._execFuncDepCache = {};
    const cacheKey = l;

    let depCache = s._execFuncDepCache[cacheKey];
    let nodes, refToChildren;

    if (!depCache) {
        nodes = {};
        refToChildren = {};
        const fmrSplit = /==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/;

        // ---------- build formula nodes (UNCHANGED logic) ----------
        for (let i = 0; i < allFuncCells.length; i++) {
            const T = allFuncCells[i];
            const nodeKey = "r" + T.r + "c" + T.c + "i" + T.index;

            const R =
                zl(T.r, T.c, T.index) ||
                ve.getSheetByIndex(T.index)?.celldata?.find(
                    x => x?.r === T.r && x?.c === T.c
                )?.v?.f;

            if (!R) continue;

            const formulaRanges = [];
            if (!(R.substr(0, 2) === '="' && R.substr(R.length - 1, 1) === '"')) {
                const tokens = R.split(fmrSplit);
                for (let ti = 0; ti < tokens.length; ti++) {
                    const tk = tokens[ti].trim();
                    if (!tk) continue;
                    if (tk.length <= 1 && !(s.iscelldata && s.iscelldata(tk))) continue;

                    const rg = s.getcellrange(tk, T.index);
                    if (rg) formulaRanges.push(rg);
                }
            }

            nodes[nodeKey] = {
                key: nodeKey,
                r: T.r,
                c: T.c,
                index: T.index,
                formulaArray: formulaRanges,
                calc_funcStr: R,
                parents: {},
                children: {},
                color: "w",
                cellAddress: s.getExcelAddr(T.r, T.c)
            };
        }

        // ---------- range â†’ keys cache (UNCHANGED behavior) ----------
        const rangeToKeysCache = {};
        function keysForRange(R) {
            const k =
                R.row[0] + "_" + R.row[1] + "_" +
                R.column[0] + "_" + R.column[1] + "_" +
                R.sheetIndex;

            if (rangeToKeysCache[k]) return rangeToKeysCache[k];

            const maxRow =
                (sheetMap[R.sheetIndex] &&
                    sheetMap[R.sheetIndex].length - 1) ??
                R.row[1];

            const endRow = R.row[1] > maxRow ? maxRow : R.row[1];
            const list = [];

            for (let rr = R.row[0]; rr <= endRow; rr++) {
                for (let cc = R.column[0]; cc <= R.column[1]; cc++) {
                    list.push("r" + rr + "c" + cc + "i" + R.sheetIndex);
                }
            }
            rangeToKeysCache[k] = list;
            return list;
        }

        // ---------- dependency graph build (UNCHANGED logic) ----------
        for (const nodeKey in nodes) {
            const node = nodes[nodeKey];
            const ranges = node.formulaArray || [];

            for (let ri = 0; ri < ranges.length; ri++) {
                const rect = ranges[ri];
                const refs = keysForRange(rect);

                for (let ki = 0; ki < refs.length; ki++) {
                    const A = refs[ki];

                    if (!refToChildren[A]) refToChildren[A] = [];
                    refToChildren[A].push(node.key);

                    if (nodes[A]) {
                        node.parents[A] = 1;
                        nodes[A].children[node.key] = 1;
                    }
                }
            }
        }

        depCache = s._execFuncDepCache[cacheKey] = {
            nodes,
            refToChildren
        };
    } else {
        nodes = depCache.nodes;
        refToChildren = depCache.refToChildren;
    }

    // =====================================================================
    // impacted set (UNCHANGED logic)
    // =====================================================================
    const impacted = new Set();
    const queue = [];
    const execKeys = Object.keys(execSet);

    for (let i = 0; i < execKeys.length; i++) {
        const k = execKeys[i];

        const children = refToChildren[k];
        if (children) {
            for (let j = 0; j < children.length; j++) {
                if (!impacted.has(children[j])) {
                    impacted.add(children[j]);
                    queue.push(children[j]);
                }
            }
        }

        if (nodes[k] && !impacted.has(k)) {
            impacted.add(k);
            queue.push(k);
        }
    }

    while (queue.length) {
        const k = queue.pop();
        const node = nodes[k];
        if (!node) continue;

        for (const ck in node.children) {
            if (!impacted.has(ck)) {
                impacted.add(ck);
                queue.push(ck);
            }
        }
    }

    if (impacted.size === 0) {
        for (const k in nodes) impacted.add(k);
    }

    // =====================================================================
    // topo sort (UNCHANGED logic)
    // =====================================================================
    const ordered = [];
    const processed = {};
    const stack = [];

    impacted.forEach(k => nodes[k] && stack.push(nodes[k]));

    while (stack.length) {
        const cur = stack.pop();
        if (processed[cur.key]) continue;

        if (cur.color === "b") {
            ordered.push(cur);
            processed[cur.key] = 1;
            continue;
        }

        cur.color = "b";
        stack.push(cur);

        const parents = Object.keys(cur.parents || {});
        for (let i = parents.length - 1; i >= 0; i--) {
            const pk = parents[i];
            if (nodes[pk] && impacted.has(pk) && !processed[pk]) {
                stack.push(nodes[pk]);
            }
        }
    }

    // =====================================================================
    // evaluation loop (UNCHANGED logic)
    // =====================================================================
    const indexMap = {};
    for (let i = 0; i < ordered.length; i++) {
        indexMap[ordered[i].key] = { idx: i, count: 0 };
    }

    window.luckysheet_getcelldata_cache = null;

    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];

        const oldValue = sheetMap[T.index]?.[T.r]?.[T.c]?.v;
        const Rres = s.execfunction(T.calc_funcStr, T.r, T.c, T.index);

        if (oldValue == Rres[1]) continue;

        s.execFunctionGlobalData[`${T.r}_${T.c}_${T.index}`] = {
            v: Rres[1],
            f: Rres[2]
        };

        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: Rres[1],
            f: Rres[2],
            spe: Rres[3],
            index: T.index
        });

        // ---------- legacy re-exec parents (UNCHANGED) ----------
        const parents = Object.keys(T.parents || {});
        for (let j = 0; j < parents.length; j++) {
            const p = parents[j];
            const im = indexMap[p];
            if (!im) continue;

            if (im.idx < i && im.count < 5) {
                ordered.push(ordered[im.idx]);
                im.idx = ordered.length - 1;
                im.count++;
            }
        }
    }

    s.execFunctionExist = null;
}
