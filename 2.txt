pasteHandler: function (e, n) {
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex) || h.allowEdit === false) return;

    let lang = Q().paste;

    // Multi-selection warning
    if (h.luckysheet_select_save.length > 1) {
        de() ? alert(lang.errorNotAllowMulti) 
             : U.info(`<i class="fa fa-exclamation-triangle"></i>${lang.warning}`, lang.errorNotAllowMulti);
        return;
    }

    // ============================
    // CASE 1: Pasting structured data (array)
    // ============================
    if (typeof e === "object") {
        if (e.length === 0) return;

        let cfg = $.extend(true, {}, h.config);
        if (!cfg.merge) cfg.merge = {};
        if (JSON.stringify(n).length > 2 && !cfg.borderInfo) cfg.borderInfo = [];

        let rlen = e.length,
            clen = e[0].length,
            sr = h.luckysheet_select_save[0].row[0],
            er = sr + rlen - 1,
            sc = h.luckysheet_select_save[0].column[0],
            ec = sc + clen - 1;

        // Check merge conflicts
        if (Dt(cfg, sr, er, sc, ec)) {
            de() ? alert(lang.errorNotAllowMerged)
                 : U.info(`<i class="fa fa-exclamation-triangle"></i>${lang.warning}`, lang.errorNotAllowMerged);
            return;
        }

        let data = we.deepCopyFlowData(h.flowdata),
            rowsNeeded = er - data.length + 1,
            colsNeeded = ec - data[0].length + 1;

        if (rowsNeeded > 0 || colsNeeded > 0)
            data = il(data, rowsNeeded, colsNeeded, true);

        if (!cfg.rowlen) cfg.rowlen = {};
        let rowHeightChanged = false;

        let mergeMap = {}; // tracking merge references

        // Fill structured data
        for (let r = sr; r <= er; r++) {
            let row = data[r].slice();
            let origHeight = cfg.rowlen[r] ?? h.defaultrowlen;

            for (let c = sc; c <= ec; c++) {
                let cellFromClipboard = e[r - sr]?.[c - sc] ?? null;

                row[c] = $.extend(true, {}, cellFromClipboard);

                // Merge handling
                if (cellFromClipboard && cellFromClipboard.mc) {
                    if (cellFromClipboard.mc.rs != null) {
                        row[c].mc.r = r;
                        row[c].mc.c = c;
                        cfg.merge[r + "_" + c] = row[c].mc;
                        mergeMap[cellFromClipboard.mc.r + "_" + cellFromClipboard.mc.c] = [r, c];
                    } else {
                        let pos = mergeMap[cellFromClipboard.mc.r + "_" + cellFromClipboard.mc.c];
                        row[c].mc = { r: pos[0], c: pos[1] };
                    }
                }

                // Border copy
                let posKey = (r - sr) + "_" + (c - sc);
                if (n[posKey]) {
                    cfg.borderInfo.push({
                        rangeType: "cell",
                        value: {
                            row_index: r,
                            col_index: c,
                            l: n[posKey].l,
                            r: n[posKey].r,
                            t: n[posKey].t,
                            b: n[posKey].b
                        }
                    });
                }

                // Row auto-resize
                let txtStyle = ra(row[c]),
                    height = be.getTextSize("田", txtStyle)[1];

                if (height > origHeight) {
                    cfg.rowlen[r] = height;
                    rowHeightChanged = true;
                }
            }
            data[r] = row;
        }

        h.luckysheet_select_save = [{ row: [sr, er], column: [sc, ec] }];

        let opt = rowHeightChanged ? { cfg, RowlChange: true } : { cfg };
        Ye(data, h.luckysheet_select_save, opt);
        if (!rowHeightChanged) tt();

        return;
    }

    // ============================
    // CASE 2: Pasting plain text (e is string)
    // ============================
    e = e.replace(/\r/g, "");

    // Split rows/tabs
    let rows = e.split("\n").map(r => r.split("\t"));
    let maxCols = Math.max(...rows.map(r => r.length));

    // Normalize all rows to equal length
    let matrix = rows.map(r => (r.length < maxCols ? null : r));

    let data = we.deepCopyFlowData(h.flowdata),
        sel = h.luckysheet_select_save[h.luckysheet_select_save.length - 1],
        sr = sel.row ? sel.row[0] : 0,
        sc = sel.column ? sel.column[0] : 0,
        rCount = matrix.length,
        cCount = matrix[0].length;

    // Merge conflict check
    if (Dt(h.config, sr, sr + rCount - 1, sc, sc + cCount - 1)) {
        de() ? alert(lang.errorNotAllowMerged)
             : U.info(`<i class="fa fa-exclamation-triangle"></i>${lang.warning}`, lang.errorNotAllowMerged);
        return;
    }

    // Expand sheet if needed
    let rowsNeeded = sr + rCount - data.length;
    let colsNeeded = sc + cCount - data[0].length;
    if (rowsNeeded > 0 || colsNeeded > 0)
        data = il(data, rowsNeeded, colsNeeded, true);

    // ============================
    // MAIN LOGIC — formula handling
    // ============================
    for (let r = 0; r < rCount; r++) {
        let row = data[sr + r].slice();

        for (let c = 0; c < cCount; c++) {
            let raw = matrix[r][c];
            let cell = row[sc + c];

            if (typeof raw === "string" && raw.trim().startsWith("=")) {
                // ⭐ Correct handling of formula pasting
                row[sc + c] = {
                    f: raw.trim(),
                    v: null,      // updatecell will evaluate
                    m: raw.trim()
                };
            } else {
                // Normal number/text paste
                if (cell && typeof cell === "object") {
                    let parsed = raw;

                    // Number detection
                    if (!isNaN(parsed) && parsed !== "" && parsed !== null) {
                        if (cell.ct && cell.ct.fa === "@") {
                            parsed = String(parsed);
                        } else {
                            parsed = parseFloat(parsed);
                        }
                    }

                    cell.v = parsed;
                    cell.m = cell.ct?.fa ? mt(cell.ct.fa, parsed) : parsed;

                    // Remove old formula
                    if (cell.f) {
                        cell.f = "";
                        p.delFunctionGroup(sr + r, sc + c, h.currentSheetIndex);
                    }
                } else {
                    // Create new cell
                    if (!isNaN(raw) && raw !== "") {
                        raw = parseFloat(raw);
                    }
                    let parsed = it(raw);
                    row[sc + c] = { v: parsed[2], ct: parsed[1], m: parsed[0] };
                }
            }
        }
        data[sr + r] = row;
    }

    // Update selection
    sel.row = [sr, sr + rCount - 1];
    sel.column = [sc, sc + cCount - 1];

    Ye(data, h.luckysheet_select_save);
    tt();
}
