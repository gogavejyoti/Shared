getcellrange: function (e, n) {
    if (!e) return;

    let t = "", l = "", a = null, o = null;
    const sheets = Ft();

    // ---------- sheet resolve ----------
    if (e.indexOf("!") > -1) {
        if (this.cellTextToIndexList[e]) return this.cellTextToIndexList[e];

        const sp = e.split("!");
        t = sp[0].replace(/\\'/g, "'").replace(/''/g, "'");
        l = sp[1];

        if (t[0] === "'" && t[t.length - 1] === "'") {
            t = t.substring(1, t.length - 1);
        }

        for (let i = 0; i < sheets.length; i++) {
            if (sheets[i].name === t) {
                a = sheets[i].index;
                o = sheets[i].data;
                break;
            }
        }
    } else {
        if (n == null) n = h.currentSheetIndex;
        if (this.cellTextToIndexList[e + "_" + n])
            return this.cellTextToIndexList[e + "_" + n];

        const si = K(n);
        t = sheets[si].name;
        a = sheets[si].index;
        o = h.flowdata;
        l = e;
    }

    // ---------- single cell ----------
    if (l.indexOf(":") === -1) {
        const r = parseInt(l.replace(/[^0-9]/g, "")) - 1;
        const c = cl(l.replace(/[^A-Za-z]/g, ""));

        if (!isNaN(r) && !isNaN(c)) {
            const f = { row: [r, r], column: [c, c], sheetIndex: a };
            this.addToCellIndexList(e, f);
            return f;
        }
        return null;
    }

    // ---------- range ----------
    const parts = l.split(":");

    let r1 = parseInt(parts[0].replace(/[^0-9]/g, "")) - 1;
    let r2 = parseInt(parts[1].replace(/[^0-9]/g, "")) - 1;
    let c1 = cl(parts[0].replace(/[^A-Za-z]/g, ""));
    let c2 = cl(parts[1].replace(/[^A-Za-z]/g, ""));

    const isColumnOnly =
        isNaN(r1) && isNaN(r2) &&
        !isNaN(c1) && !isNaN(c2);

    // ✅ COLUMN-ONLY RANGE (C:D)
    if (isColumnOnly && o) {
        let firstUsed = null;
        let lastUsed = null;

        for (let r = 0; r < o.length; r++) {
            for (let c = c1; c <= c2; c++) {
                const cell = o[r]?.[c];
                if (cell && cell.v !== null && cell.v !== "") {
                    if (firstUsed === null) firstUsed = r;
                    lastUsed = r;
                }
            }
        }

        if (firstUsed === null) return null;

        // ❗ DO NOT CACHE → dynamic range
        return {
            row: [firstUsed, lastUsed],
            column: [c1, c2],
            sheetIndex: a
        };
    }

    // ---------- fallback (unchanged behavior) ----------
    if (isNaN(r1)) r1 = 0;
    if (isNaN(r2) && o) r2 = o.length - 1;
    if (isNaN(c1)) c1 = 0;
    if (isNaN(c2) && o && o[0]) c2 = o[0].length - 1;

    if (r1 > r2 || c1 > c2) return null;

    const f = { row: [r1, r2], column: [c1, c2], sheetIndex: a };
    this.addToCellIndexList(e, f);
    return f;
}
