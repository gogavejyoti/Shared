execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;
    const s = this;

    if (a == null) a = h.flowdata;
    if (l == null) l = h.currentSheetIndex;

    /* ---------------- helpers init (ONCE) ---------------- */
    if (!window.__ls_exec_init__) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
        window.__ls_exec_init__ = true;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (!s.__fastDepGraph__) s.__fastDepGraph__ = null;

    /* ---------------- store explicit value ---------------- */
    if (t != null && e != null && n != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[`r${e}c${n}i${l}`] = tmp[0][0];
    }

    /* ---------------- get function cells ---------------- */
    let allFuncCells;
    if (e != null && n != null) {
        const fkey = window.luckysheet_getcelldata_cache
            ? Object.keys(window.luckysheet_getcelldata_cache).join("+")
            : null;
        const sheets = s.getAllDependentSheetsFromSheet(l, fkey);
        allFuncCells = s.getAllDependentFunctionGroup(sheets) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    if (allFuncCells.length === 0) return;

    /* ---------------- build graph (ONCE) ---------------- */
    let nodes = s.__fastDepGraph__;
    if (!nodes) {
        nodes = Object.create(null);

        for (let i = 0; i < allFuncCells.length; i++) {
            const T = allFuncCells[i];
            const key = `r${T.r}c${T.c}i${T.index}`;
            const formula = zl(T.r, T.c, T.index);
            if (!formula) continue;

            const parents = new Set();
            s.isFunctionRange(formula, null, null, T.index, null, ref => {
                const rg = s.getcellrange(ref.trim(), T.index);
                if (rg) parents.add(`r${rg.row[0]}_${rg.row[1]}c${rg.column[0]}_${rg.column[1]}i${rg.sheetIndex}`);
            });

            nodes[key] = {
                r: T.r,
                c: T.c,
                index: T.index,
                f: formula,
                parents,
                children: new Set()
            };
        }

        // reverse edges
        for (const k in nodes) {
            nodes[k].parents.forEach(p => {
                if (nodes[p]) nodes[p].children.add(k);
            });
        }

        s.__fastDepGraph__ = nodes;
    }

    /* ---------------- dirty propagation ---------------- */
    const dirty = new Set();
    const start = (e != null && n != null) ? `r${e}c${n}i${l}` : null;
    const stack = start ? [start] : Object.keys(nodes);

    while (stack.length) {
        const k = stack.pop();
        if (!nodes[k] || dirty.has(k)) continue;
        dirty.add(k);
        nodes[k].children.forEach(c => stack.push(c));
    }

    if (dirty.size === 0) return;

    /* ---------------- ultra-fast topo sort ---------------- */
    const indeg = Object.create(null);
    const queue = [];
    const ordered = [];

    dirty.forEach(k => indeg[k] = 0);
    dirty.forEach(k => {
        nodes[k].parents.forEach(p => {
            if (dirty.has(p)) indeg[k]++;
        });
    });

    for (const k in indeg) if (indeg[k] === 0) queue.push(k);

    for (let qi = 0; qi < queue.length; qi++) {
        const k = queue[qi];
        ordered.push(k);
        nodes[k].children.forEach(c => {
            if (!dirty.has(c)) return;
            if (--indeg[c] === 0) queue.push(c);
        });
    }

    if (ordered.length !== dirty.size) {
        throw new Error("Circular reference detected");
    }

    /* ---------------- execution (FAST PATH) ---------------- */
    for (let i = 0; i < ordered.length; i++) {
        const n0 = nodes[ordered[i]];
        const res = s.execfunction(n0.f, n0.r, n0.c, n0.index);

        s.execFunctionGlobalData[ordered[i]] = {
            v: res[1],
            f: res[2]
        };

        s.groupValuesRefreshData.push({
            r: n0.r,
            c: n0.c,
            v: res[1],
            f: res[2],
            spe: res[3],
            index: n0.index
        });
    }

    s.execFunctionExist = null;
}
