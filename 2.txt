using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Globalization;
using System.Linq;
using Dapper;
using Microsoft.ML;
using Microsoft.ML.TimeSeries;

namespace WfmForecastConsole
{
    public class WfmMetric
    {
        public string Program { get; set; }
        public DateTime Month { get; set; }
        public int AccountType { get; set; }
        public float? OfferedToForecast { get; set; }
        public float? HandledToForecast { get; set; }
        public float? HandledToOffered { get; set; }
        public float? HandledToStaffing { get; set; }
        public float? Shrinkage { get; set; }
        public float? Attrition { get; set; }
        public float? Staffing { get; set; }
    }

    public class ForecastInput
    {
        public float Value { get; set; }
    }

    public class ForecastOutput
    {
        public float[] ForecastedValues { get; set; }
    }

    internal class Program
    {
        static void Main()
        {
            var connectionString = "YourConnectionStringHere";
            var forecastHorizon = 3;

            using var connection = new SqlConnection(connectionString);

            var metrics = connection.Query<WfmMetric>("SELECT * FROM WfmMetrics").ToList();

            var cleaned = CleanData(metrics);
            var grouped = cleaned.GroupBy(m => m.Program);

            foreach (var group in grouped)
            {
                Console.WriteLine($"\n📊 Forecast for Program: {group.Key}");
                var programMetrics = group.OrderBy(m => m.Month).ToList();

                if (programMetrics.Count < 6)
                {
                    Console.WriteLine("Not enough data for reliable forecasting.");
                    continue;
                }

                var latestMonth = programMetrics.Max(m => m.Month);

                ForecastAndPrint(programMetrics, "Shrinkage", x => x.Shrinkage, latestMonth, forecastHorizon);
                ForecastAndPrint(programMetrics, "Attrition", x => x.Attrition, latestMonth, forecastHorizon);
                ForecastAndPrint(programMetrics, "Staffing", x => x.Staffing, latestMonth, forecastHorizon);

                if (programMetrics.First().AccountType == 0)
                {
                    ForecastAndPrint(programMetrics, "OfferedToForecast", x => x.OfferedToForecast, latestMonth, forecastHorizon);
                    ForecastAndPrint(programMetrics, "HandledToForecast", x => x.HandledToForecast, latestMonth, forecastHorizon);
                    ForecastAndPrint(programMetrics, "HandledToOffered", x => x.HandledToOffered, latestMonth, forecastHorizon);
                    ForecastAndPrint(programMetrics, "HandledToStaffing", x => x.HandledToStaffing, latestMonth, forecastHorizon);
                }
            }

            Console.WriteLine("\n✅ Forecasting completed using ML.NET SSA (Singular Spectrum Analysis). Ready for Azure OpenAI summarization.");
        }

        static List<WfmMetric> CleanData(List<WfmMetric> data)
        {
            return data
                .Where(m => !string.IsNullOrWhiteSpace(m.Program) && m.Month != default)
                .ToList();
        }

        static void ForecastAndPrint(List<WfmMetric> data, string metricName, Func<WfmMetric, float?> selector, DateTime lastMonth, int horizon)
        {
            var values = data
                .OrderBy(m => m.Month)
                .Select(selector)
                .Where(v => v.HasValue && v.Value != 0)
                .Select(v => v.Value.Value)
                .ToList();

            if (values.Count < 6)
            {
                Console.WriteLine($"⚠️ Skipping {metricName} — not enough valid data.");
                return;
            }

            var forecast = Forecast(values, horizon);

            Console.WriteLine($"\n📈 {metricName} Forecast:");
            for (int i = 0; i < forecast.Count; i++)
            {
                var predictedMonth = lastMonth.AddMonths(i + 1);
                Console.WriteLine($"  {predictedMonth:yyyy-MM} (Month +{i + 1}): {forecast[i]:F2}");
            }
        }

        static List<float> Forecast(List<float> values, int horizon)
        {
            var context = new MLContext();

            int windowSize = Math.Max(3, values.Count / 3);

            var data = values.Select(v => new ForecastInput { Value = v }).ToList();
            var dataView = context.Data.LoadFromEnumerable(data);

            var pipeline = context.Forecasting.ForecastBySsa(
                outputColumnName: nameof(ForecastOutput.ForecastedValues),
                inputColumnName: nameof(ForecastInput.Value),
                windowSize: windowSize,
                seriesLength: values.Count,
                trainSize: values.Count,
                horizon: horizon);

            var model = pipeline.Fit(dataView);
            var engine = model.CreateTimeSeriesEngine<ForecastInput, ForecastOutput>(context);
            return engine.Predict().ForecastedValues.ToList();
        }
    }
}
