execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;

    const s = this;

    if (a == null) a = h.flowdata;
    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    if (typeof _shiftCrossSheetReference === "function") {
        _shiftCrossSheetReference({ type: "recalc", sheetIndex: l });
    }

    let allFuncCells = [];
    let sheetIndices = null;

    if (e != null && n != null) {
        const f =
            (window.luckysheet_getcelldata_cache &&
                Object.keys(window.luckysheet_getcelldata_cache).join("+")) ||
            null;
        sheetIndices = s.getAllDependentSheetsFromSheet(l, f);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    const sheetsInfo = Ft() || [];
    const sheetMap = {};
    for (let i = 0; i < sheetsInfo.length; i++) {
        if (!sheetIndices || sheetIndices.includes(sheetsInfo[i].index)) {
            sheetMap[sheetsInfo[i].index] = sheetsInfo[i].data;
        }
    }

    // -----------------------------
    // build execSet
    // -----------------------------
    const execSet = {};
    if (s.execFunctionExist == null) {
        execSet["r" + e + "c" + n + "i" + l] = 1;
    } else {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const T = s.execFunctionExist[i];
            execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
        }
    }

    const nodes = {};
    const rangeCache = {};

    function keysForRange(R) {
        const k =
            "r" + R.row[0] + "_" + R.row[1] +
            "_c" + R.column[0] + "_" + R.column[1] +
            "_i" + R.sheetIndex;

        if (rangeCache[k]) return rangeCache[k];

        const arr = [];
        for (let r = R.row[0]; r <= R.row[1]; r++) {
            for (let c = R.column[0]; c <= R.column[1]; c++) {
                arr.push({
                    key: "r" + r + "c" + c + "i" + R.sheetIndex,
                    r, c,
                    sheetIndex: R.sheetIndex
                });
            }
        }
        rangeCache[k] = arr;
        return arr;
    }

    // -----------------------------
    // build dependency nodes
    // -----------------------------
    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const key = "r" + T.r + "c" + T.c + "i" + T.index;
        const fStr = zl(T.r, T.c, T.index);
        if (!fStr) continue;

        const ranges = [];
        const upper = fStr.toUpperCase();

        if (
            upper.includes("INDIRECT(") ||
            upper.includes("OFFSET(") ||
            upper.includes("INDEX(")
        ) {
            s.isFunctionRange(fStr, null, null, T.index, null, ref => {
                const rg = s.getcellrange($.trim(ref), T.index);
                if (rg) ranges.push(rg);
            });
        } else {
            const tokens = fStr
                .split(/==|!=|<>|<=|>=|[,()=+\-/*%&^><]/)
                .filter(Boolean);

            for (let t = 0; t < tokens.length; t++) {
                const rg = s.getcellrange($.trim(tokens[t]), T.index);
                if (rg) ranges.push(rg);
            }
        }

        nodes[key] = {
            key,
            r: T.r,
            c: T.c,
            index: T.index,
            formula: fStr,
            ranges,
            parents: {},
            children: {},
            color: "w"
        };
    }

    // -----------------------------
    // connect graph
    // -----------------------------
    for (const k in nodes) {
        const node = nodes[k];
        for (let i = 0; i < node.ranges.length; i++) {
            const refs = keysForRange(node.ranges[i]);
            for (let j = 0; j < refs.length; j++) {
                const refKey = refs[j].key;
                if (nodes[refKey]) {
                    node.children[refKey] = 1;
                    nodes[refKey].parents[node.key] = 1;
                }
            }
        }
    }

    // -----------------------------
    // ðŸ”¥ FIX #1: expand execSet transitively
    // -----------------------------
    const q = Object.keys(execSet);
    const seen = {};
    while (q.length) {
        const k = q.shift();
        if (seen[k]) continue;
        seen[k] = 1;

        const node = nodes[k];
        if (!node) continue;

        for (const ck in node.children) {
            if (!execSet[ck]) {
                execSet[ck] = 1;
                q.push(ck);
            }
        }
    }

    // -----------------------------
    // topological order
    // -----------------------------
    const ordered = [];
    const visited = {};
    const stack = [];

    for (const k in execSet) {
        if (nodes[k]) stack.push(nodes[k]);
    }

    while (stack.length) {
        const cur = stack.pop();
        if (!cur || visited[cur.key]) continue;

        if (cur.color === "b") {
            visited[cur.key] = 1;
            ordered.push(cur);
            continue;
        }

        cur.color = "b";
        stack.push(cur);
        for (const pk in cur.parents) {
            if (nodes[pk]) stack.push(nodes[pk]);
        }
    }

    ordered.reverse();

    // -----------------------------
    // ðŸ”¥ FIX #2: eager value write-back
    // -----------------------------
    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];
        window.luckysheet_getcelldata_cache = null;

        const R = s.execfunction(T.formula, T.r, T.c, T.index);
        const sheet = sheetMap[T.index];

        if (sheet && sheet[T.r] && sheet[T.r][T.c]) {
            sheet[T.r][T.c].v = R[1];
            sheet[T.r][T.c].f = R[2];
        }

        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: R[1],
            f: R[2],
            spe: R[3],
            index: T.index
        });

        s.execFunctionGlobalData[T.r + "_" + T.c + "_" + T.index] = {
            v: R[1],
            f: R[2]
        };
    }

    s.execFunctionExist = null;
}
