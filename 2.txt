execFunctionGroup: function(e, n, t, l, a, o = false) {
    if (o) return;
    const s = this;

    // --- Alias globals locally for faster lookup ---
    const getCellData = window.luckysheet_getcelldata;
    const getArrayData = window.luckysheet_getarraydata;
    const parseData = window.luckysheet_parseData;
    const getValue = window.luckysheet_getValue;
    const indirectCheck = window.luckysheet_indirect_check;
    const indirectCheckReturn = window.luckysheet_indirect_check_return;
    const offsetCheck = window.luckysheet_offset_check;
    const calcADPMM = window.luckysheet_calcADPMM;
    const getSpecialReference = window.luckysheet_getSpecialReference;

    // --- Initialize helpers ---
    if (a == null) a = h.flowdata;
    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    // --- Store explicit value if provided ---
    if (t != null) {
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = { v: t };
    }

    // --- Update cross-sheet references ---
    if (typeof _shiftCrossSheetReference === 'function') {
        _shiftCrossSheetReference({ type: 'recalc', sheetIndex: l });
    }

    // --- Get all function group cells ---
    const allFuncCells = s.getAllFunctionGroup() || [];
    const sheetsInfo = Ft() || [];
    const sheetMap = {};
    for (let sh of sheetsInfo) sheetMap[sh.index] = sh.data;

    // --- Build execSet ---
    const execSet = {};
    if (!s.execFunctionExist) {
        execSet[`r${e}c${n}i${l}`] = 1;
    } else {
        for (let T of s.execFunctionExist) {
            execSet[`r${T.r}c${T.c}i${T.i}`] = 1;
        }
    }

    const nodes = {};
    const formulaRangeCache = new Map();

    // --- Helper: get cell range keys (numeric IDs to reduce string overhead) ---
    const keysForRange = (R) => {
        const cacheKey = `${R.sheetIndex}_${R.row[0]}_${R.row[1]}_${R.column[0]}_${R.column[1]}`;
        if (formulaRangeCache.has(cacheKey)) return formulaRangeCache.get(cacheKey);
        const list = [];
        for (let rr = R.row[0]; rr <= R.row[1]; rr++) {
            for (let cc = R.column[0]; cc <= R.column[1]; cc++) {
                const id = (R.sheetIndex << 24) | (rr << 12) | cc; // numeric key
                list.push({ key: id, r: rr, c: cc, sheetIndex: R.sheetIndex });
            }
        }
        formulaRangeCache.set(cacheKey, list);
        return list;
    };

    // --- Build nodes ---
    for (let T of allFuncCells) {
        const nodeKey = (T.index << 24) | (T.r << 12) | T.c; // numeric key
        const formulaStr = zl(T.r, T.c, T.index);
        if (!formulaStr) continue;

        let formulaRanges = [];
        const upper = formulaStr.toUpperCase();

        // --- Only parse dynamic functions ---
        if (upper.includes("INDIRECT") || upper.includes("OFFSET") || upper.includes("INDEX")) {
            s.isFunctionRange(formulaStr, null, null, T.index, null, ref => {
                const rg = s.getcellrange($.trim(ref), T.index);
                if (rg) formulaRanges.push(rg);
            });
        } else if (!(formulaStr.startsWith('="') && formulaStr.endsWith('"'))) {
            const tokens = formulaStr.split(/==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/).filter(Boolean);
            for (let tk of tokens) {
                tk = tk.trim();
                if (!tk || (tk.length <= 1 && !(s.iscelldata && s.iscelldata(tk)))) continue;
                const rg = s.getcellrange($.trim(tk), T.index);
                if (rg) formulaRanges.push(rg);
            }
        }

        nodes[nodeKey] = {
            formulaArray: formulaRanges,
            calc_funcStr: formulaStr,
            key: nodeKey,
            r: T.r,
            c: T.c,
            index: T.index,
            parents: {},
            children: {},
            color: "w"
        };
    }

    // --- Build dependency graph ---
    const y = [];
    for (let node of Object.values(nodes)) {
        for (let rect of node.formulaArray || []) {
            const keys = keysForRange(rect);
            for (let cellInfo of keys) {
                const A = cellInfo.key;
                if (A in nodes) {
                    node.children[A] = 1;
                    nodes[A].parents[node.key] = 1;
                }
                if (!o && (A in execSet)) y.push(node);
            }
        }
        if (o) y.push(node);
    }

    // --- Topological sort using Kahn's algorithm ---
    const inDegree = {};
    for (let k in nodes) inDegree[k] = Object.keys(nodes[k].parents).length;
    const queue = [];
    for (let k in nodes) if (inDegree[k] === 0) queue.push(nodes[k]);
    const ordered = [];
    while (queue.length) {
        const cur = queue.shift();
        ordered.push(cur);
        for (let ch in cur.children) {
            inDegree[ch]--;
            if (inDegree[ch] === 0) queue.push(nodes[ch]);
        }
    }

    // --- Evaluate nodes ---
    window.luckysheet_getcelldata_cache = null; // clear cache once per sheet
    s.groupValuesRefreshData = [];
    for (let node of ordered) {
        const Rres = s.execfunction(node.calc_funcStr, node.r, node.c, node.index);
        s.groupValuesRefreshData.push({
            r: node.r,
            c: node.c,
            v: Rres[1],
            f: Rres[2],
            spe: Rres[3],
            index: node.index
        });
        s.execFunctionGlobalData[`${node.r}_${node.c}_${node.index}`] = { v: Rres[1], f: Rres[2] };
    }

    s.execFunctionExist = null;
}
