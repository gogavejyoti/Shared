update: function () {
    let e = this;
    if (!gr([e.applyRange], h.currentSheetIndex) || h.allowEdit === !1) return;

    let n = h.flowdata; // ðŸ”¥ NO deep copy
    let t = h.luckysheetfile[K(h.currentSheetIndex)];
    let l = $.extend(!0, {}, h.config);
    let a = Ur();
    let o = $.extend(!0, {}, t.dataVerification);

    let s = e.direction;
    let d = e.copyRange;
    let f = d.row[0], m = d.row[1];
    let g = d.column[0], y = d.column[1];

    let v = e.getCopyData(n, f, m, g, y, s);
    let k;
    s === "down" || s === "up"
        ? k = m - f + 1
        : k = y - g + 1;

    let b = e.applyRange;
    let w = b.row[0], x = b.row[1];
    let C = b.column[0], S = b.column[1];

    const dirtyCells = [];

    // ---------------- PHASE 1: COPY ONLY ----------------
    if (s === "down" || s === "up") {
        let A = x - w + 1;
        for (let R = C; R <= S; R++) {
            let I = v[R - C];
            let F = e.getApplyData(I, k, A);

            let rowIter = s === "down"
                ? (cb => { for (let N = w; N <= x; N++) cb(N, N - w); })
                : (cb => { for (let N = x; N >= w; N--) cb(N, x - N); });

            rowIter((N, idx) => {
                let D = F[idx];

                if (D && D.f != null) {
                    let z = "=" + p.functionCopy(
                        D.f,
                        s,
                        idx + 1
                    );
                    D.f = z;
                    D.v = null;
                    D.m = null;
                    dirtyCells.push({ r: N, c: R, i: h.currentSheetIndex });
                }

                n[N][R] = D;

                let srcRow = s === "down"
                    ? f + (N - w) % k
                    : m - (x - N) % k;

                let srcKey = srcRow + "_" + R;
                if (a[srcKey]) {
                    l.borderInfo.push({
                        rangeType: "cell",
                        value: { row_index: N, col_index: R, ...a[srcKey] }
                    });
                }

                if (o[srcKey]) o[N + "_" + R] = o[srcKey];
            });
        }
    } else {
        let A = S - C + 1;
        for (let R = w; R <= x; R++) {
            let I = v[R - w];
            let F = e.getApplyData(I, k, A);

            let colIter = s === "right"
                ? (cb => { for (let N = C; N <= S; N++) cb(N, N - C); })
                : (cb => { for (let N = S; N >= C; N--) cb(N, S - N); });

            colIter((N, idx) => {
                let D = F[idx];

                if (D && D.f != null) {
                    let z = "=" + p.functionCopy(
                        D.f,
                        s,
                        idx + 1
                    );
                    D.f = z;
                    D.v = null;
                    D.m = null;
                    dirtyCells.push({ r: R, c: N, i: h.currentSheetIndex });
                }

                n[R][N] = D;

                let srcCol = s === "right"
                    ? g + (N - C) % k
                    : y - (S - N) % k;

                let srcKey = R + "_" + srcCol;
                if (a[srcKey]) {
                    l.borderInfo.push({
                        rangeType: "cell",
                        value: { row_index: R, col_index: N, ...a[srcKey] }
                    });
                }

                if (o[srcKey]) o[R + "_" + N] = o[srcKey];
            });
        }
    }

    // ---------------- PHASE 2: CALCULATE ONCE ----------------
    if (dirtyCells.length > 0) {
        p.execFunctionExist = dirtyCells.map(c => ({
            r: c.r,
            c: c.c,
            i: c.i
        }));

        p.execFunctionGroup(
            null,
            null,
            null,
            h.currentSheetIndex,
            n,
            true
        );
    }

    // ---------------- FINAL RENDER ----------------
    Ye(n, h.luckysheet_select_save, {
        cfg: l,
        cdformat: t.luckysheet_conditionformat_save,
        dataVerification: o
    });

    tt();
}
