private static List<float> ForecastMetric(List<float> values, int forecastHorizon)
{
    if (values == null || values.Count == 0)
        return Enumerable.Repeat(0f, forecastHorizon).ToList();

    // Remove invalids
    values = values.Where(v => v >= 0f).ToList();
    if (values.Count == 0) return Enumerable.Repeat(0f, forecastHorizon).ToList();

    // Remove trailing zeros
    values = values.Reverse<float>().SkipWhile(v => v == 0f).Reverse().ToList();

    float minVal = values.Min();
    float maxVal = values.Max();
    float range = maxVal - minVal;

    int n = values.Count;

    // Short series or tiny variation â†’ allow small linear trend
    float level = values[0];
    float trend = 0f;
    float alpha = 0.5f; // level smoothing
    float beta = 0.3f;  // trend smoothing

    for (int i = 1; i < n; i++)
    {
        float prevLevel = level;
        level = alpha * values[i] + (1 - alpha) * (level + trend);
        trend = beta * (level - prevLevel) + (1 - beta) * trend;
    }

    // Forecast horizon
    var forecast = new List<float>();
    for (int h = 1; h <= forecastHorizon; h++)
    {
        float val = level + h * trend;
        val = Math.Max(minVal, Math.Min(maxVal, val)); // clamp to historical min/max
        forecast.Add(val);
    }

    return forecast;
}
