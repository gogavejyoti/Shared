// Global RegEx (Compiled once)
const FORMULA_SPLIT_REGEX = /==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/;

execFunctionGroup: function(e, n, t, l, a, o = !1) {
    if (o) return;
    const s = this;

    // 1. Setup helpers
    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    // Initialize Caches
    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (!s.formulaCache) s.formulaCache = {}; // PERSISTENT CACHE
    if (l == null) l = h.currentSheetIndex;

    // 2. Set Trigger Value
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // 3. Shift References
    if (typeof _shiftCrossSheetReference === 'function') {
        _shiftCrossSheetReference({ type: 'recalc', sheetIndex: l });
    }

    // 4. Gather Function Cells
    let allFuncCells = [];
    if (e && n) {
        const cacheKey = (window.luckysheet_getcelldata_cache && Object.keys(window.luckysheet_getcelldata_cache).join("+")) || null;
        const dependentSheets = s.getAllDependentSheetsFromSheet(l, cacheKey);
        allFuncCells = s.getAllDependentFunctionGroup(dependentSheets) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    if (allFuncCells.length === 0) return;

    // 5. Build Spatial Index & Node Map (Fast Lookup)
    // Structure: rowMap[sheetIndex][rowIndex] = [NodeA, NodeB...]
    const nodes = {};
    const rowMap = {}; 
    const execSet = {};

    // Helper to add to execSet
    const addToExec = (r, c, i) => execSet[(r << 12) + (c << 6) + i] = 1; // Integer hash is faster than string

    // Populate execSet from existing data
    if (s.execFunctionExist == null) {
        addToExec(e, n, l);
    } else {
        const len = s.execFunctionExist.length;
        for (let i = 0; i < len; i++) {
            const T = s.execFunctionExist[i];
            addToExec(T.r, T.c, T.i);
        }
    }

    // --- PHASE 1: Parse Formulas (With Cache) ---
    const len = allFuncCells.length;
    for (let i = 0; i < len; i++) {
        const T = allFuncCells[i];
        const rawFormula = zl(T.r, T.c, T.index);
        if (!rawFormula) continue;

        const nodeKey = "r" + T.r + "c" + T.c + "i" + T.index;
        
        // CHECK CACHE
        // We use formula string + index as key. If formula text hasn't changed, reuse ranges.
        const cacheKey = T.index + "_" + rawFormula;
        let formulaRanges = s.formulaCache[cacheKey];

        if (!formulaRanges) {
            // Cache Miss: Parse Expensive Formula
            formulaRanges = [];
            const upper = rawFormula.toUpperCase();
            
            if (upper.indexOf("INDIRECT(") > -1 || upper.indexOf("OFFSET(") > -1 || upper.indexOf("INDEX(") > -1) {
                this.isFunctionRange(rawFormula, null, null, T.index, null, function(ref) {
                    const rg = s.getcellrange($.trim(ref), T.index);
                    if (rg) formulaRanges.push(rg);
                });
            } else if (!(rawFormula.startsWith('="') && rawFormula.endsWith('"'))) {
                const tokens = rawFormula.split(FORMULA_SPLIT_REGEX);
                const tLen = tokens.length;
                for (let ti = 0; ti < tLen; ti++) {
                    const tk = tokens[ti].trim();
                    if (tk.length > 1 || (tk.length === 1 && s.iscelldata && s.iscelldata(tk))) {
                         const rg = s.getcellrange(tk, T.index);
                         if (rg) formulaRanges.push(rg);
                    }
                }
            }
            // Save to Cache
            s.formulaCache[cacheKey] = formulaRanges;
        }

        // Create Node
        const node = {
            ranges: formulaRanges,
            func: rawFormula,
            key: nodeKey,
            r: T.r, c: T.c, i: T.index,
            p: [], // Parents (Array is faster than object keys)
            color: 0 // 0: white, 1: gray, 2: black
        };
        nodes[nodeKey] = node;

        // Populate Spatial Index (Row Map)
        if(!rowMap[T.index]) rowMap[T.index] = {};
        if(!rowMap[T.index][T.r]) rowMap[T.index][T.r] = [];
        rowMap[T.index][T.r].push(node);
    }

    // --- PHASE 2: Build Graph (Spatial Lookup) ---
    const y = []; // Nodes to execute
    const nodeKeys = Object.keys(nodes);
    const nodeLen = nodeKeys.length;

    for (let i = 0; i < nodeLen; i++) {
        const node = nodes[nodeKeys[i]];
        const ranges = node.ranges;
        const rLen = ranges.length;

        for (let j = 0; j < rLen; j++) {
            const rect = ranges[j];
            const sheetIdx = rect.sheetIndex;
            
            // Fast Skip: If no formulas on this sheet, skip
            if (!rowMap[sheetIdx]) continue;

            // Spatial Search: Only iterate rows that actually exist in the map and overlap our range
            const sheetRows = rowMap[sheetIdx];
            const rStart = rect.row[0];
            const rEnd = rect.row[1];
            const cStart = rect.column[0];
            const cEnd = rect.column[1];

            // Iterate only relevant rows (Sparse check)
            for (let r = rStart; r <= rEnd; r++) {
                const rowNodes = sheetRows[r];
                if (!rowNodes) continue; // No formulas in this row

                const rowNodeLen = rowNodes.length;
                for (let k = 0; k < rowNodeLen; k++) {
                    const neighbor = rowNodes[k];
                    // Check Column overlap
                    if (neighbor.c >= cStart && neighbor.c <= cEnd) {
                        // Link Dependency: neighbor is a dependency of node
                        // neighbor -> node (neighbor is parent of node)
                        // Actually: If node A has range B1, then B1 is a child of A? 
                        // Standard: Logic is "Dependencies must run first". 
                        // If A = B1, B1 must run before A. B1 is Parent, A is Child.
                        // Wait, topological sort usually puts dependencies first.
                        // Let's stick to your original logic structure:
                        // You had: node.children[neighbor] and neighbor.parents[node]
                        
                        // Optimized: Just push to array
                        neighbor.p.push(node); 
                    }
                }
            }
        }
        
        // Add to execution queue if dirty
        const isDirty = o || execSet[(node.r << 12) + (node.c << 6) + node.i];
        if (isDirty) y.push(node);
    }

    // --- PHASE 3: Topological Sort (Iterative DFS) ---
    const ordered = [];
    const visited = {}; // integers logic faster? Objects are fine here for sparse
    const stack = y; // Reuse array

    while (stack.length > 0) {
        const cur = stack[stack.length - 1]; // Peek
        
        if (cur.color === 2) { // Black (Done)
            stack.pop();
            continue;
        }

        if (cur.color === 1) { // Gray (Visiting children/parents)
            cur.color = 2;
            ordered.push(cur);
            stack.pop();
            continue;
        }

        cur.color = 1; // Mark Gray
        const parents = cur.p;
        const pLen = parents.length;
        
        for (let i = 0; i < pLen; i++) {
            const p = parents[i];
            if (p.color === 0) {
                stack.push(p);
            }
        }
    }
    
    // Reverse because we pushed post-order
    ordered.reverse();

    // --- PHASE 4: Execution ---
    // Batch DOM updates if possible? No, engine needs sequential updates.
    const execLen = ordered.length;
    
    // Clear cache once before loop
    window.luckysheet_getcelldata_cache = null;

    for (let i = 0; i < execLen; i++) {
        const T = ordered[i];
        const Rres = s.execfunction(T.func, T.r, T.c, T.i);

        // Update Global Data directly
        const resObj = { v: Rres[1], f: Rres[2] };
        
        // Only push to RefreshData if strictly needed (Memory opt)
        s.groupValuesRefreshData.push({
            r: T.r, c: T.c, v: Rres[1], f: Rres[2], spe: Rres[3], index: T.i
        });

        s.execFunctionGlobalData[T.r + "_" + T.c + "_" + T.i] = resObj;
    }

    s.execFunctionExist = null;
}
