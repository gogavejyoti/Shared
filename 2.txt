pasteHandlerOfCopyPaste: function (e) {
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex)) return;

    let t = Q().paste,
        l = $.extend(true, {}, h.config);
    l.merge = l.merge || {};

    const a = e.HasMC,
          o = e.RowlChange,
          s = e.dataSheetIndex,
          copyRange = e.copyRange[0],
          u = copyRange.row[0],
          d = copyRange.row[1],
          f = copyRange.column[0],
          m = copyRange.column[1];

    let g = [],
        y = false;

    // Prepare copied data
    for (let idx = 0; idx < e.copyRange.length; idx++) {
        let data = Nt({ row: e.copyRange[idx].row, column: e.copyRange[idx].column }, s);
        if (e.copyRange.length > 1) {
            if (u === e.copyRange[1].row[0] && d === e.copyRange[1].row[1]) {
                data = data[0].map((_, colIdx) => data.map(row => row[colIdx]));
                g = g.concat(data);
                y = true;
            } else if (f === e.copyRange[1].column[0] && m === e.copyRange[1].column[1]) {
                g = g.concat(data);
            }
        } else g = data;
    }

    if (y) g = g[0].map((_, colIdx) => g.map(row => row[colIdx]));

    let v = $.extend(true, [], g);

    if (e.copyRange.length > 1) {
        for (let r = 0; r < v.length; r++)
            for (let c = 0; c < v[r].length; c++)
                if (v[r][c]?.f != null) delete v[r][c].f, delete v[r][c].spl;
    }

    // Determine target range
    let w = h.luckysheet_select_save[h.luckysheet_select_save.length - 1],
        x = w.row[0],
        C = w.row[1],
        S = w.column[0],
        _ = w.column[1],
        T = (C - x + 1) % v.length,
        A = (_ - S + 1) % v[0].length;

    if (T !== 0 || A !== 0) {
        C = x + v.length - 1;
        _ = S + v[0].length - 1;
    }

    // Merge conflict check
    let R = l.merge && Dt(l, x, C, S, _);
    if (R) {
        de() ? alert(t.errorNotAllowMerged) : U.info(`<i class="fa fa-exclamation-triangle"></i>${t.warning}`, t.errorNotAllowMerged);
        return;
    }

    const I = (C - x + 1) / v.length,
          F = (_ - S + 1) / v[0].length;

    let N = we.deepCopyFlowData(h.flowdata),
        P = v.length + x - N.length,
        z = v[0].length + S - N[0].length;

    if (P > 0 || z > 0) N = il([].concat(N), P, z, true);

    const O = Ur(s),
          V = $.extend(true, {}, h.luckysheetfile[K(s)].dataVerification);

    let q = null,
        formulaCells = [],
        depGraph = {};

    // Helper to extract cell references from formula
    function getFormulaRefs(formula) {
        if (!formula) return [];
        if (formula[0] === "=") formula = formula.substring(1);
        const refs = new Set();
        const cellRefRegex = /([A-Z]+)(\d+)/g;
        let match;
        while ((match = cellRefRegex.exec(formula)) !== null) {
            const colLetters = match[1], rowNum = parseInt(match[2], 10) - 1;
            let colNum = 0;
            for (let i = 0; i < colLetters.length; i++)
                colNum = colNum * 26 + (colLetters.charCodeAt(i) - 64);
            colNum -= 1;
            refs.add(`${rowNum}_${colNum}`);
        }
        return Array.from(refs);
    }

    // Paste loop: copy values/formulas (deferred)
    for (let se = 1; se <= I; se++) {
        for (let ie = 1; ie <= F; ie++) {
            let Y = x + (se - 1) * v.length,
                X = S + (ie - 1) * v[0].length,
                te = x + se * v.length,
                ee = S + ie * v[0].length;
            let ue = Y - u, he = X - f, formulaMap = {};

            for (let G = Y; G < te; G++) {
                let rowCopy = [].concat(N[G]);
                for (let pe = X; pe < ee; pe++) {
                    let cell = v[G - Y]?.[pe - X] ? $.extend(true, {}, v[G - Y][pe - X]) : null;

                    if (cell?.f != null) {
                        let Fe = cell.f;
                        if (ue > 0) Fe = "=" + p.functionCopy(Fe, "down", ue);
                        if (ue < 0) Fe = "=" + p.functionCopy(Fe, "up", Math.abs(ue));
                        if (he > 0) Fe = "=" + p.functionCopy(Fe, "right", he);
                        if (he < 0) Fe = "=" + p.functionCopy(Fe, "left", Math.abs(he));

                        cell.f = Fe;
                        cell.v = null;
                        formulaCells.push({ r: G, c: pe, f: Fe });
                        depGraph[G + "_" + pe] = getFormulaRefs(Fe);
                    }

                    rowCopy[pe] = cell;

                    // Multi-cell merge
                    if (cell && a && "mc" in cell) {
                        if (cell.mc.rs != null) {
                            cell.mc.r = G;
                            cell.mc.c = pe;
                            l.merge[cell.mc.r + "_" + cell.mc.c] = cell.mc;
                            formulaMap[cell.mc.r + "_" + cell.mc.c] = [cell.mc.r, cell.mc.c];
                        } else {
                            rowCopy[pe] = { mc: { r: formulaMap[cell.mc.r + "_" + cell.mc.c][0], c: formulaMap[cell.mc.r + "_" + cell.mc.c][1] } };
                        }
                    }
                }
                N[G] = rowCopy;
            }
        }
    }

    w.row = [x, C];
    w.column = [S, _];

    // Conditional formatting & data validation
    let ce = null;
    if (e.copyRange.length == 1) {
        const sourceCF = h.luckysheetfile[K(s)].luckysheet_conditionformat_save;
        if (sourceCF?.length > 0) {
            ce = $.extend(true, [], h.luckysheetfile[K(h.currentSheetIndex)].luckysheet_conditionformat_save);
            for (let cf of sourceCF) {
                let newRanges = [];
                for (let le = 1; le <= I; le++)
                    for (let pe = 1; pe <= F; pe++) {
                        let Y = x + (le - 1) * v.length,
                            X = S + (pe - 1) * v[0].length,
                            te = x + le * v.length,
                            ee = S + pe * v[0].length;
                        for (let r of cf.cellrange) {
                            const adjusted = $e.CFSplitRange(r, { row: [u, d], column: [f, m] }, { row: [Y, te - 1], column: [X, ee - 1] }, "operatePart");
                            if (adjusted.length > 0) newRanges = newRanges.concat(adjusted);
                        }
                    }
                if (newRanges.length > 0) {
                    let cfCopy = $.extend(true, {}, cf);
                    cfCopy.cellrange = newRanges;
                    ce.push(cfCopy);
                }
            }
        }
    }

    // Final write
    const payload = { cfg: l, RowlChange: o, cdformat: ce, dataVerification: q };
    Ye(N, h.luckysheet_select_save, payload);

    // -----------------------------
    // Extremely fast batch formula evaluation (topological)
    // -----------------------------
    const evaluated = new Set();

    function topoEval(cellKey) {
        if (evaluated.has(cellKey)) return;
        const deps = depGraph[cellKey] || [];
        for (let ref of deps) topoEval(ref);
        const [r, c] = cellKey.split("_").map(Number);
        const cell = N[r][c];
        if (cell && cell.f) {
            const result = p.execfunction(cell.f, r, c, void 0, true);
            cell.v = result[1];
            cell.f = result[2] ? "=" + result[2] : cell.f;
            if (cell.spl != null) cell.spl = result[3]?.data;
            if (cell.ct?.fa) cell.m = mt(cell.ct.fa, cell.v);
        }
        evaluated.add(cellKey);
    }

    for (let fc of formulaCells) {
        topoEval(fc.r + "_" + fc.c);
    }

    tt(); // UI update after all formulas
}
