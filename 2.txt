$("#luckysheet-icon-excel").click(async function () {
    try {
        // --- Helpers ---
        function hexToARGB(color) {
            if (!color) return undefined;

            color = String(color).trim();

            // If rgb() or rgba()
            if (color.startsWith("rgb")) {
                const nums = color.match(/[\d.]+/g).map(Number);
                const [r, g, b] = nums;
                // Ignore alpha for Excel (Excel doesn't support per-cell alpha)
                return "FF" + [r, g, b].map(n => Math.round(n).toString(16).padStart(2, "0")).join("").toUpperCase();
            }

            // Remove #
            let hex = color.replace("#", "");

            // 3-digit hex ‚Üí expand (e.g., f0c ‚Üí ff00cc)
            if (hex.length === 3) {
                hex = hex.split("").map(h => h + h).join("");
            }

            // Invalid hex ‚Üí ignore
            if (!/^[0-9A-Fa-f]{6}$/.test(hex)) {
                console.warn("Invalid HEX color:", color);
                return undefined;
            }

            return "FF" + hex.toUpperCase();
        }

        function pxToExcelWidth(px) {
            if (!px) return 10;
            return Math.max(3, Math.round(px / 7));
        }

        function normalizeFormula(formula, sheetNames) {
            if (!formula) return formula;
            sheetNames.forEach(name => {
                if (/\s/.test(name) && formula.includes(name + "!")) {
                    const re = new RegExp(name.replace(/[-\/\\^$*+?.()|[\]{ }]/g, '\\$&') + '!', 'g');
                    formula = formula.replace(re, `'${name}'!`);
                }
            });
            return formula;
        }

        // Helper: try multiple selectors for the DOM cell
        function findDomCell(r, c) {
            // Many LuckySheet builds use attributes row/column or row/col
            const selectors = [
                `#luckysheet-cell-main div[row="${r}"][column="${c}"]`,
                `#luckysheet-cell-main div[row="${r}"][col="${c}"]`,
                `.luckysheet-cell-main div[row="${r}"][column="${c}"]`,
                `.luckysheet-cell-main div[row="${r}"][col="${c}"]`
            ];
            for (const s of selectors) {
                const el = document.querySelector(s);
                if (el) return el;
            }
            return null;
        }

        const sheets = luckysheet.getAllSheets();
        const workbook = new ExcelJS.Workbook();
        workbook.creator = "LuckySheet";
        workbook.created = new Date();
        const sheetNames = sheets.map(s => s.name || 'Sheet');

        for (let si = 0; si < sheets.length; si++) {
            const sheet = sheets[si];
            const ws = workbook.addWorksheet(sheet.name || `Sheet${si + 1}`);
            const data = sheet.data || [];

            // üîπ Column widths
            if (sheet.config?.columnlen) {
                const colLens = sheet.config.columnlen;
                // ExcelJS expects columns array; fill up to max index
                const maxCol = Math.max(...Object.keys(colLens).map(k => Number(k)));
                const cols = [];
                for (let ci = 0; ci <= maxCol; ci++) {
                    if (colLens[ci] != null) {
                        cols.push({ width: pxToExcelWidth(colLens[ci]) });
                    } else {
                        cols.push({ width: pxToExcelWidth(64) }); // default
                    }
                }
                ws.columns = cols;
            }

            // üîπ Fill cell data
            for (let r = 0; r < data.length; r++) {
                const row = data[r] || [];
                for (let c = 0; c < row.length; c++) {
                    const cell = row[c];
                    if (!cell) continue;
                    const cellRef = ws.getCell(r + 1, c + 1);

                    // --- Normalize numeric, percentage, and date-like values ---
                    if (!cell.f && cell.v !== null && cell.v !== undefined) {
                        let val = cell.v;
                        const strVal = String(val).trim();

                        // Detect % values like "12%" ‚Üí 0.12
                        if (/^-?\d+(\.\d+)?%$/.test(strVal)) {
                            const num = parseFloat(strVal.replace('%', ''));
                            cell.v = num / 100;
                            cell.ct = cell.ct || {};
                            cell.ct.fa = "0.00%";
                        }

                        // Detect numeric strings ‚Üí number
                        else if (/^-?\d+(\.\d+)?$/.test(strVal)) {
                            cell.v = parseFloat(strVal);
                        }

                        // Detect date-like strings
                        else if (
                            /^\d{4}[-/]\d{2}[-/]\d{2}$/.test(strVal) || // 2025-08-20 or 2025/08/20
                            /^[0-9]{1,2}-[A-Za-z]{3}-[0-9]{2,4}$/.test(strVal) // 02-Mar-25 or 02-Mar-2025
                        ) {
                            // ‚úÖ Export as string to avoid timezone shift
                            cell.v = strVal; // Keep original string
                            cell.ct = cell.ct || {};
                            cell.ct.fa = "@"; // Excel format for text
                        }
                    }

                    // --- Value / Formula
                    if (cell.f) {
                        const f = normalizeFormula(cell.f, sheetNames);
                        cellRef.value = { formula: f, result: cell.v ?? null };
                    } else {
                        cellRef.value = cell.v ?? null;
                    }

                    // --- Font (prefer cell props; fallback to DOM computed)
                    // We'll read DOM computed font later only if needed
                    let domEl = null;
                    if (cell.fc || cell.bl || cell.it || cell.ff || cell.fs) {
                        cellRef.font = {};
                        if (cell.fc) {
                            const argb = hexToARGB(cell.fc);
                            if (argb) cellRef.font.color = { argb };
                        }
                        if (cell.bl) cellRef.font.bold = true;
                        if (cell.it) cellRef.font.italic = true;
                        if (cell.ff) cellRef.font.name = cell.ff;
                        if (cell.fs) cellRef.font.size = Number(cell.fs);
                    } else {
                        // no font info in cell ‚Äî try DOM
                        domEl = findDomCell(r, c);
                        if (domEl) {
                            const cs = window.getComputedStyle(domEl);
                            const fontColor = cs.color || null;
                            const fontSize = cs.fontSize || null;
                            const fontFamily = cs.fontFamily || null;
                            const fontWeight = cs.fontWeight || null;
                            const fontStyle = cs.fontStyle || null;
                            const textDecoration = cs.textDecoration || cs.textDecorationLine || "";

                            cellRef.font = {};
                            if (fontColor && fontColor !== "rgba(0, 0, 0, 0)") {
                                const col = hexToARGB(fontColor);
                                if (col) cellRef.font.color = { argb: col };
                            }
                            if (fontSize) {
                                const fsz = parseFloat(fontSize);
                                if (!isNaN(fsz)) cellRef.font.size = Math.round(fsz);
                            }
                            if (fontFamily) {
                                // remove quotes if any
                                cellRef.font.name = fontFamily.split(",")[0].replace(/['"]/g, "").trim();
                            }
                            if (fontWeight) {
                                const num = parseInt(fontWeight, 10);
                                if (!isNaN(num)) {
                                    if (num >= 600) cellRef.font.bold = true;
                                } else {
                                    if (fontWeight.toLowerCase() === "bold") cellRef.font.bold = true;
                                }
                            }
                            if (fontStyle && fontStyle.toLowerCase() === "italic") cellRef.font.italic = true;
                            if (textDecoration && textDecoration.toLowerCase().includes("underline")) cellRef.font.underline = true;
                        }
                    }

                    // --- Fill (static bg first)
                    let appliedFill = null;
                    if (cell.bg) {
                        const a = hexToARGB(cell.bg);
                        if (a) {
                            appliedFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: a } };
                            cellRef.fill = appliedFill;
                        }
                    }

                    // --- DOM-based background (CF or visual styles) ‚Äî only apply if we didn't set bg above or want exact visual
                    // Always check DOM to match EXACT visual look; it will override cell.bg when needed (so result equals what user sees)
                    if (!domEl) domEl = findDomCell(r, c);
                    if (domEl) {
                        const comp = window.getComputedStyle(domEl);
                        const computedBG = comp.backgroundColor;
                        // valid non-transparent background?
                        if (computedBG && computedBG !== "rgba(0, 0, 0, 0)" && computedBG !== "transparent") {
                            const argb = hexToARGB(computedBG);
                            if (argb) {
                                cellRef.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb } };
                            }
                        }
                        // Also ensure font color is exact from DOM if not set earlier
                        if ((!cell.fc) && comp.color && comp.color !== "rgba(0, 0, 0, 0)") {
                            const domFontCol = hexToARGB(comp.color);
                            if (domFontCol) {
                                cellRef.font = cellRef.font || {};
                                cellRef.font.color = { argb: domFontCol };
                            }
                        }
                    }

                    // --- Alignment
                    if (cell.ht || cell.vt || cell.tb) {
                        cellRef.alignment = {};
                        if (cell.ht) cellRef.alignment.horizontal = cell.ht;
                        if (cell.vt) cellRef.alignment.vertical = cell.vt;
                        if (cell.tb) cellRef.alignment.wrapText = cell.tb === 2;
                    } else if (domEl) {
                        // fallback alignment from DOM if not present
                        const cs = window.getComputedStyle(domEl);
                        cellRef.alignment = cellRef.alignment || {};
                        const textAlign = cs.textAlign;
                        const verticalAlign = cs.verticalAlign || null;
                        if (textAlign) cellRef.alignment.horizontal = textAlign === "start" ? "left" : textAlign;
                        if (verticalAlign) {
                            // map some likely values
                            if (verticalAlign === "middle") cellRef.alignment.vertical = "middle";
                            else if (verticalAlign === "bottom") cellRef.alignment.vertical = "bottom";
                            else cellRef.alignment.vertical = "top";
                        }
                        if (cs.whiteSpace && (cs.whiteSpace === "pre-wrap" || cs.whiteSpace === "normal")) {
                            // detect wrapping via DOM heuristics
                            cellRef.alignment.wrapText = true;
                        }
                    }

                    // --- Border
                    if (cell.border) {
                        const border = {};
                        for (const [side, val] of Object.entries(cell.border)) {
                            if (val?.color) {
                                border[side] = {
                                    style: 'thin',
                                    color: { argb: hexToARGB(val.color) }
                                };
                            }
                        }
                        cellRef.border = border;
                    } else if (domEl) {
                        // Try to derive border from DOM computed style (thin only)
                        const cs = window.getComputedStyle(domEl);
                        // Note: many times borders are painted on parent elements; this is best-effort
                        const borderProps = {
                            top: cs.borderTopColor,
                            left: cs.borderLeftColor,
                            right: cs.borderRightColor,
                            bottom: cs.borderBottomColor
                        };
                        const border = {};
                        let anyBorder = false;
                        for (const [side, col] of Object.entries(borderProps)) {
                            if (col && col !== "rgba(0, 0, 0, 0)" && col !== "transparent") {
                                anyBorder = true;
                                const argb = hexToARGB(col);
                                if (argb) border[side] = { style: 'thin', color: { argb } };
                            }
                        }
                        if (anyBorder) cellRef.border = border;
                    }

                    // --- Number format
                    if (cell.ct?.fa) {
                        const fmt = cell.ct.fa;
                        const val = cell.v;
                        if (typeof val === "number") {
                            cellRef.numFmt = fmt;
                        } else if (typeof val === "string" && fmt === "@") {
                            cellRef.numFmt = "@"; // Text format
                        }
                    }

                }
            }

            // üîπ Merged cells
            if (sheet.config?.merge) {
                Object.values(sheet.config.merge).forEach(m => {
                    if (m) {
                        try {
                            ws.mergeCells(
                                m.r + 1,
                                m.c + 1,
                                m.r + (m.rowspan || 1),
                                m.c + (m.colspan || 1)
                            );
                        } catch (e) {
                            console.warn("Merge skipped:", e);
                        }
                    }
                });
            }

            // üîπ Row heights
            if (sheet.config?.rowlen) {
                Object.entries(sheet.config.rowlen).forEach(([k, px]) => {
                    ws.getRow(Number(k) + 1).height = Math.round(px / 1.3333);
                });
            }
        }

        // üîπ Save as Excel
        const buf = await workbook.xlsx.writeBuffer();
        const fileName = (luckysheet.getluckysheetfile?.().title || 'RP_Export') + '.xlsx';
        saveAs(new Blob([buf], { type: "application/octet-stream" }), fileName);
    } catch (err) {
        console.error("‚ùå Export failed:", err);
        alert("Export failed. See console for details.");
    }
});
