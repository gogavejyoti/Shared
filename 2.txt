pasteHandlerOfCutPaste: async function (e) {
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex) || h.allowEdit === !1) return;

    const self = this;
    const t = Q().paste;
    let l = $.extend(!0, {}, h.config);
    l.merge == null && (l.merge = {});

    // async-safe recalculation helper
    async function recalc(flowdata, row, col) {
        await Promise.resolve(
            self.execFunctionGroup(
                row,
                col,
                null,
                h.currentSheetIndex,
                flowdata
            )
        );
    }

    let a = e.HasMC,
        o = e.RowlChange,
        s = e.dataSheetIndex,
        u = e.copyRange[0].row[0],
        d = e.copyRange[0].row[1],
        f = e.copyRange[0].column[0],
        m = e.copyRange[0].column[1];

    let g = $.extend(!0, [], Nt({ row: [u, d], column: [f, m] }, s)),
        y = g.length,
        v = g[0].length;

    let k = h.luckysheet_select_save.at(-1),
        b = k.row_focus,
        w = b + y - 1,
        x = k.column_focus,
        C = x + v - 1;

    if (l.merge && Dt(l, b, w, x, C)) {
        de()
            ? alert(t.errorNotAllowMerged)
            : U.info(`<i class="fa fa-exclamation-triangle"></i>${t.warning}`, t.errorNotAllowMerged);
        return;
    }

    // clone current flowdata
    let _ = we.deepCopyFlowData(h.flowdata);

    let addRow = y + b - _.length;
    let addCol = v + x - _[0].length;
    (addRow > 0 || addCol > 0) && (_ = il([].concat(_), addRow, addCol, !0));

    /* -----------------------------
       Clear source (cut operation)
    ------------------------------ */
    if (h.currentSheetIndex === s) {
        for (let r = u; r <= d; r++) {
            for (let c = f; c <= m; c++) {
                let cell = _[r][c];
                if (L(cell) === "object" && cell?.mc) {
                    cell.mc.rs && delete l.merge[cell.mc.r + "_" + cell.mc.c];
                    delete cell.mc;
                }
                _[r][c] = null;
            }
        }
    }

    /* -----------------------------
       Paste into destination
    ------------------------------ */
    let mergeMap = {};
    for (let r = b; r <= w; r++) {
        let row = [].concat(_[r]);
        for (let c = x; c <= C; c++) {
            let src = g[r - b]?.[c - x] ?? null;
            row[c] = $.extend(!0, {}, src);

            if (src && a && src.mc) {
                if (src.mc.rs != null) {
                    row[c].mc.r = r;
                    row[c].mc.c = c;
                    l.merge[r + "_" + c] = row[c].mc;
                    mergeMap[src.mc.r + "_" + src.mc.c] = [r, c];
                } else {
                    row[c] = {
                        mc: {
                            r: mergeMap[src.mc.r + "_" + src.mc.c][0],
                            c: mergeMap[src.mc.r + "_" + src.mc.c][1]
                        }
                    };
                }
            }
        }
        _[r] = row;
    }

    // update selection
    k.row = [b, w];
    k.column = [x, C];

    /* -----------------------------
       âœ… ASYNC FORMULA RECALC
       (on UPDATED flowdata)
    ------------------------------ */
    await recalc(_, b, x);

    /* -----------------------------
       Final UI apply
    ------------------------------ */
    let P = {
        sheetIndex: h.currentSheetIndex,
        data: h.flowdata,
        curData: _,
        config: $.extend(!0, {}, h.config),
        curConfig: l,
        range: { row: [u, d], column: [f, m] }
    };

    let z = {
        sheetIndex: h.currentSheetIndex,
        data: h.flowdata,
        curData: _,
        config: $.extend(!0, {}, h.config),
        curConfig: l,
        range: { row: [b, w], column: [x, C] }
    };

    addRow > 0 || addCol > 0
        ? Va(P, z, !0)
        : Va(P, z, o);
}
