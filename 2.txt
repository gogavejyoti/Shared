pasteHandlerOfCopyPaste: function (e) {
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex)) return;

    const t = Q().paste;
    let l = $.extend(true, {}, h.config);
    if (!l.merge) l.merge = {};

    const a = e.HasMC,
          o = e.RowlChange,
          s = e.dataSheetIndex,
          copyRanges = e.copyRange,
          firstRange = copyRanges[0],
          u = firstRange.row[0], d = firstRange.row[1],
          f = firstRange.column[0], m = firstRange.column[1];

    let g = [], y = false;

    // Precompute copied data
    for (let i = 0; i < copyRanges.length; i++) {
        let data = Nt({
            row: copyRanges[i].row,
            column: copyRanges[i].column
        }, s);

        if (copyRanges.length > 1) {
            if (i === 1 && u === copyRanges[1].row[0] && d === copyRanges[1].row[1]) {
                data = data[0].map((_, ci) => data.map(r => r[ci]));
                g = g.concat(data);
                y = true;
            } else if (i === 1 && f === copyRanges[1].column[0] && m === copyRanges[1].column[1]) {
                g = g.concat(data);
            }
        } else g = data;
    }

    if (y) g = g[0].map((_, ci) => g.map(r => r[ci]));

    const v = $.extend(true, [], g);
    const rowCount = v.length,
          colCount = v[0].length;

    // Remove formulas in multi-range
    if (copyRanges.length > 1) {
        for (let r = 0; r < rowCount; r++) {
            for (let c = 0; c < colCount; c++) {
                const cell = v[r][c];
                if (cell && cell.f) {
                    delete cell.f;
                    delete cell.spl;
                }
            }
        }
    }

    const sel = h.luckysheet_select_save[h.luckysheet_select_save.length - 1],
          x = sel.row[0], C = sel.row[1],
          S = sel.column[0], _ = sel.column[1];

    let pasteRows = (C - x + 1) % rowCount,
        pasteCols = (_ - S + 1) % colCount;

    if (pasteRows !== 0 || pasteCols !== 0) {
        sel.row[1] = x + rowCount - 1;
        sel.column[1] = S + colCount - 1;
    }

    // Merge check
    let R = l.merge != null && Dt(l, x, sel.row[1], S, sel.column[1]);
    if (R) {
        de() ? alert(t.errorNotAllowMerged) : U.info(`<i class="fa fa-exclamation-triangle"></i>${t.warning}`, t.errorNotAllowMerged);
        return;
    }

    const I = (sel.row[1] - x + 1) / rowCount,
          F = (sel.column[1] - S + 1) / colCount;

    let N = we.deepCopyFlowData(h.flowdata);
    const addRows = rowCount + x - N.length,
          addCols = colCount + S - N[0].length;
    if (addRows > 0 || addCols > 0) {
        N = il([].concat(N), addRows, addCols, true);
    }

    const borderMap = Ur(s),
          verifSrc = $.extend(true, {}, h.luckysheetfile[K(s)].dataVerification),
          verifTarget = $.extend(true, {}, h.luckysheetfile[K(h.currentSheetIndex)].dataVerification || {}),
          formulaCache = new Map();

    const JMC = {}; // temp merged cell mapping

    for (let rr = 1; rr <= I; rr++) {
        for (let cc = 1; cc <= F; cc++) {
            const startRow = x + (rr - 1) * rowCount,
                  startCol = S + (cc - 1) * colCount;

            for (let r = 0; r < rowCount; r++) {
                const targetRow = startRow + r;
                let rowArr = [].concat(N[targetRow]);

                for (let c = 0; c < colCount; c++) {
                    const targetCol = startCol + c;
                    const srcCell = v[r][c] ? $.extend(true, {}, v[r][c]) : null;

                    const rowOff = targetRow - (x + r),
                          colOff = targetCol - (S + c);

                    // Border
                    const keySrc = `${u + r}_${f + c}`;
                    const keyTgt = `${targetRow}_${targetCol}`;
                    if (borderMap[keySrc]) {
                        l.borderInfo = l.borderInfo || [];
                        l.borderInfo.push({
                            rangeType: "cell",
                            value: { row_index: targetRow, col_index: targetCol, ...borderMap[keySrc] }
                        });
                    } else if (borderMap[keyTgt]) {
                        l.borderInfo = l.borderInfo || [];
                        l.borderInfo.push({
                            rangeType: "cell",
                            value: { row_index: targetRow, col_index: targetCol, l: null, r: null, t: null, b: null }
                        });
                    }

                    // Data verification
                    if (verifSrc[keySrc]) verifTarget[keyTgt] = verifSrc[keySrc];

                    // Formulas
                    if (srcCell && srcCell.f) {
                        let formula = srcCell.f;
                        const cacheKey = `${formula}|${rowOff}|${colOff}`;
                        let result = formulaCache.get(cacheKey);

                        if (!result) {
                            if (rowOff > 0) formula = "=" + p.functionCopy(formula, "down", rowOff);
                            else if (rowOff < 0) formula = "=" + p.functionCopy(formula, "up", -rowOff);
                            if (colOff > 0) formula = "=" + p.functionCopy(formula, "right", colOff);
                            else if (colOff < 0) formula = "=" + p.functionCopy(formula, "left", -colOff);

                            result = p.execfunction(formula, targetRow, targetCol, undefined, true);
                            formulaCache.set(cacheKey, result);
                        }

                        if (srcCell.spl) {
                            srcCell.f = result[2];
                            srcCell.v = result[1];
                            srcCell.spl = result[3].data;
                        } else {
                            srcCell.f = result[2];
                            srcCell.v = result[1];
                            if (srcCell.ct && srcCell.ct.fa) srcCell.m = mt(srcCell.ct.fa, result[1]);
                        }
                    }

                    // Merged cells
                    if (srcCell && a && srcCell.mc) {
                        if (srcCell.mc.rs != null) {
                            srcCell.mc.r = targetRow;
                            srcCell.mc.c = targetCol;
                            l.merge[`${srcCell.mc.r}_${srcCell.mc.c}`] = srcCell.mc;
                            JMC[`${srcCell.mc.r}_${srcCell.mc.c}`] = [srcCell.mc.r, srcCell.mc.c];
                        } else {
                            srcCell.mc = { r: JMC[`${srcCell.mc.r}_${srcCell.mc.c}`][0], c: JMC[`${srcCell.mc.r}_${srcCell.mc.c}`][1] };
                        }
                    }

                    rowArr[targetCol] = srcCell;
                }

                N[targetRow] = rowArr;
            }
        }
    }

    // Conditional formatting copy
    let ce = null;
    if (copyRanges.length === 1) {
        const srcCF = h.luckysheetfile[K(s)].luckysheet_conditionformat_save || [],
              tgtCF = h.luckysheetfile[K(h.currentSheetIndex)].luckysheet_conditionformat_save || [];
        ce = $.extend(true, [], tgtCF);

        for (let cfItem of srcCF) {
            let newRanges = [];
            for (let rr = 1; rr <= I; rr++) {
                for (let cc = 1; cc <= F; cc++) {
                    const startRow = x + (rr - 1) * rowCount,
                          startCol = S + (cc - 1) * colCount,
                          endRow = startRow + rowCount - 1,
                          endCol = startCol + colCount - 1;

                    for (let orig of cfItem.cellrange) {
                        const parts = $e.CFSplitRange(orig, { row: [u, d], column: [f, m] }, { row: [startRow, endRow], column: [startCol, endCol] }, "operatePart");
                        if (parts.length) newRanges = newRanges.concat(parts);
                    }
                }
            }
            if (newRanges.length) {
                const newItem = $.extend(true, {}, cfItem);
                newItem.cellrange = newRanges;
                ce.push(newItem);
            }
        }
    }

    sel.row = [x, sel.row[1]];
    sel.column = [S, sel.column[1]];

    const params = { cfg: yl(N, x, sel.row[1], l), cdformat: ce, dataVerification: verifTarget };
    if (o || addRows > 0 || addCols > 0) {
        params.RowlChange = true;
    }

    Ye(N, h.luckysheet_select_save, params);
    tt();
}
