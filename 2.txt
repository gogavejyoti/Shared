function _shiftSameSheetReference({
    type,
    sheetIndex,
    rowIndex,
    rowCount = 1,
    colIndex,
    colCount = 1
}) {
    const sheet = (Ft() || [])[sheetIndex];
    if (!sheet || !sheet.data) return;

    let changed = false;

    // Covers A1, $A1, A$1, $A$1, ranges
    const REF_REGEX = /(\$?)([A-Z]+)(\$?)(\d+)(?::(\$?)([A-Z]+)(\$?)(\d+))?/g;

    for (let r = 0; r < sheet.data.length; r++) {
        for (let c = 0; c < (sheet.data[r] || []).length; c++) {
            const cell = sheet.data[r][c];
            if (!cell || !cell.f) continue;

            const oldF = cell.f;
            let error = false;

            cell.f = cell.f.replace(REF_REGEX, (
                _,
                sColAbs, sCol, sRowAbs, sRow,
                eColAbs, eCol, eRowAbs, eRow
            ) => {
                let sc = colToIdx(sCol);
                let sr = +sRow;
                let ec = eCol ? colToIdx(eCol) : sc;
                let er = eRow ? +eRow : sr;

                /* ===== ROW ===== */
                if (type === "deleteRow") {
                    const ds = rowIndex + 1;
                    const de = rowIndex + rowCount;

                    if ((sr >= ds && sr <= de) || (er >= ds && er <= de)) {
                        error = true;
                        return "#REF!";
                    }
                    if (!sRowAbs && sr > de) sr -= rowCount;
                    if (!eRowAbs && er > de) er -= rowCount;
                }

                if (type === "insertRow") {
                    if (!sRowAbs && sr >= rowIndex + 1) sr += rowCount;
                    if (!eRowAbs && er >= rowIndex + 1) er += rowCount;
                }

                /* ===== COLUMN ===== */
                if (type === "deleteCol") {
                    const ds = colIndex;
                    const de = colIndex + colCount - 1;

                    if ((sc >= ds && sc <= de) || (ec >= ds && ec <= de)) {
                        error = true;
                        return "#REF!";
                    }
                    if (!sColAbs && sc > de) sc -= colCount;
                    if (!eColAbs && ec > de) ec -= colCount;
                }

                if (type === "insertCol") {
                    if (!sColAbs && sc >= colIndex) sc += colCount;
                    if (!eColAbs && ec >= colIndex) ec += colCount;
                }

                const start = `${sColAbs}${idxToCol(sc)}${sRowAbs}${sr}`;
                if (!eCol) return start;

                const end = `${eColAbs}${idxToCol(ec)}${eRowAbs}${er}`;
                return `${start}:${end}`;
            });

            if (cell.f !== oldF) {
                changed = true;
                if (error) {
                    cell.v = "#REF!";
                    cell.ct = { t: "e", fa: "General" };
                }
            }
        }
    }

    if (changed) {
        jf?.refresh?.();
        typeof luckysheetrefreshgrid === "function" &&
            luckysheetrefreshgrid();
    }

    function colToIdx(c) {
        let n = 0;
        for (let i = 0; i < c.length; i++) n = n * 26 + c.charCodeAt(i) - 64;
        return n - 1;
    }
    function idxToCol(n) {
        let s = "";
        for (++n; n; n = Math.floor((n - 1) / 26))
            s = String.fromCharCode(((n - 1) % 26) + 65) + s;
        return s;
    }
}
