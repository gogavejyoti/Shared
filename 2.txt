// ================================================
//   OPTIMIZED Ucv  (No deep-copy memory explosion)
// ================================================
function Ucv(sheetObj, row, col, value, triggerUpdate = true) {

    if (!sheetObj || !sheetObj.data) return;

    const flowdata = sheetObj.data;
    const a = p;   // formula engine

    let cell = flowdata[row][col] || {};
    let oldCell = JSON.parse(JSON.stringify(cell));  // clone ONLY this cell (light)

    let isFormula = false;
    let dynamicArrayPayload = null;
    let textValue = value;
    let needsRecalc = true;

    // -----------------------------------------------------------
    // 1. BASIC NORMALIZATION (same behavior as LuckySheet)
    // -----------------------------------------------------------
    if (!textValue && xl(cell)) {
        if (cell.ct) delete cell.ct.s;
        if (cell.ct) {
            cell.ct.t = "g";
            cell.ct.fa = "General";
        }
        textValue = "";
    }

    // -----------------------------------------------------------
    // 2. PRE-EVENT HOOK
    // -----------------------------------------------------------
    if (!Je.createHookFunction("cellUpdateBefore", row, col, textValue, triggerUpdate)) {
        a.cancelNormalSelected();
        return;
    }

    // -----------------------------------------------------------
    // 3. HANDLE FORMULA OR VALUE
    // -----------------------------------------------------------
    if (typeof textValue === "string" && textValue.startsWith("=") && textValue.length > 1) {

        // ✔ The cell is a formula → evaluate it
        const evalResult = a.execfunction(textValue, row, col, undefined, true);

        isFormula = true;
        cell = { v: evalResult[1], f: evalResult[2] };

        // handle sparklines / dynamic arrays
        if (evalResult.length === 4) {
            const meta = evalResult[3];

            if (meta.type === "sparklines") {
                const sparkData = meta.data;
                if (Array.isArray(sparkData) && typeof sparkData[0] !== "object") {
                    cell.v = sparkData[0];
                } else {
                    cell.spl = sparkData;
                }
            }

            if (meta.type === "dynamicArrayItem") {
                dynamicArrayPayload = meta.data;
            }
        }

        needsRecalc = false;

    } else if (typeof textValue === "object") {

        // ✔ Input object may contain .f (formula)
        if (textValue.f && textValue.f.startsWith("=")) {
            const evalResult = a.execfunction(textValue.f, row, col, undefined, true);

            isFormula = true;
            textValue.v = evalResult[1];
            textValue.f = evalResult[2];

            if (evalResult.length === 4 && evalResult[3].type === "dynamicArrayItem") {
                dynamicArrayPayload = evalResult[3].data;
            }

            cell = textValue;
            needsRecalc = false;

        } else {
            // Normal raw object value (keep behavior)
            cell = { ...cell, ...textValue };
        }

    } else {
        // ✔ Plain value (not formula)
        a.delFunctionGroup(row, col);
        a.execFunctionGroup(row, col, textValue);

        cell = {
            ...cell,
            v: textValue
        };

        delete cell.f;
        delete cell.spl;

        if (cell.qp === 1 && ("" + textValue)[0] !== "'") {
            cell.qp = 0;
            if (cell.ct) {
                cell.ct.fa = "General";
                cell.ct.t = "n";
            }
        }

        needsRecalc = false;
    }

    // -----------------------------------------------------------
    // 4. APPLY UPDATE (NO SHEET DEEP COPY)
    // -----------------------------------------------------------
    flowdata[row][col] = cell;

    a.cancelNormalSelected();

    // -----------------------------------------------------------
    // 5. ROW HEIGHT CALC (cheap)
    // -----------------------------------------------------------
    let cfg = sheetObj.config || {};
    let rowChanged = false;

    if (!cfg.rowlen) cfg.rowlen = {};

    const cCell = flowdata[row][col];
    if ((cCell.tb === "2" && cCell.v != null) || (xl(cCell) && !cCell.mc)) {

        const defaultHeight = h.defaultrowlen;
        const canvas = document.getElementById("luckysheetTableContent").getContext("2d");

        if (!(cfg.customHeight && cfg.customHeight[row] === 1)) {
            const width = Rt(col)[1] - Rt(col)[0] - 2;
            const sizeInfo = Tr(cCell, canvas, { r: row, c: col, cellWidth: width });

            const newHeight = sizeInfo ? sizeInfo.textHeightAll + 2 : defaultHeight;

            if (newHeight > defaultHeight) {
                cfg.rowlen[row] = newHeight;
                rowChanged = true;
            }
        }
    }

    // -----------------------------------------------------------
    // 6. HANDLE DYNAMIC ARRAY
    // -----------------------------------------------------------
    let dynArray = null;
    if (dynamicArrayPayload) {
        dynArray = this.insertUpdateDynamicArray(dynamicArrayPayload);
    }

    const param = {
        dynamicArray: dynArray ? JSON.parse(JSON.stringify(dynArray)) : null,
        cfg: rowChanged ? cfg : undefined,
        RowlChange: rowChanged ? true : undefined
    };

    // -----------------------------------------------------------
    // 7. FIRE HOOK (ASYNC)
    // -----------------------------------------------------------
    setTimeout(() => {
        Je.createHookFunction("cellUpdated", row, col, oldCell, cell, triggerUpdate);
    }, 0);

    // -----------------------------------------------------------
    // 8. GLOBAL UPDATE (NO heavy deep-copy)
    // -----------------------------------------------------------
    if (triggerUpdate) {
        Ye(flowdata, [{ row: [row, row], column: [col, col] }], param, needsRecalc);
        a.execFunctionGlobalData = null;
    } else {
        return { data: flowdata, allParam: param };
    }
}
