         changeSheet: function (e, n, t, l) {
                if (de())
                    return;
                let a = this;
                if (e == h.currentSheetIndex)
                    return;
                ne.allowUpdate && ($("#luckysheet-cell-main #luckysheet-multipleRange-show").empty(),
                    ne.multipleIndex = 0);
                let o = h.luckysheetfile[a.getSheetIndex(e)];
                if (t && Je.createHookFunction("sheetCreateAfter", {
                    sheet: o
                }),
                    l && Je.createHookFunction("sheetCopyAfter", {
                        sheet: o
                    }),
                    Je.createHookFunction("sheetActivate", e, n, t),
                    $("#luckysheet-filter-selected-sheet" + h.currentSheetIndex + ", #luckysheet-filter-options-sheet" + h.currentSheetIndex).hide(),
                    $("#luckysheet-filter-selected-sheet" + e + ", #luckysheet-filter-options-sheet" + e).show(),
                    window.luckysheetCurrentIndex = e,
                    a.storeSheetParamALL(),
                    a.setCurSheet(e),
                    o.isPivotTable ? (h.luckysheetcurrentisPivotTable = !0,
                        n || Be.changePivotTable(e)) : (h.luckysheetcurrentisPivotTable = !1,
                            $("#luckysheet-modal-dialog-slider-pivot").hide(),
                            $t(!1),
                            this.refreshAllPivotTable(h.currentSheetIndex)),
                    o.load != null) {
                    let u = a.buildGridData(o);
                    o.data = u,
                        a.mergeCalculation(e),
                        a.setSheetParam(!0),
                        a.showSheet(),
                        setTimeout(function () {
                            p.execFunctionGroupForce(!0),
                                He(),
                                ne.saveParam("shs", null, h.currentSheetIndex)
                        }, 1)
                } else {
                    let u = ne.loadSheetUrl;
                    if (u == "" || h.luckysheetcurrentisPivotTable || !!t) {
                        let d = a.buildGridData(o);
                        o.data = d,
                            o.load = "1",
                            a.mergeCalculation(e),
                            a.setSheetParam(),
                            a.showSheet(),
                            setTimeout(function () {
                                a.restoreCache(),
                                    p.execFunctionGroupForce(me.forceCalculation),
                                    a.restoreSheetAll(h.currentSheetIndex),
                                    He()
                            }, 1),
                            ne.saveParam("shs", null, h.currentSheetIndex)
                    } else {
                        $("#luckysheet-grid-window-1").append(Fr());
                        let d = a.checkLoadSheetIndex(o);
                        $.post(u, {
                            gridKey: ne.gridKey,
                            index: d.join(",")
                        }, function (f) {
                            let m = new Function("return " + f)();
                            o.celldata = m[e.toString()];
                            let g = a.buildGridData(o);
                            setTimeout(function () {
                                h.loadingObj.close()
                            }, 500);
                            for (let y in m) {
                                if (y == e)
                                    continue;
                                let v = h.luckysheetfile[a.getSheetIndex(y)];
                                (v.load == null || v.load == "0") && (v.celldata = m[y.toString()],
                                    v.data = a.buildGridData(v),
                                    v.load = "1")
                            }
                            o.data = g,
                                o.load = "1",
                                a.mergeCalculation(e),
                                a.setSheetParam(),
                                a.showSheet(),
                                setTimeout(function () {
                                    a.restoreCache(),
                                        p.execFunctionGroupForce(me.forceCalculation),
                                        a.restoreSheetAll(h.currentSheetIndex),
                                        He()
                                }, 1),
                                ne.saveParam("shs", null, h.currentSheetIndex)
                        })
                    }
                }
                $("#luckysheet-cell-main .luckysheet-datavisual-selection-set").hide(),
                    $("#luckysheet-datavisual-selection-set-" + e).show(),
                    p.hideButton(),
                    Ic(e),
                    W.initialFreezen(e),
                    a.restoreselect(),
                    rc(o)
            },



            execFunctionGroupForce: function (e) {
                e ? this.execFunctionGroup(void 0, void 0, void 0, void 0, void 0, !0) : this.execFunctionGroup()
            },

            execFunctionGroup: function (e, n, t, l, a, o = !1) {
              
                const s = this;

                // initialize dependencies once (same as original)
                if (a == null) a = h.flowdata;

                if (!window.luckysheet_compareWith) {
                    window.luckysheet_compareWith = ja;
                    window.luckysheet_getarraydata = wc;
                    window.luckysheet_getcelldata = nr;
                    window.luckysheet_parseData = Ua;
                    window.luckysheet_getValue = qn;
                    window.luckysheet_indirect_check = xc;
                    window.luckysheet_indirect_check_return = _c;
                    window.luckysheet_offset_check = Cc;
                    window.luckysheet_calcADPMM = _t;
                    window.luckysheet_getSpecialReference = Tc;
                }

                if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
                if (l == null) l = h.currentSheetIndex;

                // If an explicit value is provided, store it (same behavior)
                if (t != null) {
                    const tmp = [[{ v: null }]];
                    At(0, 0, tmp, t);
                    s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
                }

                // Fetch all function group cells and sheet info
                const allFuncCells = s.getAllFunctionGroup() || [];
                const sheetsInfo = Ft() || [];
                const sheetMap = {};
                for (let i = 0; i < sheetsInfo.length; i++) sheetMap[sheetsInfo[i].index] = sheetsInfo[i].data;

                // Build execSet (existing function execution set) - identical semantics
                const execSet = {};
                if (s.execFunctionExist == null) {
                    execSet["r" + e + "c" + n + "i" + l] = 1;
                } else {
                    for (let i = 0; i < s.execFunctionExist.length; i++) {
                        const T = s.execFunctionExist[i];
                        execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
                    }
                }

                // nodes: key -> node object
                const nodes = {};
                // per-call cache: range rectangle -> list of cell keys (to avoid re-creating lists)
                const rangeToKeysCache = {};

                // helper to get keys inside a rectangular range (safe per-call cache)
                function keysForRange(R) {
                    const cacheKey = `r${R.row[0]}_${R.row[1]}_c${R.column[0]}_${R.column[1]}_i${R.sheetIndex}`;
                    if (rangeToKeysCache[cacheKey]) return rangeToKeysCache[cacheKey];
                    const list = [];
                    for (let rr = R.row[0]; rr <= R.row[1]; rr++) {
                        for (let cc = R.column[0]; cc <= R.column[1]; cc++) {
                            const k = "r" + rr + "c" + cc + "i" + R.sheetIndex;
                            list.push({ key: k, r: rr, c: cc, sheetIndex: R.sheetIndex });
                        }
                    }
                    rangeToKeysCache[cacheKey] = list;
                    return list;
                }

                // Build nodes by scanning formulas and collecting referenced ranges
                for (let i = 0; i < allFuncCells.length; i++) {
                    const T = allFuncCells[i];
                    const nodeKey = "r" + T.r + "c" + T.c + "i" + T.index;
                    const R = zl(T.r, T.c, T.index); // original formula retrieval
                    if (!R) continue;

                    const upper = R.toUpperCase();
                    const needsIsFunctionRange = upper.indexOf("INDIRECT(") > -1 || upper.indexOf("OFFSET(") > -1 || upper.indexOf("INDEX(") > -1;
                    const formulaRanges = [];

                    if (needsIsFunctionRange) {
                        // preserve original behavior for INDIRECT/OFFSET/INDEX
                        this.isFunctionRange(R, null, null, T.index, null, function (ref) {
                            const rg = s.getcellrange($.trim(ref), T.index);
                            if (rg) formulaRanges.push(rg);
                        });
                    } else if (!(R.substr(0, 2) == '="' && R.substr(R.length - 1, 1) == '"')) {
                        // faster tokenization compared to many regex / splits in original:
                        // split by common operators/parens to extract candidate tokens
                        const tokens = R.split(/==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/).filter(Boolean);
                        for (let ti = 0; ti < tokens.length; ti++) {
                            const tk = tokens[ti].trim();
                            if (!tk) continue;
                            // skip tiny tokens unless they are detected as cell-data pattern
                            if (tk.length <= 1 && !(s.iscelldata && s.iscelldata(tk))) continue;
                            const rg = s.getcellrange($.trim(tk), T.index);
                            if (rg) formulaRanges.push(rg);
                        }
                    }

                    nodes[nodeKey] = {
                        formulaArray: formulaRanges,
                        calc_funcStr: R,
                        key: nodeKey,
                        r: T.r,
                        c: T.c,
                        index: T.index,
                        parents: {},
                        chidren: {},
                        color: "w"
                    };
                }

                // Build dependency graph (children/parents) and initial worklist y (same semantics)
                const y = [];
                const nodeKeys = Object.keys(nodes);
                for (let i = 0; i < nodeKeys.length; i++) {
                    const node = nodes[nodeKeys[i]];
                    const ranges = node.formulaArray || [];
                    for (let ri = 0; ri < ranges.length; ri++) {
                        const rect = ranges[ri];
                        const keys = keysForRange(rect);
                        for (let ki = 0; ki < keys.length; ki++) {
                            const cellInfo = keys[ki];
                            const A = cellInfo.key;
                            if (A in nodes) {
                                node.chidren[A] = 1;
                                nodes[A].parents[node.key] = 1;
                            }
                            if (!o && (A in execSet)) y.push(node);
                        }
                    }
                    if (o) y.push(node);
                }

                // Topological-like traversal using stack to preserve original push/pop semantics
                const S = {}; // seen map
                const stack = y.slice(); // copy
                const ordered = [];

                while (stack.length > 0) {
                    const cur = stack.pop();
                    if (!cur || S[cur.key]) continue;

                    if (cur.color === "b") {
                        ordered.push(cur);
                        S[cur.key] = 1;
                        continue;
                    }

                    const parentKeys = Object.keys(cur.parents || {});
                    const parentNodes = [];
                    for (let pi = 0; pi < parentKeys.length; pi++) {
                        const pk = parentKeys[pi];
                        if (nodes[pk]) parentNodes.push(nodes[pk]);
                    }

                    if (parentNodes.length === 0) {
                        ordered.push(cur);
                        S[cur.key] = 1;
                    } else {
                        cur.color = "b";
                        stack.push(cur);
                        for (let p = 0; p < parentNodes.length; p++) stack.push(parentNodes[p]);
                    }
                }

                // Preserve original x.reverse() behavior: reverse ordered list
                ordered.reverse();

                // Evaluate nodes using execfunction (preserve side effects)
                for (let i = 0; i < ordered.length; i++) {
                    const T = ordered[i];
                    window.luckysheet_getcelldata_cache = null; // original cleared cache before each eval

                    const A = T.calc_funcStr;
                    const Rres = s.execfunction(A, T.r, T.c, T.index);

                    s.groupValuesRefreshData.push({
                        r: T.r,
                        c: T.c,
                        v: Rres[1],
                        f: Rres[2],
                        spe: Rres[3],
                        index: T.index
                    });

                    s.execFunctionGlobalData[T.r + "_" + T.c + "_" + T.index] = {
                        v: Rres[1],
                        f: Rres[2]
                    };
                }

                s.execFunctionExist = null;
            },
