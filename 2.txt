pasteHandler: async function (e, n) {
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex) || h.allowEdit === !1) return;

    const self = this;
    const l = Q().paste;

    // helper – async safe recalculation
    async function recalc(flowdata, row, col) {
        await Promise.resolve(
            self.execFunctionGroup(
                row,
                col,
                null,
                h.currentSheetIndex,
                flowdata
            )
        );
    }

    /* ---------------------------------------------------
       BRANCH A: Object / grid paste
    --------------------------------------------------- */
    if (typeof e === "object") {
        if (e.length === 0) return;

        let cfg = $.extend(!0, {}, h.config);
        cfg.merge == null && (cfg.merge = {});
        JSON.stringify(n).length > 2 && cfg.borderInfo == null && (cfg.borderInfo = []);

        const rowCount = e.length;
        const colCount = e[0].length;

        const startRow = h.luckysheet_select_save[0].row[0];
        const endRow = startRow + rowCount - 1;
        const startCol = h.luckysheet_select_save[0].column[0];
        const endCol = startCol + colCount - 1;

        if (cfg.merge && Dt(cfg, startRow, endRow, startCol, endCol)) {
            de()
                ? alert(l.errorNotAllowMerged)
                : U.info(`<i class="fa fa-exclamation-triangle"></i>${l.warning}`, l.errorNotAllowMerged);
            return;
        }

        let y = we.deepCopyFlowData(h.flowdata);
        let addRow = endRow - y.length + 1;
        let addCol = endCol - y[0].length + 1;

        (addRow > 0 || addCol > 0) && (y = il([].concat(y), addRow, addCol, !0));
        cfg.rowlen == null && (cfg.rowlen = {});

        let needRowResize = !1;
        let mergeMap = {};

        for (let r = startRow; r <= endRow; r++) {
            let row = [].concat(y[r]);
            let rowHeight = h.defaultrowlen;
            cfg.rowlen[r] != null && (rowHeight = cfg.rowlen[r]);

            for (let c = startCol; c <= endCol; c++) {
                // remove old merge
                if (L(row[c]) === "object" && row[c]?.mc) {
                    row[c].mc.rs && delete cfg.merge[row[c].mc.r + "_" + row[c].mc.c];
                    delete row[c].mc;
                }

                let src = e[r - startRow]?.[c - startCol] ?? null;
                row[c] = $.extend(!0, {}, src);

                // rebuild merge
                if (src?.mc) {
                    if (src.mc.rs != null) {
                        row[c].mc.r = r;
                        row[c].mc.c = c;
                        cfg.merge[r + "_" + c] = row[c].mc;
                        mergeMap[src.mc.r + "_" + src.mc.c] = [r, c];
                    } else {
                        row[c] = { mc: { r: mergeMap[src.mc.r + "_" + src.mc.c][0], c: mergeMap[src.mc.r + "_" + src.mc.c][1] } };
                    }
                }

                // borders
                if (n[r - startRow + "_" + (c - startCol)]) {
                    cfg.borderInfo.push({
                        rangeType: "cell",
                        value: {
                            row_index: r,
                            col_index: c,
                            ...n[r - startRow + "_" + (c - startCol)]
                        }
                    });
                }

                let hgt = be.getTextSize("田", ra(row[c]))[1];
                if (hgt > rowHeight) {
                    rowHeight = hgt;
                    needRowResize = !0;
                }
            }

            y[r] = row;
            rowHeight !== h.defaultrowlen && (cfg.rowlen[r] = rowHeight);
        }

        h.luckysheet_select_save = [{ row: [startRow, endRow], column: [startCol, endCol] }];

        // ✅ await recalculation on NEW flowdata
        await recalc(y, startRow, startCol);

        if (addRow > 0 || addCol > 0 || needRowResize) {
            Ye(y, h.luckysheet_select_save, { cfg, RowlChange: !0 });
        } else {
            Ye(y, h.luckysheet_select_save, { cfg });
            tt();
        }

        return;
    }

    /* ---------------------------------------------------
       BRANCH B: Plain text paste
    --------------------------------------------------- */
    e = e.replace(/\r/g, "");
    let rows = e.split("\n").map(r => r.split("\t")).filter(r => r.length);

    let u = we.deepCopyFlowData(h.flowdata);
    let sel = h.luckysheet_select_save.at(-1);

    let sr = sel.row?.[0] ?? 0;
    let sc = sel.column?.[0] ?? 0;

    let rc = rows.length;
    let cc = rows[0].length;

    if (h.config.merge && Dt(h.config, sr, sr + rc - 1, sc, sc + cc - 1)) {
        de()
            ? alert(l.errorNotAllowMerged)
            : U.info(`<i class="fa fa-exclamation-triangle"></i>${l.warning}`, l.errorNotAllowMerged);
        return;
    }

    let addR = sr + rc - u.length;
    let addC = sc + cc - u[0].length;
    (addR > 0 || addC > 0) && (u = il([].concat(u), addR, addC, !0));

    for (let r = 0; r < rc; r++) {
        let row = [].concat(u[sr + r]);
        for (let c = 0; c < cc; c++) {
            let cell = row[sc + c];
            let val = rows[r][c];

            if (B(val)) val = cell?.ct?.fa === "@" ? String(val) : parseFloat(val);

            if (cell instanceof Object) {
                cell.v = val;
                cell.m = cell.ct?.fa ? mt(cell.ct.fa, val) : val;
                if (cell.f) {
                    cell.f = "";
                    self.delFunctionGroup(sr + r, sc + c, h.currentSheetIndex);
                }
            } else {
                let t = it(val);
                row[sc + c] = { v: t[2], ct: t[1], m: t[0] };
            }
        }
        u[sr + r] = row;
    }

    sel.row = [sr, sr + rc - 1];
    sel.column = [sc, sc + cc - 1];

    // ✅ await recalculation on NEW flowdata
    await recalc(u, sr, sc);

    if (addR > 0 || addC > 0) {
        Ye(u, h.luckysheet_select_save, { RowlChange: !0 });
    } else {
        Ye(u, h.luckysheet_select_save);
        tt();
    }
}
