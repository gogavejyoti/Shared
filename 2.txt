update: function () {
    let e = this;

    if (!gr([e.applyRange], h.currentSheetIndex) || h.allowEdit === false) {
        return;
    }

    // IMPORTANT: do NOT deep copy entire sheet (performance + correctness)
    let n = h.flowdata;

    let t = h.luckysheetfile[K(h.currentSheetIndex)];
    let l = $.extend(true, {}, h.config);
    let a = Ur();
    let o = $.extend(true, {}, t.dataVerification);

    let s = e.direction;
    let d = e.copyRange;

    let f = d.row[0], m = d.row[1];
    let g = d.column[0], y = d.column[1];

    let v = e.getCopyData(n, f, m, g, y, s);
    let k;

    if (s === "down" || s === "up") {
        k = m - f + 1;
    } else {
        k = y - g + 1;
    }

    let b = e.applyRange;
    let w = b.row[0], x = b.row[1];
    let C = b.column[0], S = b.column[1];

    // Track impacted area (for correctness + future optimization)
    const impacted = {
        row: [Infinity, -1],
        column: [Infinity, -1]
    };

    /* =========================
       PHASE 1: COPY ONLY
       ========================= */

    if (s === "down" || s === "up") {

        let A = x - w + 1;

        for (let R = C; R <= S; R++) {

            let I = v[R - C];
            let F = e.getApplyData(I, k, A);

            if (s === "down") {
                for (let N = w; N <= x; N++) {
                    let D = F[N - w];

                    // --- FORMULA COPY ONLY (NO EXECUTION) ---
                    if (D.f != null) {
                        D.f = "=" + p.functionCopy(D.f, "down", N - w + 1);
                        D.v = null;
                        D.m = null;
                    }

                    n[N][R] = D;

                    impacted.row[0] = Math.min(impacted.row[0], N);
                    impacted.row[1] = Math.max(impacted.row[1], N);
                    impacted.column[0] = Math.min(impacted.column[0], R);
                    impacted.column[1] = Math.max(impacted.column[1], R);

                    // borders
                    let E = f + (N - w) % k, P = R;
                    if (a[E + "_" + P]) {
                        l.borderInfo.push({
                            rangeType: "cell",
                            value: {
                                row_index: N,
                                col_index: R,
                                ...a[E + "_" + P]
                            }
                        });
                    } else if (a[N + "_" + R]) {
                        l.borderInfo.push({
                            rangeType: "cell",
                            value: { row_index: N, col_index: R }
                        });
                    }

                    if (o[E + "_" + P]) {
                        o[N + "_" + R] = o[E + "_" + P];
                    }
                }
            }

            if (s === "up") {
                for (let N = x; N >= w; N--) {
                    let D = F[x - N];

                    if (D.f != null) {
                        D.f = "=" + p.functionCopy(D.f, "up", x - N + 1);
                        D.v = null;
                        D.m = null;
                    }

                    n[N][R] = D;

                    impacted.row[0] = Math.min(impacted.row[0], N);
                    impacted.row[1] = Math.max(impacted.row[1], N);
                    impacted.column[0] = Math.min(impacted.column[0], R);
                    impacted.column[1] = Math.max(impacted.column[1], R);

                    let E = m - (x - N) % k, P = R;
                    if (a[E + "_" + P]) {
                        l.borderInfo.push({
                            rangeType: "cell",
                            value: {
                                row_index: N,
                                col_index: R,
                                ...a[E + "_" + P]
                            }
                        });
                    } else if (a[N + "_" + R]) {
                        l.borderInfo.push({
                            rangeType: "cell",
                            value: { row_index: N, col_index: R }
                        });
                    }

                    if (o[E + "_" + P]) {
                        o[N + "_" + R] = o[E + "_" + P];
                    }
                }
            }
        }

    } else if (s === "right" || s === "left") {

        let A = S - C + 1;

        for (let R = w; R <= x; R++) {

            let I = v[R - w];
            let F = e.getApplyData(I, k, A);

            if (s === "right") {
                for (let N = C; N <= S; N++) {
                    let D = F[N - C];

                    if (D.f != null) {
                        D.f = "=" + p.functionCopy(D.f, "right", N - C + 1);
                        D.v = null;
                        D.m = null;
                    }

                    n[R][N] = D;

                    impacted.row[0] = Math.min(impacted.row[0], R);
                    impacted.row[1] = Math.max(impacted.row[1], R);
                    impacted.column[0] = Math.min(impacted.column[0], N);
                    impacted.column[1] = Math.max(impacted.column[1], N);

                    let E = R, P = g + (N - C) % k;
                    if (a[E + "_" + P]) {
                        l.borderInfo.push({
                            rangeType: "cell",
                            value: {
                                row_index: R,
                                col_index: N,
                                ...a[E + "_" + P]
                            }
                        });
                    } else if (a[R + "_" + N]) {
                        l.borderInfo.push({
                            rangeType: "cell",
                            value: { row_index: R, col_index: N }
                        });
                    }

                    if (o[E + "_" + P]) {
                        o[R + "_" + N] = o[E + "_" + P];
                    }
                }
            }

            if (s === "left") {
                for (let N = S; N >= C; N--) {
                    let D = F[S - N];

                    if (D.f != null) {
                        D.f = "=" + p.functionCopy(D.f, "left", S - N + 1);
                        D.v = null;
                        D.m = null;
                    }

                    n[R][N] = D;

                    impacted.row[0] = Math.min(impacted.row[0], R);
                    impacted.row[1] = Math.max(impacted.row[1], R);
                    impacted.column[0] = Math.min(impacted.column[0], N);
                    impacted.column[1] = Math.max(impacted.column[1], N);

                    let E = R, P = y - (S - N) % k;
                    if (a[E + "_" + P]) {
                        l.borderInfo.push({
                            rangeType: "cell",
                            value: {
                                row_index: R,
                                col_index: N,
                                ...a[E + "_" + P]
                            }
                        });
                    } else if (a[R + "_" + N]) {
                        l.borderInfo.push({
                            rangeType: "cell",
                            value: { row_index: R, col_index: N }
                        });
                    }

                    if (o[E + "_" + P]) {
                        o[R + "_" + N] = o[E + "_" + P];
                    }
                }
            }
        }
    }

    /* =========================
       PHASE 2: CALCULATE ONCE
       ========================= */

    window.luckysheet_getcelldata_cache = null;

    p.execFunctionGroup(
        null,
        null,
        null,
        h.currentSheetIndex,
        n,
        true
    );

    /* =========================
       PHASE 3: CF + UI (UNCHANGED)
       ========================= */

    let _ = $.extend(true, [], t.luckysheet_conditionformat_save);
    if (_ && _.length > 0) {
        for (let i = 0; i < _.length; i++) {
            let ranges = _.i.cellrange || [];
            let newRanges = [];
            for (let j = 0; j < ranges.length; j++) {
                let r = $e.CFSplitRange(
                    ranges[j],
                    { row: d.row, column: d.column },
                    { row: b.row, column: b.column },
                    "operatePart"
                );
                if (r.length > 0) newRanges = newRanges.concat(r);
            }
            if (newRanges.length > 0) {
                _.i.cellrange.push(b);
            }
        }
    }

    Ye(n, h.luckysheet_select_save, {
        cfg: l,
        cdformat: _,
        dataVerification: o
    });

    tt();
}
