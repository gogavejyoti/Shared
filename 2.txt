pasteHandler: function (e, n) {
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex) || h.allowEdit === false) {
        return;
    }

    let lang = Q().paste;

    if (h.luckysheet_select_save.length > 1) {
        U.info(`<i class="fa fa-exclamation-triangle"></i>${lang.warning}`, lang.errorNotAllowMulti);
        return;
    }

    // *** CASE 1: e is parsed JSON (from copy inside Luckysheet) ***
    if (typeof e === "object") {
        if (e.length === 0) return;

        let cfg = $.extend(true, {}, h.config);
        cfg.merge ??= {};
        if (JSON.stringify(n).length > 2 && cfg.borderInfo == null) cfg.borderInfo = [];

        let rows = e.length;
        let cols = e[0].length;

        let r0 = h.luckysheet_select_save[0].row[0];
        let c0 = h.luckysheet_select_save[0].column[0];
        let r1 = r0 + rows - 1;
        let c1 = c0 + cols - 1;

        // Block merged-area overwrite
        if (Dt(cfg, r0, r1, c0, c1)) {
            U.info(`<i class="fa fa-exclamation-triangle"></i>${lang.warning}`, lang.errorNotAllowMerged);
            return;
        }

        let newData = we.deepCopyFlowData(h.flowdata);
        let Radd = r1 - newData.length + 1;
        let Cadd = c1 - newData[0].length + 1;

        if (Radd > 0 || Cadd > 0) newData = il([].concat(newData), Radd, Cadd, true);

        cfg.rowlen ??= {};
        let mergeMapping = {};
        let rowChange = false;

        for (let r = r0; r <= r1; r++) {
            let row = [].concat(newData[r]);
            let baseHeight = cfg.rowlen[r] ?? h.defaultrowlen;

            for (let c = c0; c <= c1; c++) {
                let cellData = e[r - r0][c - c0];

                // Clear merged cell structure & rebuild
                if (row[c] && typeof row[c] === "object" && "mc" in row[c]) {
                    if ("rs" in row[c].mc) delete cfg.merge[row[c].mc.r + "_" + row[c].mc.c];
                    delete row[c].mc;
                }

                // Copy cell
                row[c] = $.extend(true, {}, cellData);

                // Rebuild merge master info
                if (cellData && "mc" in cellData) {
                    if (cellData.mc.rs != null) {
                        row[c].mc.r = r;
                        row[c].mc.c = c;
                        cfg.merge[r + "_" + c] = row[c].mc;
                        mergeMapping[cellData.mc.r + "_" + cellData.mc.c] = [r, c];
                    } else {
                        row[c] = {
                            mc: {
                                r: mergeMapping[cellData.mc.r + "_" + cellData.mc.c][0],
                                c: mergeMapping[cellData.mc.r + "_" + cellData.mc.c][1]
                            }
                        };
                    }
                }

                // Apply borders
                if (n[r - r0 + "_" + (c - c0)]) {
                    cfg.borderInfo.push({
                        rangeType: "cell",
                        value: {
                            row_index: r,
                            col_index: c,
                            ...n[r - r0 + "_" + (c - c0)]
                        }
                    });
                }

                // Adjust row height if needed
                let font = ra(row[c]);
                let hpx = be.getTextSize("田", font)[1];
                if (hpx > baseHeight) {
                    cfg.rowlen[r] = hpx;
                    rowChange = true;
                }
            }
            newData[r] = row;
        }

        h.luckysheet_select_save = [{ row: [r0, r1], column: [c0, c1] }];

        let updateCfg = rowChange ? { cfg, RowlChange: true } : { cfg };
        Ye(newData, h.luckysheet_select_save, updateCfg);
        return;
    }

    // *** CASE 2: Plain text paste (Notepad, external source) ***
    e = e.replace(/\r/g, "");
    let rows = e.split("\n").filter(x => x.trim().length > 0);
    let parsed = rows.map(r => r.split("\t"));

    let target = we.deepCopyFlowData(h.flowdata);
    let sel = h.luckysheet_select_save[h.luckysheet_select_save.length - 1];

    let r0 = sel.row?.[0] ?? 0;
    let c0 = sel.column?.[0] ?? 0;

    let g = parsed.length;
    let y = parsed[0].length;

    // Block merge overwrite
    if (Dt(h.config, r0, r0 + g - 1, c0, c0 + y - 1)) {
        U.info(`<i class="fa fa-exclamation-triangle"></i>${lang.warning}`, lang.errorNotAllowMerged);
        return;
    }

    // Expand sheet if needed
    let Radd = r0 + g - target.length;
    let Cadd = c0 + y - target[0].length;
    if (Radd > 0 || Cadd > 0) target = il([].concat(target), Radd, Cadd, true);

    // MAIN LOOP — apply pasted cells
    for (let r = 0; r < g; r++) {
        let row = [].concat(target[r0 + r]);
        for (let c = 0; c < y; c++) {
            let S = row[c0 + c];
            let val = parsed[r][c];

            // *** FORMULA DETECTION — SAME AS updatecell ***
            if (typeof val === "string" && val.startsWith("=") && val.length > 1) {
                let ef = p.execfunction(val, r0 + r, c0 + c, undefined, true);

                if (!(S instanceof Object)) S = {};

                S.f = ef[2];   // raw formula
                S.v = ef[1];   // evaluated value

                // sparkline support
                if (ef.length === 4) {
                    if (ef[3].type === "sparklines") {
                        delete S.m;
                        delete S.v;
                        let d = ef[3].data;
                        if (Array.isArray(d) && typeof d[0] !== "object") S.v = d[0];
                        else S.spl = ef[3].data;
                    }
                }

                row[c0 + c] = S;
                continue; // **IMPORTANT**
            }

            // *** Normal non-formula paste ***
            if (S instanceof Object) {
                S.v = val;
                S.m = val;
                if (S.f) {
                    S.f = "";
                    p.delFunctionGroup(r0 + r, c0 + c, h.currentSheetIndex);
                }
            } else {
                let info = it(val);
                S = {
                    v: info[2],
                    ct: info[1],
                    m: info[0]
                };
                row[c0 + c] = S;
            }
        }
        target[r0 + r] = row;
    }

    sel.row = [r0, r0 + g - 1];
    sel.column = [c0, c0 + y - 1];

    Ye(target, h.luckysheet_select_save);
    tt();
}
