DATE: function () {
                if (arguments.length < this.m[0] || arguments.length > this.m[1])
                    return p.error.na;
                for (var e = 0; e < arguments.length; e++) {
                    var n = p.errorParamCheck(this.p, arguments[e], e);
                    if (!n[0])
                        return p.error.v
                }
                try {
                    var t = M.getFirstValue(arguments[0]);
                    if (H(t))
                        return t;
                    if (!B(t))
                        return p.error.v;
                    t = parseInt(t);
                    var l = M.getFirstValue(arguments[1]);
                    if (H(l))
                        return l;
                    if (!B(l))
                        return p.error.v;
                    l = parseInt(l);
                    var a = M.getFirstValue(arguments[2]);
                    if (H(a))
                        return a;
                    if (!B(a))
                        return p.error.v;
                    if (a = parseInt(a),
                        t < 0 || t >= 1e4)
                        return p.error.nm;
                    t >= 0 && t <= 1899 && (t = t + 1900);
                    var o = (0,
                        j.default)().set({
                            year: t,
                            month: l - 1,
                            date: a
                        });
                    return (0,
                        j.default)(o).year() < 1900 ? p.error.nm : (0,
                            j.default)(o).format("YYYY-MM-DD")
                } catch (u) {
                    var s = u;
                    return s = p.errorInfo(s),
                        [p.error.v, s]
                }
            },
