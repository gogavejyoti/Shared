(function ($) {
    $.fn.trendAnalytics = function (options) {
        const settings = $.extend({
            data: [], // JSON array
        }, options);

        let filteredTransformedData = settings.data;
        let isMLTrend = false;
        $('#trendAnalyticModal').remove();

        if ($('#trendAnalyticModalStyles').length === 0) {
            $('head').append(`
            <style id="trendAnalyticModalStyles">
                /* Modal Content Styling */
                #trendAnalyticModal .modal-content { border-radius: 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.12); font-family: 'Inter', sans-serif; background: #fafafa; }
                #trendAnalyticModal .modal-header { border-bottom: 1px solid #e0e0e0; background-color: #D7C4F0; color: #2c2c2c; }
                #trendAnalyticModal .modal-title { font-weight: 600; color: #2c2c2c; }
                #trendAnalyticModal .btn-close { filter: invert(30%); }

                /* Table Wrapper */
                #trendAnalyticModal .table-wrapper { overflow-x: auto; overflow-y: auto; max-height: calc(100vh - 120px); position: relative; border: 1px solid #dcdcdc; background: #fff; border-radius: 8px; margin: 10px; }
                #trendAnalyticModal table { border-collapse: collapse; width: max-content; table-layout: auto; }
                #trendAnalyticModal th, #trendAnalyticModal td { padding: 8px; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; border-top: 1px solid #eaeaea; background: #fff; }


                #trendAnalyticModal .simTable thead th { position: sticky;top: 0;background: #fff;z-index: 3;border-top: 2px solid #dee2e6;color: #000;}
                #trendAnalyticModal .simTable th:first-child,.simTable td:first-child {position: sticky;left: 0;background-color: #f8f9fa; z-index: 2;
                #trendAnalyticModal .simTable thead th box-shadow: 2px 0 0 rgba(0,0,0,0.04);color:#000;}

                #trendAnalyticModal .cell-manual-sim {background: #DDF4E7 !important;}
                #trendAnalyticModal .week-cell {background: blueviolet !important; color: #fff !important;}

                /* Sticky Headers */
                #trendAnalyticModal thead th { position: sticky; top: 0; background: #f5f5f5; z-index: 6; }
                #trendAnalyticModal thead th.sticky-left { position: sticky; top: 0; left: 0; background: #f5f5f5; z-index: 9; min-width: 140px; }
                #trendAnalyticModal thead th.sticky-left-2 { position: sticky; top: 0; left: 140px; background: #f5f5f5; z-index: 9; min-width: 150px; }

                #trendAnalyticModal tbody td.sticky-left { position: sticky; left: 0; background: #f0f0f0; z-index: 7; min-width: 140px; }
                #trendAnalyticModal tbody td.sticky-left-2 { position: sticky; left: 140px; background: #f0f0f0; z-index: 7; min-width: 150px; }

                /* Conditional Coloring */
                #trendAnalyticModal .rag-red { color: #e74c3c; font-weight: bold; }
                #trendAnalyticModal .rag-amber { color: #f39c12; font-weight: bold; }
                #trendAnalyticModal .rag-green { color: #27ae60; font-weight: bold; }

                /* Filter Container */
                #trendAnalyticModal .sticky-col{ background: gray !important; color: #fff !important;border-right: 1px solid #fff !important;}
                #trendAnalyticModal .filter-container { margin: 10px; font-size: 0.875rem; }
                #trendAnalyticModal .dropdown-checkbox { max-height: 250px; overflow-y: auto; padding: 10px; }

                /* Buttons */
                #trendAnalyticModal .btn-sm { border-radius: 6px; font-size: 0.875rem; }
                #applyFilterBtn { background: #9b59b6; border-color: #9b59b6; }
                #applyFilterBtn:hover { background: #8e44ad; border-color: #8e44ad; }
            </style>
            `);
        }


        const modalHTML = `
        <div class="modal fade" id="trendAnalyticModal" tabindex="-1" style="z-index:9999;zoom:85%">
          <div class="modal-dialog" style="width: 100%;margin: 0;height: 100%;max-width: none;">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title">Assumption Simulator</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
              </div>
              <div class="modal-body p-0">
                <div class="filter-container">
                 <div style="display: flex;align-items: center;justify-content: center;gap: 10px 10px;">
                        <label><b>LOB:</b></label><br/>
                            <div class="dropdown">
                                <button class="btn btn-sm dropdown-toggle" type="button" id="lobDropdownBtn" data-bs-toggle="dropdown" style="border: 1px solid;border-radius: 5px;">Select LOBs</button>
                                <div class="dropdown-menu dropdown-checkbox" aria-labelledby="lobDropdownBtn" id="lobDropdown"></div>
                            </div>

 <label><b>Week From:</b></label><br/>
                            <div class="dropdown">
                                <button class="btn btn-sm dropdown-toggle" type="button" id="weekFromDropdownBtn" data-bs-toggle="dropdown" style="border: 1px solid;border-radius: 5px;">Select From Week</button>
                                <div class="dropdown-menu dropdown-checkbox" aria-labelledby="weekFromDropdownBtn" id="weekFromDropdown"></div>
                            </div>

<label><b>Week To:</b></label><br/>
                            <div class="dropdown">
                                <button class="btn btn-sm dropdown-toggle" type="button" id="weekToDropdownBtn" data-bs-toggle="dropdown" style="border: 1px solid;border-radius: 5px;">Select To Week</button>
                                <div class="dropdown-menu dropdown-checkbox" aria-labelledby="weekToDropdownBtn" id="weekToDropdown"></div>
                            </div>
 <button id="applyFilterBtn" class="btn btn-primary btn-sm">Apply Filter</button>
  </div>
  <div class="rounded shadow-sm" style="display: flex;justify-content: center;gap: 10px 10px;padding: 20px;background: #F4FDE4;margin-top: 5px;zoom: 90%;">
<label>Simulation Shrinkage %: </label>  <div><input type="number" step="0.1" min="0" class="sim-input-global-shrink w-20 p-0.5 border rounded"></div>
 <label>Simulation Attrition %: </label>  <div><input type="number" step="0.1" min="0" class="sim-input-global-attr w-20 p-0.5 border rounded"></div>
 <div class="col-auto"> <button class="btn btn-success btn-apply px-3 py-1 bg-blue-500 rounded btn-sm">Apply</button></div>
                        <div class="col-auto"> <button class="btn btn-danger btn-reset px-3 py-1 rounded btn-sm">Reset</button></div>
<input class="form-check-input" type="checkbox" id="mlShrinkage">
      <label class="form-check-label" for="mlShrinkage">
        ML Shrinkage
      </label>
  <input class="form-check-input" type="checkbox" id="mlAttrition">
      <label class="form-check-label" for="mlAttrition">
        ML Attrition
      </label>
                            <div class="dropdown">
                                <button class="btn btn-sm dropdown-toggle" type="button" id="weekDropdownBtn" data-bs-toggle="dropdown" style="border: 1px solid;border-radius: 5px;">Select Weeks</button>
                                <div class="dropdown-menu dropdown-checkbox" aria-labelledby="weekDropdownBtn" id="weekDropdown"></div>
                            </div>
                      

  <button class="btn-ml-trend px-3 py-1 bg-green-500 rounded btn-sm">ðŸ§  ML Trend</button>
<div class="col-auto"> <button id="applyToPlanBtn" class="btn btn-success btn-sm">ðŸ“Š Apply to Plan</button></div>

                </div>

  </div>

                </div>  
                <div class="table-wrapper" id="trendAnalyticContainer"></div>
              </div>
            </div>
          </div>
        </div>`;


        const $toolbar = $(modalHTML);

        $('body').append($toolbar);
        const $container = $('#trendAnalyticContainer');
        $container.empty().addClass('assumption-simulator');

        let weeks = [...new Set(settings.data.map(d => d.week))].sort((a, b) => new Date(a) - new Date(b));
        let lobs = [...new Set(settings.data.map(d => d.lob))];
       
        function populateFilters() {
            // LOB
            const lobContainer = document.createDocumentFragment();
            lobContainer.appendChild(document.createElement('label')).innerHTML = `<label><input type="checkbox" class="lobSelectAll" checked> <b>Select All</b></label><br/>`;
            lobs.forEach(lob => { const label = document.createElement('label'); label.innerHTML = `<input type="checkbox" class="lobCheckbox" value="${lob}" checked> ${lob}`; lobContainer.appendChild(label); lobContainer.appendChild(document.createElement('br')); });
            $('#lobDropdown').append(lobContainer);


            // Weeks
            const weekFrom = weeks[0];
            weeks.forEach(week => {
                $('#weekFromDropdown').append(`<label><input type="radio" name="weekFrom" value="${week}" ${week === weekFrom ? 'checked' : ''}> ${week}</label><br/>`);
                $('#weekToDropdown').append(`<label><input type="radio" name="weekTo" value="${week}" ${week === weeks[weeks.length - 1] ? 'checked' : ''}> ${week}</label><br/>`);
            });

            updateDropdownLabel('lobDropdown', lobs, 'Select LOBs');
            updateRadioDropdownLabel('weekFromDropdownBtn', weekFrom, 'From');
            updateRadioDropdownLabel('weekToDropdownBtn', weeks[weeks.length - 1], 'To');

            getMLWeeks();

        }

        function updateDropdownLabel(dropdownId, selectedItems, placeholder) {
            const btn = $(`#${dropdownId}Btn`);
            btn.text(selectedItems.length === 0 ? placeholder : `${placeholder.split(' ')[0]} (${selectedItems.length}) selected`);
        }
        function updateRadioDropdownLabel(dropdownBtnId, selectedValue, prefix) {
            $(`#${dropdownBtnId}`).text(`${prefix}: ${selectedValue}`);
        }



        // Store simulated values (manual or ML)
        const simulatedValues = {};

        // Store original metrics
        const originalMetrics = {};
        lobs.forEach(lob => {
            weeks.forEach(week => {
                const d = settings.data.find(x => x.lob === lob && x.week === week);
                if (d) {
                    originalMetrics[`${lob}_${week}`] = {
                        fteRequired: d.fteRequired,
                        fteAvailable: d.fteAvailable,
                        delta: d.delta,
                        staffingPct: d.staffingPct,
                        shrinkage: d.plannedShrinkage,
                        attrition: d.plannedAttrition ?? 0
                    };
                }
            });
        });







        // Table
        const $tableWrapper = $('<div class="sim-table-wrapper overflow-x-auto"></div>');
     

        const fmt = (val, metric) => (val !== null && val !== undefined && !isNaN(val)) ?
            (metric?.includes("Shrinkage") || metric?.includes("Attrition")) ? parseFloat(val).toFixed(1) : parseFloat(val).toFixed(0)
            : 'NA';

        function getData(lob, week) {
            return filteredTransformedData.find(d => d.lob === lob && d.week === week);
        }


        $('#trendAnalyticModal').on('hidden.bs.modal', function () {
            $('#trendAnalyticModal').remove();
            $('#trendAnalyticModalStyles').remove();
        });

        // Initialize simulated values from planned
        function initSimulated() {
            lobs.forEach(lob => {
                weeks.forEach(week => {
                    const d = getData(lob, week);
                    simulatedValues[`${lob}_${week}_shrink`] = d?.plannedShrinkage ?? 0;
                    simulatedValues[`${lob}_${week}_attr`] = d?.plannedAttrition ?? 0;
                });
            });
        }
        initSimulated();

        // Calculate simulated metrics (FTE / Delta / Staffing) based on simulatedValues
        let fteAvailPreWk = {};
        function calcSimulated(d) {
            if (!d) return {};

            const shrinkInput = $toolbar.find('.sim-input-global-shrink').val();
            const attrInput = $toolbar.find('.sim-input-global-attr').val();
            const shrinkageChecked = document.getElementById('mlShrinkage').checked;
            const attritionChecked = document.getElementById('mlAttrition').checked;


            const shrink = simulatedValues[`${d.lob}_${d.week}_shrink`] ?? 0;
            let attr = simulatedValues[`${d.lob}_${d.week}_attr`] ?? 0;

            let fteReq = null, fteAvail = null, delta = null, staffing = null;

            const orig = originalMetrics[`${d.lob}_${d.week}`];

            if (shrink === d.plannedShrinkage && attr === (d.plannedAttrition ?? 0)) {
                fteReq = orig?.fteRequired ?? null;
                fteAvail = orig?.fteAvailable ?? null;
                delta = orig?.delta ?? null;
                staffing = orig?.staffingPct ?? null;
            } else {

                if (shrinkInput || (isMLTrend && shrinkageChecked) )
                    fteReq = d.fteRequired != null ? d.fteRequired * (1 - d.plannedShrinkage / 100) / (1 - shrink / 100) : null;
                else
                    fteReq = d.fteRequired;

                if (((attrInput || (isMLTrend && attritionChecked)) && d.week != weeks[0]))
                    fteAvail = fteAvailPreWk[d.lob] != null ? d.fteAvailable * (1 - (attr - d.plannedAttrition) / 100) : d.fteAvailable != null ? d.fteAvailable * (1 - attr / 100) : null;
                else {
                    fteAvail = d.fteAvailable;
                    attr = d.plannedAttrition;
                }

                delta = fteReq != null && fteAvail != null ? fteAvail - fteReq : null;
                staffing = fteReq ? (fteAvail / fteReq * 100) : null;
            }

            fteAvailPreWk[d.lob] = fteAvail;

            return {
                'FTE Required': fteReq,
                'FTE Available': fteAvail,
                'Delta': delta,
                'Staffing %': staffing,
                'Simulated Shrinkage %': shrink,
                'Simulated Attrition %': attr
            };
        }




        function getArrow(sim, orig) {
            if (sim === 'NA' || orig === 'NA') return '';
            sim = parseFloat(sim);
            orig = parseFloat(orig);
            if (sim > orig) return 'ðŸ¡…';
            if (sim < orig) return 'ðŸ¡‡';
            return '';
        }

        function renderTable() {

            $tableWrapper.empty();
            const $table = $('<table class="table sim-table min-w-max border-collapse border border-gray-200"></table>');
            $tableWrapper.append($table);
            $container.append($tableWrapper);

            // Table header
            let headerHtml = `<thead><tr>
            <th class="sticky-col border" nowrap>LOB / Overall</th>
            <th class="sticky-col border" nowrap>Metric</th>`;
            weeks.forEach(w => headerHtml += `<th class="border text-center week-cell" colspan="2" nowrap>${w}</th>`);
            headerHtml += `</tr><tr><th></th><th></th>`;
            weeks.forEach(_ => headerHtml += `<th nowrap>Original</th><th class="cell-manual-sim" style="min-width:55px;" nowrap>Simulated</th>`);
            headerHtml += `</tr></thead>`;
            $table.append(headerHtml);
            const $tbody = $('<tbody></tbody>');
            $table.append($tbody);

            const metrics = ['FTE Required', 'FTE Available', 'Delta', 'Staffing %', 'Planned Shrinkage %', 'Simulated Shrinkage %', 'Planned Attrition %', 'Simulated Attrition %'];
            const simulatedOnlyMetrics = ['Simulated Shrinkage %', 'Simulated Attrition %'];
            const percentMetrics = ['Staffing %', 'Planned Shrinkage %', 'Simulated Shrinkage %', 'Planned Attrition %', 'Simulated Attrition %'];



            // Overall row
            metrics.forEach(metric => {
                const $tr = $('<tr></tr>');
                if (metric === 'FTE Required') $tr.append(`<td class="sticky-col font-bold" rowspan="${metrics.length}" nowrap>Overall</td>`);
                $tr.append(`<td class="sticky-col" nowrap>${metric}</td>`);

                weeks.forEach(week => {
                    const weekData = lobs.map(lob => getData(lob, week)).filter(d => d);
                    let original = 'NA', simulated = 'NA';
                    if (weekData.length) {
                        if (simulatedOnlyMetrics.includes(metric)) {
                            original = 'NA';
                            const vals = weekData.map(d => calcSimulated(d)[metric]).filter(v => v != null && !isNaN(v));
                            if (vals.length) simulated = fmt(vals.reduce((a, b) => a + b, 0) / vals.length, metric);
                        } else {
                            const origVals = weekData.map(d => {
                                switch (metric) {
                                    case 'FTE Required': return d.fteRequired;
                                    case 'FTE Available': return d.fteAvailable;
                                    case 'Delta': return d.delta;
                                    case 'Staffing %': return d.staffingPct;
                                    case 'Planned Shrinkage %': return d.plannedShrinkage;
                                    case 'Planned Attrition %': return d.plannedAttrition ?? 0;
                                    default: return null;
                                }
                            }).filter(v => v != null && !isNaN(v));
                            if (origVals.length) original = percentMetrics.includes(metric) ? fmt(origVals.reduce((a, b) => a + b, 0) / origVals.length, metric) : fmt(origVals.reduce((a, b) => a + b, 0), metric);
                            const simVals = weekData.map(d => calcSimulated(d)[metric]).filter(v => v != null && !isNaN(v));
                            if (simVals.length) simulated = percentMetrics.includes(metric) ? fmt(simVals.reduce((a, b) => a + b, 0) / simVals.length, metric) : fmt(simVals.reduce((a, b) => a + b, 0), metric);
                        }
                    }

                    const isNeg = !isNaN(simulated) && parseFloat(simulated) < 0;
                    const arrow = !simulatedOnlyMetrics.includes(metric) && original !== 'NA' ? getArrow(simulated, original) : '';
                    const valDisplay = simulated + (percentMetrics.includes(metric) && simulated !== 'NA' ? '%' : '');
                    $tr.append(`<td class="text-right" nowrap>${original}${percentMetrics.includes(metric) && original !== 'NA' ? '%' : ''}</td>
                               <td class="text-right cell-manual-sim ${isNeg ? 'text-red' : ''}" nowrap>${valDisplay}<span style="float:right;color:${arrow === 'ðŸ¡…' ? 'green' : arrow === 'ðŸ¡‡' ? 'red' : ''}">${arrow}</span></td>`);
                });
                $tbody.append($tr);
            });

            // LOB rows
            lobs.forEach(lob => {
                metrics.forEach(metric => {
                    const $tr = $('<tr></tr>');
                    if (metric === 'FTE Required') $tr.append(`<td class="sticky-col font-semibold" rowspan="${metrics.length}" nowrap>${lob}</td>`);
                    $tr.append(`<td class="sticky-col" nowrap>${metric}</td>`);

                    weeks.forEach(week => {
                        const d = getData(lob, week);
                        let original = 'NA', simulated = 'NA';
                        if (d) {
                            if (simulatedOnlyMetrics.includes(metric)) original = 'NA';
                            else switch (metric) {
                                case 'FTE Required': original = fmt(d.fteRequired); break;
                                case 'FTE Available': original = fmt(d.fteAvailable); break;
                                case 'Delta': original = fmt(d.delta); break;
                                case 'Staffing %': original = fmt(d.staffingPct); break;
                                case 'Planned Shrinkage %': original = fmt(d.plannedShrinkage, metric); break;
                                case 'Planned Attrition %': original = fmt(d.plannedAttrition ?? 0, metric); break;
                            }

                            simulated = fmt(calcSimulated(d)[metric], metric);
                            const isNeg = !isNaN(simulated) && parseFloat(simulated) < 0;
                            const arrow = !simulatedOnlyMetrics.includes(metric) && original !== 'NA' ? getArrow(simulated, original) : '';
                            const valDisplay = simulated + (percentMetrics.includes(metric) && simulated !== 'NA' ? '%' : '');
                            $tr.append(`<td class="text-right" nowrap>${original}${percentMetrics.includes(metric) && original !== 'NA' ? '%' : ''}</td>
                                       <td class="text-right cell-manual-sim ${isNeg ? 'text-red' : ''}" nowrap>${valDisplay}<span style="float:right;color:${arrow === 'ðŸ¡…' ? 'green' : arrow === 'ðŸ¡‡' ? 'red' : ''}">${arrow}</span></td>`);
                        } else $tr.append(`<td class="text-right" colspan="2" nowrap>NA</td>`);
                    });
                    $tbody.append($tr);
                });
            });
        }



        // --- Manual Simulation Apply ---
        $toolbar.find('.btn-apply').on('click', function () {
            isMLTrend = false;
            const shrinkInput = $toolbar.find('.sim-input-global-shrink').val();
            const attrInput = $toolbar.find('.sim-input-global-attr').val();
            const shrinkVal = shrinkInput !== '' ? parseFloat(shrinkInput) : null;
            const attrVal = attrInput !== '' ? parseFloat(attrInput) : null;

            lobs.forEach(lob => weeks.forEach(week => {
                if (shrinkVal !== null) simulatedValues[`${lob}_${week}_shrink`] = shrinkVal;
                if (attrVal !== null) simulatedValues[`${lob}_${week}_attr`] = attrVal;
            }));

            renderTable();
            $container.find('.cell-manual-sim').addClass('bg-blue-100'); // manual simulation highlight
        });

        // --- Reset ---
        $toolbar.find('.btn-reset').on('click', function () {
            isMLTrend = false;
            $toolbar.find('.sim-input-global-shrink').val(null);
            $toolbar.find('.sim-input-global-attr').val(null);
            initSimulated();
            renderTable();
        });

        // --- ML Trend ---
        $toolbar.find('.btn-ml-trend').on('click', function () {
            isMLTrend = true;
            $toolbar.find('.sim-input-global-shrink').val(null);
            $toolbar.find('.sim-input-global-attr').val(null);
            getMLTrend();
        });

        $toolbar.find('#applyToPlanBtn').on('click', async function () {
            try {
                if (!confirm("This will overwrite matching cells in the plan with current simulated values. Proceed?")) return;

                const changes = buildSimulatedChangeList(); // [{lob, week, metric, value}, ...]
                console.log(changes);

                if (!changes.length) {
                    toastr.warning("No simulated changes to apply.");
                    return;
                }

                const applied = applyChangesToLuckySheet(changes);


            } catch (err) {
                console.error("Apply to Plan error:", err);
                toastr.error("An unexpected error occurred while applying the simulation.");
            }

        });


        function buildSimulatedChangeList() {
            const list = [];
            // We're interested in shrink and attr simulated pairs and optionally staffing
            lobs.forEach(lob => {
                weeks.forEach(week => {
                    const shrinkKey = `${lob}_${week}_shrink`;
                    const attrKey = `${lob}_${week}_attr`;
                    const shrinkVal = (simulatedValues[shrinkKey] != null) ? simulatedValues[shrinkKey] : null;
                    const attrVal = (simulatedValues[attrKey] != null) ? simulatedValues[attrKey] : null;

                    if (shrinkVal !== null) {
                        list.push({ lob, week, metric: 'Simulated Shrinkage %', value: parseFloat(shrinkVal) });
                    }
                    if (attrVal !== null) {
                        list.push({ lob, week, metric: 'Simulated Attrition %', value: parseFloat(attrVal) });
                    }

                    // Optionally include Staffing % if you calculate it per-week in calcSimulated()
                    const d = getData(lob, week);
                    if (d) {
                        const staffing = calcSimulated(d)['Staffing %'];
                        if (staffing != null && !isNaN(staffing)) {
                            list.push({ lob, week, metric: 'Staffing %', value: parseFloat(staffing) });
                        }
                    }
                });
            });

            // remove duplicates (metric entries could be pushed twice), ensure numeric values
            return list.filter(item => item.value !== null && item.value !== undefined && !isNaN(item.value));
        }

        function applyChangesToLuckySheet(changes) {
            const applied = [];

            // Attempt to find lucky sheet file object(s)
            // 1) try global function getluckysheetfile()
            let luckysheetFile = null;
            let luckysheetInstance = null;
            if (typeof window.getluckysheetfile === 'function') {
                luckysheetFile = window.getluckysheetfile();
            } else if (window.luckysheet && typeof window.luckysheet.getluckysheetfile === 'function') {
                luckysheetFile = window.luckysheet.getluckysheetfile();
            } else if (Array.isArray(window.luckysheetfile)) {
                luckysheetFile = window.luckysheetfile;
            } else if (window.luckysheet && window.luckysheet.getAllSheets) {
                // some integrations attach API differently
                luckysheetInstance = window.luckysheet;
                try { luckysheetFile = luckysheetInstance.getAllSheets(); } catch (e) { /* ignore */ }
            }

            if (!luckysheetFile || !Array.isArray(luckysheetFile)) {
                console.warn("LuckySheet: cannot locate workbook via getluckysheetfile / luckysheetfile.");
                toastr.error("Cannot find LuckySheet workbook in this page. Ensure LuckySheet is initialized.");
                return applied;
            }

            // Helper: find a sheet object by LOB (several naming conventions considered)
            function findSheetForLOB(lob) {
                // First, try exact match by name
                let sheet = luckysheetFile.find(s => (s.name || s.sheetName || s.title) === lob);
                if (sheet) return sheet;

                // Try common suffixes/prefixes: e.g., 'LOB - CardOps', 'CardOps_Lob', etc.
                const lower = lob.toLowerCase();
                sheet = luckysheetFile.find(s => (s.name || s.sheetName || s.title || '').toLowerCase().includes(lower));
                if (sheet) return sheet;

                // Fallback: if you maintain a mapping in window.savedConfigs (preferred), use it
                if (window.savedConfigs && window.savedConfigs[lob] && window.savedConfigs[lob].sheetName) {
                    const mappedName = window.savedConfigs[lob].sheetName;
                    const mapped = luckysheetFile.find(s => (s.name || s.sheetName || s.title) === mappedName);
                    if (mapped) return mapped;
                }

                return null;
            }

            // Helper: map metric name to row index using savedConfigs or headerMappings
            function findRowForMetric_(sheetObj, lob, metricName) {
                // sheetObj.data is usually 2D array of cells in luckySheet internal representation
                // Try to use window.savedConfigs if available: structure should include headerMappings with std metricToHeader
                if (window.savedConfigs && window.savedConfigs[lob] && window.savedConfigs[lob].headerMappings) {
                    const headerMappings = window.savedConfigs[lob].headerMappings;
                    // headerMappings might map standard labels to the actual header text in sheet (e.g. "Planned Shrinkage": "Shr %")
                    // Now find row index by searching first column for that header text
                    const targetLabel = headerMappings[metricName] || headerMappings[metricName.replace('Simulated ', 'Planned ')] || null;
                    if (targetLabel) {
                        const colIndex = (function () {
                            // header column specified in config as A or 1 etc.
                            const cfg = window.savedConfigs[lob];
                            const headerCol = cfg && cfg.headerCol;
                            if (!headerCol) return 0;
                            if (isNaN(headerCol)) return headerCol.toUpperCase().charCodeAt(0) - 65;
                            return parseInt(headerCol) - 1;
                        })();
                        const sheetData = sheetObj.data || sheetObj.rows || sheetObj;
                        for (let r = 0; r < sheetData.length; r++) {
                            try {
                                const cell = sheetData[r][colIndex];
                                const cellText = cell ? (cell.m || cell.v || '').toString().trim() : '';
                                if (cellText === targetLabel || cellText.indexOf(targetLabel) !== -1) return r;
                            } catch (e) { /* ignore */ }
                        }
                    }
                }

                // Fallback: search first 200 rows of first few columns for metric label
                const fallBackLabels = [metricName, metricName.replace('Simulated ', 'Planned '), metricName.replace('%', '').trim()];
                const sData = sheetObj.data || sheetObj.rows || sheetObj;
                for (let r = 0; r < Math.min(200, (sData.length || 0)); r++) {
                    for (let c = 0; c < Math.min(6, (sData[r] ? sData[r].length : 0)); c++) {
                        const cell = sData[r][c];
                        const text = cell ? (cell.m || cell.v || '').toString().trim() : '';
                        if (!text) continue;
                        for (const lbl of fallBackLabels) if (lbl && (text === lbl || text.indexOf(lbl) !== -1)) return r;
                    }
                }

                return null;
            }

            function findRowForMetric(sheetObj, lob, metricName) {
                if (!sheetObj || !window.savedConfigs || !window.savedConfigs[lob]) return null;

                const cfg = window.savedConfigs[lob];
                const headerMappings = cfg.headerMappings || {};
                const sheetData = sheetObj.data || [];

                // Identify planned key for simulated metrics
                let plannedKey = metricName;
                if (metricName.toLowerCase().includes("simulated shrinkage")) {
                    plannedKey = "Planned Shrinkage";
                } else if (metricName.toLowerCase().includes("simulated attrition")) {
                    plannedKey = "Planned Attrition";
                }

                // If mapping exists for plannedKey, use it
                const targetHeaderLabel =
                    headerMappings[plannedKey] ||
                    headerMappings[metricName] || // direct match (for non-simulated metrics)
                    null;

                if (!targetHeaderLabel) {
                    console.warn(`No header mapping found for ${metricName} in ${lob}`);
                    return null;
                }

                // Determine column index for header search
                let headerColIndex = 0;
                if (cfg.headerCol) {
                    if (isNaN(cfg.headerCol))
                        headerColIndex = cfg.headerCol.toUpperCase().charCodeAt(0) - 65; // Aâ†’0, Bâ†’1
                    else headerColIndex = parseInt(cfg.headerCol) - 1;
                }

                // Search the specified column for targetHeaderLabel
                for (let r = 0; r < sheetData.length; r++) {
                    const cell = sheetData[r] && sheetData[r][headerColIndex];
                    const cellText = cell ? (cell.m || cell.v || "").toString().trim() : "";
                    if (!cellText) continue;
                    if (
                        cellText.toLowerCase() === targetHeaderLabel.toLowerCase() ||
                        cellText.toLowerCase().includes(targetHeaderLabel.toLowerCase())
                    ) {
                        return r; // found row
                    }
                }

                console.warn(`Row not found for ${metricName} â†’ ${targetHeaderLabel} in ${lob}`);
                return null;
            }

            // Helper: find column for week date (week header row mapping)
            function findColForWeek(sheetObj, weekStr) {
                // If window.savedConfigs has weekRow set, use it to read week header row
                const sheetNameKey = (sheetObj.name || sheetObj.sheetName || sheetObj.title);
                let weekRowIndex = null;
                if (window.savedConfigs) {
                    // attempt to find matching config by sheet name or LOB
                    const cfgEntry = Object.values(window.savedConfigs).find(cfg => {
                        const target = (cfg.sheetName || cfg.sheet || cfg.sheetName);
                        return target && target === sheetNameKey;
                    });
                    if (cfgEntry && cfgEntry.weekRow) {
                        weekRowIndex = parseInt(cfgEntry.weekRow) - 1; // config is 1-based
                    }
                }
                // fallback: try common week rows (2 or 3 or 4)
                if (weekRowIndex === null) {
                    const possible = [2, 3, 4, 5].map(x => x - 1);
                    for (const rowi of possible) {
                        const headerRow = sheetObj.data && sheetObj.data[rowi];
                        if (!headerRow) continue;
                        for (let c = 0; c < headerRow.length; c++) {
                            const cell = headerRow[c];
                            const text = cell ? (cell.m || cell.v || '').toString().trim() : '';
                            if (!text) continue;
                            // Try to parse both as Date objects or match formatting
                            try {
                                const a = new Date(text);
                                const b = new Date(weekStr);
                                if (!isNaN(a) && !isNaN(b) && a.toDateString() === b.toDateString()) return c;
                                // match dd-MMM-yy style where weekStr may be same format
                                if (text.indexOf(weekStr) !== -1 || weekStr.indexOf(text) !== -1) return c;
                            } catch (e) { }
                        }
                    }
                } else {
                    // use the configured weekRowIndex to search for weekStr
                    const headerRow = sheetObj.data && sheetObj.data[weekRowIndex];
                    if (headerRow) {
                        for (let c = 0; c < headerRow.length; c++) {
                            const cell = headerRow[c];
                            const text = cell ? (cell.m || cell.v || '').toString().trim() : '';
                            if (!text) continue;
                            if (text === weekStr || text.indexOf(weekStr) !== -1) return c;
                            // try Date equality
                            const a = new Date(text);
                            const b = new Date(weekStr);
                            if (!isNaN(a) && !isNaN(b) && a.toDateString() === b.toDateString()) return c;
                        }
                    }
                }

                return null;
            }

            // Helper: actually set value into the sheet object. This modifies the in-memory sheet structure.
            function setSheetCellValue(sheetObj, r, c, value) {
                //if (!sheetObj) return false;
                //// Ensure row exists
                //if (!sheetObj.data) sheetObj.data = sheetObj.rows || [];
                //while (sheetObj.data.length <= r) sheetObj.data.push([]);
                //while (sheetObj.data[r].length <= c) sheetObj.data[r].push(null);

                const existing = sheetObj.data[r][c] || {};
                const oldVal = existing.v !== undefined ? existing.v : (existing.m !== undefined ? existing.m : null);
                luckysheet.updateCellValue(sheetObj,r, c, value, true);


                //// Create cell object
                //const newCell = {
                //    v: value,
                //    m: (typeof value === 'number') ? value.toString() : (value === null ? '' : value.toString())
                //};
               

                //// copy style if you want - here we just replace value
                //sheetObj.data[r][c] = Object.assign({}, existing, newCell);
                //luckysheet.setCellValue(r, c, value, sheetObj.index,true);


                return { oldVal, newVal: value };
            }

            // Iterate changes and apply
            for (const ch of changes) {
                const { lob, week, metric, value } = ch;

                const sheet = findSheetForLOB(lob);
                if (!sheet) {
                    console.warn("No sheet found for LOB:", lob);
                    continue;
                }

                const rowIdx = findRowForMetric(sheet, lob, metric);
                const colIdx = findColForWeek(sheet, week);

                if (rowIdx === null || colIdx === null) {
                    console.warn("Could not map metric/week to sheet cell:", { lob, week, metric, rowIdx, colIdx, sheetName: sheet.name || sheet.sheetName });
                    continue;
                }
                window.luckysheet.setSheetActive(sheet.order);
                const valuePer = value / 100;
                const res = setSheetCellValue(sheet, rowIdx, colIdx, valuePer);
                if (res) {
                    // mark the cell visually by adding style object (if luckySheet supports it)
                    try {
                        // some luckySheet versions use "bg" inside cell.s or cell.bg
                        sheet.data[rowIdx][colIdx].bg = "#DFF0D8"; // light green
                        // or style: sheet.data[rowIdx][colIdx].s = { ... }
                    } catch (e) { /* ignore */ }

                    applied.push({
                        sheetName: sheet.name || sheet.sheetName || sheet.title,
                        row: rowIdx,
                        col: colIdx,
                        oldVal: res.oldVal,
                        newVal: res.newVal,
                        lob, week, metric
                    });
                }
            }

            // After applying in-memory changes, attempt to refresh LuckySheet UI using known APIs
            try {
                if (window.luckysheet && typeof window.luckysheet.refresh === 'function') {
                    window.luckysheet.refresh();
                } else if (typeof window.refreshLuckySheet === 'function') {
                    window.refreshLuckySheet();
                } else if (typeof window.luckysheet_draw === 'function') {
                    // older API
                    window.luckysheet_draw();
                } else {
                    // Last resort: try to reassign global luckysheetfile and call getluckysheetfile setter if exists
                    if (typeof window.setluckysheetfile === 'function') {
                        window.setluckysheetfile(luckysheetFile);
                    }
                }
            } catch (e) {
                console.warn("Could not trigger LuckySheet UI refresh automatically. You may need to refresh the sheet manually.", e);
            }
            alert("done");
            return applied;
        }



        function getMLTrend() {
            const shrinkageChecked = document.getElementById('mlShrinkage').checked;
            const attritionChecked = document.getElementById('mlAttrition').checked;
            if (!shrinkageChecked && !attritionChecked) {
                toastr.error("âš ï¸ Please select ML Shrinkage or ML Attrition â€” one of the options is required to proceed.");
                return;
            }
            const weekFrom = $('#weekFromDropdown input[type=radio]:checked').val();
            const weekTo = $('#weekToDropdown input[type=radio]:checked').val();
            const selectedWeeks = $('.weekCheckbox:checked').map(function () { return this.value; }).get();

            var data = {
                'vertical': $("#verticalName").val(),
                'lobFilter': lobs,
                'weekFrom': weekFrom,
                'WeekTo': weekTo,
                'weeks': selectedWeeks
            };

            $.ajax({
                url: '/resourceplanner/GetMLTrend',
                type: "POST",
                async: true,
                cache: false,
                data: JSON.stringify(data),
                contentType: "application/json",
                dataType: "json",
                success: function (response) {
                    if (response?.data?.length) {
                        // Replace simulated values completely with ML
                        Object.keys(simulatedValues).forEach(k => simulatedValues[k] = 0);
                        response.data.forEach(item => {
                            const lob = item.lob || item.LOB;
                            const weekDate = new Date(item.weekDate || item.WeekDate);
                            const weekStr = weeks.find(w => new Date(w).getTime() === weekDate.getTime());
                            if (!weekStr) return;

                            if (shrinkageChecked)
                            simulatedValues[`${lob}_${weekStr}_shrink`] = parseFloat(item.predictedShrinkage ?? item.PredictedShrinkage ?? 0);

                            if (attritionChecked)
                            simulatedValues[`${lob}_${weekStr}_attr`] = parseFloat(item.predictedAttrition ?? item.PredictedAttrition ?? 0);
                        });

                        renderTable();
                        $container.find('.cell-manual-sim').addClass('bg-green-100'); // ML highlight
                        toastr.success("ML Trend applied successfully.", "Simulation Updated");
                    } else {
                        toastr.warning("No ML prediction data available for selected filters.");
                    }
                },
                error: function (xhr, textStatus, errorThrown) {
                    console.error("Error fetching ML trend:", errorThrown);
                    toastr.error("Error fetching ML trend. Please try again.");
                }
            });
        }

        function getMLWeeks() {
            const weekFrom = $('#weekFromDropdown input[type=radio]:checked').val();
            const weekTo = $('#weekToDropdown input[type=radio]:checked').val();
            var data = {
                'vertical': $("#verticalName").val(),
                'weekFrom': weekFrom,
                'WeekTo': weekTo
            };

            $.ajax({
                url: '/resourceplanner/GetMLWeeks',
                type: "POST",
                async: true,
                cache: false,
                data: JSON.stringify(data),
                contentType: "application/json",
                dataType: "json",
                success: function (response) {
                    if (response?.data?.length) {
                        const weeks = response.data;
                        const weekContainer = document.createDocumentFragment();
                        weekContainer.appendChild(document.createElement('label')).innerHTML = `<label><input type="checkbox" class="weekSelectAll" checked> <b>Select All</b></label><br/>`;
                        weeks.forEach(week => { const label = document.createElement('label'); label.innerHTML = `<input type="checkbox" class="weekCheckbox" value="${week}" checked> ${week}`; weekContainer.appendChild(label); weekContainer.appendChild(document.createElement('br')); });
                        $('#weekDropdown').append(weekContainer);
                        updateDropdownLabel('weekDropdown', response.data, 'Select Weeks');
                    } else {
                        toastr.warning("No ML prediction weeks available for selected filters.");
                    }
                },
                error: function (xhr, textStatus, errorThrown) {
                    console.error("Error fetching ML trend:", errorThrown);
                    toastr.error("Error fetching Weeks. Please try again.");
                }
            });
        }


        populateFilters();

        // Select All / Unselect All Logic
        $('#lobDropdown').on('change', '.lobSelectAll', function () {
            const checked = $(this).is(':checked');
            $('.lobCheckbox').prop('checked', checked);
            updateDropdownLabel('lobDropdown', checked ? uniqueLOBs.slice() : [], 'Select LOBs');
        });
        $('#weekFromDropdown').on('change', 'input[type=radio]', function () {
            const selectedWeek = $('#weekFromDropdown input[type=radio]:checked').val();
            updateRadioDropdownLabel('weekFromDropdownBtn', selectedWeek, 'From');
        });
        $('#weekToDropdown').on('change', 'input[type=radio]', function () {
            const selectedWeek = $('#weekToDropdown input[type=radio]:checked').val();
            updateRadioDropdownLabel('weekToDropdownBtn', selectedWeek, 'To');
        });

        $('#applyFilterBtn').on('click', function () {
            $toolbar.find('.sim-input-global-shrink').val(null);
            $toolbar.find('.sim-input-global-attr').val(null);
            const selectedLOBs = $('.lobCheckbox:checked').map(function () { return this.value; }).get();
            const weekFrom = $('#weekFromDropdown input[type=radio]:checked').val();
            const weekTo = $('#weekToDropdown input[type=radio]:checked').val();
            buildTrendTable(selectedLOBs, weekFrom, weekTo);


        });

        function buildTrendTable(selectedLOBs, weekFrom, weekTo) {
             filteredTransformedData = settings.data.filter(item => {
                const weekDate = parseTrendWeekDate(item.week); // convert to Date object

                const fromDate = parseTrendWeekDate(weekFrom);
                const toDate = parseTrendWeekDate(weekTo);

                const isLOBMatch = selectedLOBs.length === 0 || selectedLOBs.includes(item.lob);
                const isWeekInRange = weekDate >= fromDate && weekDate <= toDate;

                return isLOBMatch && isWeekInRange;
             });

             weeks = [...new Set(filteredTransformedData.map(d => d.week))].sort((a, b) => new Date(a) - new Date(b));
             lobs = [...new Set(filteredTransformedData.map(d => d.lob))];

            renderTable();
        }

        function parseTrendWeekDate(weekStr) {
            const [day, month, year] = weekStr.split('-');
            return new Date(`${day} ${month} 20${year}`);
        }


        buildTrendTable(lobs, weeks[0], weeks[weeks.length - 1]);

        // Show Modal
        const trendAnalyticModal = new bootstrap.Modal(document.getElementById('trendAnalyticModal'));
        trendAnalyticModal.show();

    };
}(jQuery));

