update: function () {
    const self = this;

    if (!gr([self.applyRange], h.currentSheetIndex) || h.allowEdit === false) {
        return;
    }

    const sheetIndex = h.currentSheetIndex;
    const sheet = h.luckysheetfile[K(sheetIndex)];
    const data = h.flowdata;

    const cfg = $.extend(true, {}, h.config);
    if (!cfg.merge) cfg.merge = {};
    if (!cfg.borderInfo) cfg.borderInfo = [];

    const borders = Ur();
    const dataVerification = $.extend(true, {}, sheet.dataVerification);

    const dir = self.direction;
    const srcRange = self.copyRange;
    const dstRange = self.applyRange;

    const src = {
        r1: srcRange.row[0],
        r2: srcRange.row[1],
        c1: srcRange.column[0],
        c2: srcRange.column[1]
    };

    const dst = {
        r1: dstRange.row[0],
        r2: dstRange.row[1],
        c1: dstRange.column[0],
        c2: dstRange.column[1]
    };

    const copyData = self.getCopyData(
        data,
        src.r1, src.r2,
        src.c1, src.c2,
        dir
    );

    const rowSpan = src.r2 - src.r1 + 1;
    const colSpan = src.c2 - src.c1 + 1;

    // Track all cells whose formulas were changed
    const dirtyCells = [];

    // ===============================
    // 1️⃣ COPY / SHIFT FORMULAS ONLY
    // ===============================
    for (let r = dst.r1; r <= dst.r2; r++) {
        for (let c = dst.c1; c <= dst.c2; c++) {

            // determine source template position
            const sr = src.r1 + (r - dst.r1) % rowSpan;
            const sc = src.c1 + (c - dst.c1) % colSpan;

            let template;

            if (dir === "left" || dir === "right") {
                template = copyData[r - dst.r1][(c - dst.c1) % colSpan];
            } else {
                template = copyData[c - dst.c1][(r - dst.r1) % rowSpan];
            }

            if (!template) continue;

            const cell = template;

            if (cell.f != null) {
                cell.f = "=" + p.functionCopy(
                    cell.f,
                    dir,
                    dir === "left" || dir === "right"
                        ? (c - dst.c1) + 1
                        : (r - dst.r1) + 1
                );
                cell.v = null;
                cell.m = null;
            }

            data[r][c] = cell;
            dirtyCells.push({ r, c, index: sheetIndex });

            // borders
            if (borders[sr + "_" + sc]) {
                cfg.borderInfo.push({
                    rangeType: "cell",
                    value: {
                        row_index: r,
                        col_index: c,
                        ...borders[sr + "_" + sc]
                    }
                });
            }

            // data verification
            if (dataVerification[sr + "_" + sc]) {
                dataVerification[r + "_" + c] =
                    dataVerification[sr + "_" + sc];
            }
        }
    }

    // ===============================
    // 2️⃣ SINGLE DEPENDENCY BUILD
    // ===============================
    window.luckysheet_getcelldata_cache = null;
    p.groupValuesRefreshData = [];

    // ONE graph build + topo evaluation
    p.execFunctionGroup(
        null,
        null,
        null,
        sheetIndex,
        data,
        true
    );

    // ===============================
    // 3️⃣ APPLY CALCULATED VALUES
    // ===============================
    if (p.groupValuesRefreshData && p.groupValuesRefreshData.length) {
        for (let i = 0; i < p.groupValuesRefreshData.length; i++) {
            const g = p.groupValuesRefreshData[i];
            const cell = data[g.r][g.c];
            if (!cell) continue;

            cell.v = g.v;
            cell.f = g.f;

            if (g.spe) {
                cell.spl = g.spe.data;
            }

            const V = it(g.v);
            cell.m = V[0].toString();
            cell.ct = V[1];
        }
        p.groupValuesRefreshData.length = 0;
    }

    // ===============================
    // 4️⃣ FINAL UI UPDATE
    // ===============================
    const conditionFormat = $.extend(
        true,
        [],
        sheet.luckysheet_conditionformat_save
    );

    Ye(data, h.luckysheet_select_save, {
        cfg,
        cdformat: conditionFormat,
        dataVerification
    });

    tt();
}
