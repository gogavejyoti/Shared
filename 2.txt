execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;

    const s = this;

    // Initialize dependencies once (same as original)
    if (a == null) a = h.flowdata;

    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    // If an explicit value is provided, store it
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[`${e}_${n}_${l}`] = tmp[0][0];
    }

    // ---------------- Caching Layer ----------------
    if (!s._cache) s._cache = {};
    if (s._cache.sheetIndex !== h.currentSheetIndex || s._cache.flowdata !== h.flowdata) {
        // Rebuild cache only if sheet changed
        const sheetsInfo = Ft() || [];
        const sheetMap = {};
        for (let i = 0; i < sheetsInfo.length; i++) {
            sheetMap[sheetsInfo[i].index] = sheetsInfo[i].data;
        }

        s._cache.allFuncCells = s.getAllFunctionGroup() || [];
        s._cache.sheetsInfo = sheetsInfo;
        s._cache.sheetMap = sheetMap;

        // Update markers
        s._cache.sheetIndex = h.currentSheetIndex;
        s._cache.flowdata = h.flowdata;
    }

    const allFuncCells = s._cache.allFuncCells;
    const sheetMap = s._cache.sheetMap;

    // Build execSet
    const execSet = new Set();
    if (s.execFunctionExist == null) {
        execSet.add(`r${e}c${n}i${l}`);
    } else {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const T = s.execFunctionExist[i];
            execSet.add(`r${T.r}c${T.c}i${T.i}`);
        }
    }

    // Nodes + per-call caches
    const nodes = new Map();
    const rangeToKeysCache = {};

    // Hoist regex for token split
    const formulaSplitRegex = /==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/;

    function keysForRange(R) {
        const cacheKey = `r${R.row[0]}_${R.row[1]}_c${R.column[0]}_${R.column[1]}_i${R.sheetIndex}`;
        if (rangeToKeysCache[cacheKey]) return rangeToKeysCache[cacheKey];
        const list = [];
        for (let rr = R.row[0]; rr <= R.row[1]; rr++) {
            for (let cc = R.column[0]; cc <= R.column[1]; cc++) {
                list.push({
                    key: `r${rr}c${cc}i${R.sheetIndex}`,
                    r: rr,
                    c: cc,
                    sheetIndex: R.sheetIndex
                });
            }
        }
        rangeToKeysCache[cacheKey] = list;
        return list;
    }

    // Build nodes by scanning formulas
    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const nodeKey = `r${T.r}c${T.c}i${T.index}`;
        const R = zl(T.r, T.c, T.index);
        if (!R) continue;

        const upper = R.toUpperCase();
        const needsIsFunctionRange =
            upper.indexOf("INDIRECT(") > -1 ||
            upper.indexOf("OFFSET(") > -1 ||
            upper.indexOf("INDEX(") > -1;

        const formulaRanges = [];

        if (needsIsFunctionRange) {
            this.isFunctionRange(R, null, null, T.index, null, function (ref) {
                const rg = s.getcellrange($.trim(ref), T.index);
                if (rg) formulaRanges.push(rg);
            });
        } else if (!(R.substr(0, 2) === '="' && R.substr(R.length - 1, 1) === '"')) {
            const tokens = R.split(formulaSplitRegex).filter(Boolean);
            for (let ti = 0; ti < tokens.length; ti++) {
                const tk = tokens[ti].trim();
                if (!tk) continue;
                if (tk.length <= 1 && !(s.iscelldata && s.iscelldata(tk))) continue;
                const rg = s.getcellrange(tk, T.index);
                if (rg) formulaRanges.push(rg);
            }
        }

        nodes.set(nodeKey, {
            formulaArray: formulaRanges,
            calc_funcStr: R,
            key: nodeKey,
            r: T.r,
            c: T.c,
            index: T.index,
            parents: new Set(),
            children: new Set(),
            color: "w"
        });
    }

    // Build dependency graph + worklist
    const y = [];
    for (const node of nodes.values()) {
        const ranges = node.formulaArray || [];
        for (let ri = 0; ri < ranges.length; ri++) {
            const rect = ranges[ri];
            const keys = keysForRange(rect);
            for (let ki = 0; ki < keys.length; ki++) {
                const cellInfo = keys[ki];
                const A = cellInfo.key;
                if (nodes.has(A)) {
                    node.children.add(A);
                    nodes.get(A).parents.add(node.key);
                }
                if (!o && execSet.has(A)) y.push(node);
            }
        }
        if (o) y.push(node);
    }

    // Topological-like traversal
    const S = new Set();
    const stack = y.slice();
    const ordered = [];

    while (stack.length > 0) {
        const cur = stack.pop();
        if (!cur || S.has(cur.key)) continue;

        if (cur.color === "b") {
            ordered.push(cur);
            S.add(cur.key);
            continue;
        }

        const parentNodes = [];
        for (const pk of cur.parents) {
            if (nodes.has(pk)) parentNodes.push(nodes.get(pk));
        }

        if (parentNodes.length === 0) {
            ordered.push(cur);
            S.add(cur.key);
        } else {
            cur.color = "b";
            stack.push(cur);
            for (let p = 0; p < parentNodes.length; p++) stack.push(parentNodes[p]);
        }
    }

    ordered.reverse();

    // Evaluate nodes
    window.luckysheet_getcelldata_cache = null;
    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];
        const A = T.calc_funcStr;
        const Rres = s.execfunction(A, T.r, T.c, T.index);

        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: Rres[1],
            f: Rres[2],
            spe: Rres[3],
            index: T.index
        });

        s.execFunctionGlobalData[`${T.r}_${T.c}_${T.index}`] = {
            v: Rres[1],
            f: Rres[2]
        };
    }

    s.execFunctionExist = null;
},
