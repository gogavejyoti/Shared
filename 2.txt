execFunctionGroup: function (e, n, t, l, a, o = !1) {
    // Preserve original early return semantics
    if (o) return;

    const s = this;

    // ---------- Initialize helpers ----------
    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    // ---------- Store explicit value if provided ----------
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // ---------- Gather function cells ----------
    let allFuncCells = [];
    let sheetIndices = null;
    if (e != null && n != null) {
        const formulaOrValue = (window.luckysheet_getcelldata_cache && Object.keys(window.luckysheet_getcelldata_cache).join("+")) || null;
        sheetIndices = s.getAllDependentSheetsFromSheet(l, formulaOrValue);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    // ---------- Build sheetMap ----------
    const sheetsInfo = Ft() || [];
    const sheetMap = {};
    for (let i = 0; i < sheetsInfo.length; i++) {
        sheetMap[sheetsInfo[i].index] = sheetsInfo[i].data;
    }

    // ---------- Build execSet (changed/explicit targets) ----------
    const execSet = {};
    if (s.execFunctionExist == null) {
        execSet["r" + e + "c" + n + "i" + l] = 1;
    } else {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const T = s.execFunctionExist[i];
            execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
        }
    }

    // ---------- Local caches & Helpers ----------
    const _rgCache = new Map();
    function rgCached(txt, sheetIndex) {
        const key = sheetIndex + '|' + (txt || '').trim();
        if (_rgCache.has(key)) return _rgCache.get(key);
        const rect = s.getcellrange((txt || '').trim(), sheetIndex);
        _rgCache.set(key, rect);
        return rect;
    }

    const rangeToKeysCache = {};
    function keysForRange(R, sheetMap) {
        const cacheKey = `r${R.row[0]}_${R.row[1]}_c${R.column[0]}_${R.column[1]}_i${R.sheetIndex}`;
        if (rangeToKeysCache[cacheKey]) return rangeToKeysCache[cacheKey];
        const maxRow = (sheetMap[R.sheetIndex] && sheetMap[R.sheetIndex].length - 1) ?? R.row[1];
        const aRow = R.row[1] > maxRow ? maxRow : R.row[1];
        const list = [];
        for (let rr = R.row[0]; rr <= aRow; rr++) {
            for (let cc = R.column[0]; cc <= R.column[1]; cc++) {
                const k = "r" + rr + "c" + cc + "i" + R.sheetIndex;
                list.push({ key: k, r: rr, c: cc, sheetIndex: R.sheetIndex });
            }
        }
        rangeToKeysCache[cacheKey] = list;
        return list;
    }

    const fmrSplit = /==|!=|<>|<=|>=|[,()=+\-/*%&^><]/;
    function parseCall(name, text) {
        const re = new RegExp(`${name}\\s*\\(`, 'i');
        const m = text.match(re);
        if (!m) return null;
        let i = m.index + m[0].length, depth = 1, cur = '', args = [];
        while (i < text.length && depth > 0) {
            const ch = text[i++];
            if (ch === '(') { depth++; cur += ch; }
            else if (ch === ')') {
                depth--;
                if (depth === 0) { if (cur.trim()) args.push(cur.trim()); break; }
                cur += ch;
            } else if (ch === ',' && depth === 1) {
                args.push(cur.trim()); cur = '';
            } else { cur += ch; }
        }
        return { name, args, start: m.index, end: i };
    }

    function parseIntIfLiteral(x) {
        if (x == null) return null;
        const t = ('' + x).trim();
        if (/^[+-]?\d+$/.test(t)) return parseInt(t, 10);
        return null;
    }

    function isFalseyExact(x) {
        if (x == null) return false;
        const t = ('' + x).trim().toLowerCase();
        return t === '0' || t === 'false';
    }

    // ---------- Collect dependency keys ----------
    function collectRefKeysForNode(formulaStr, T) {
        const depKeys = new Set();
        const selfKey = "r" + T.r + "c" + T.c + "i" + T.index;
        const rectSeen = new Set();
        function rectId(rect) {
            return rect ? `${rect.sheetIndex}|${rect.row[0]}_${rect.row[1]}|${rect.column[0]}_${rect.column[1]}` : '';
        }
        function addRect(rect, excludeSelf = false) {
            if (!rect) return;
            const id = rectId(rect);
            if (rectSeen.has(id)) return;
            rectSeen.add(id);
            const refs = keysForRange(rect, sheetMap) || [];
            for (const r of refs) {
                if (excludeSelf && r.key === selfKey) continue;
                depKeys.add(r.key);
            }
        }

        const calls = {
            HLOOKUP: parseCall('HLOOKUP', formulaStr),
            VLOOKUP: parseCall('VLOOKUP', formulaStr),
            XLOOKUP: parseCall('XLOOKUP', formulaStr),
            INDEX: parseCall('INDEX', formulaStr),
            MATCH: parseCall('MATCH', formulaStr),
            SUMIF: parseCall('SUMIF', formulaStr),
            SUMIFS: parseCall('SUMIFS', formulaStr),
            SUMPRODUCT: parseCall('SUMPRODUCT', formulaStr),
            OFFSET: parseCall('OFFSET', formulaStr),
            INDIRECT: parseCall('INDIRECT', formulaStr),
        };

        if (calls.HLOOKUP && calls.HLOOKUP.args.length >= 3) {
            const [, table_array, row_index_num, range_lookup] = calls.HLOOKUP.args;
            const rect = rgCached(table_array, T.index);
            if (rect) {
                addRect({ row: [rect.row[0], rect.row[0]], column: rect.column, sheetIndex: rect.sheetIndex });
                const ri = parseIntIfLiteral(row_index_num);
                if ((isFalseyExact(range_lookup) || range_lookup == null) && Number.isFinite(ri)) {
                    const retRow = rect.row[0] + (ri - 1);
                    addRect({ row: [retRow, retRow], column: rect.column, sheetIndex: rect.sheetIndex });
                    return depKeys;
                }
            }
        }
        // ... (VLOOKUP, INDEX, etc. - keeping your existing logic here for brevity)
        
        const tokens = formulaStr.split(fmrSplit).filter(Boolean);
        for (let ti = 0; ti < tokens.length; ti++) {
            const tk = tokens[ti].trim();
            if (!tk || tk.length <= 1) continue;
            const rg = rgCached(tk, T.index);
            if (rg) addRect(rg);
        }
        return depKeys;
    }

    // ---------- Build nodes & reverse index ----------
    const nodes = {};
    const refToChildren = {};
    const volatileNodesBySheet = {};
    function addChildEdge(refKey, nodeKey) {
        if (!refToChildren[refKey]) refToChildren[refKey] = new Set();
        refToChildren[refKey].add(nodeKey);
    }

    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const nodeKey = "r" + T.r + "c" + T.c + "i" + T.index;
        const R = zl(T.r, T.c, T.index) || ve.getSheetByIndex(T.index)?.celldata?.find(x => x?.r === T.r && x?.c === T.c)?.v?.f;
        if (!R) continue;

        const node = nodes[nodeKey] = {
            key: nodeKey, r: T.r, c: T.c, index: T.index,
            calc_funcStr: R, parents: {}, children: {}, refKeys: new Set(),
            cellAddress: s.getExcelAddr(T.r, T.c)
        };

        const refKeys = collectRefKeysForNode(R, T);
        for (const k of refKeys) {
            node.refKeys.add(k);
            addChildEdge(k, nodeKey);
        }

        const indMeta = parseCall('INDIRECT', R);
        if (indMeta && indMeta.args.length >= 1 && !/^".*"$/.test((indMeta.args[0] || '').trim())) {
            if (!volatileNodesBySheet[T.index]) volatileNodesBySheet[T.index] = new Set();
            volatileNodesBySheet[T.index].add(nodeKey);
        }
    }

    for (const nodeKey in nodes) {
        const node = nodes[nodeKey];
        for (const refKey of node.refKeys) {
            if (nodes[refKey]) {
                node.parents[refKey] = 1;
                nodes[refKey].children[nodeKey] = 1;
            }
        }
    }

    // ---------- Build IMPACTED set (Potential Scope) ----------
    const impacted = new Set();
    const queue = [];
    const execKeys = Object.keys(execSet);
    for (let i = 0; i < execKeys.length; i++) {
        const changedKey = execKeys[i];
        const directChildren = refToChildren[changedKey];
        if (directChildren) {
            for (const childKey of directChildren) {
                if (!impacted.has(childKey)) { impacted.add(childKey); queue.push(childKey); }
            }
        }
        if (nodes[changedKey] && !impacted.has(changedKey)) { impacted.add(changedKey); queue.push(changedKey); }
        const si = changedKey.split('i')[1];
        if (volatileNodesBySheet[si]) {
            for (const vk of volatileNodesBySheet[si]) {
                if (!impacted.has(vk)) { impacted.add(vk); queue.push(vk); }
            }
        }
    }
    while (queue.length > 0) {
        const k = queue.pop();
        const nnode = nodes[k];
        if (!nnode) continue;
        for (const ck in nnode.children) {
            if (!impacted.has(ck)) { impacted.add(ck); queue.push(ck); }
        }
    }
    if (impacted.size === 0) { for (const k in nodes) impacted.add(k); }

    // ---------- Topological sort ----------
    const ordered = [];
    const processed = {};
    const color = {};
    let cycleDetected = false;
    function dfsVisit(k) {
        if (processed[k]) return;
        const curColor = color[k] || 'w';
        if (curColor === 'g') { cycleDetected = true; return; }
        color[k] = 'g';
        const parents = Object.keys(nodes[k]?.parents || {}).filter(pk => nodes[pk] && impacted.has(pk)).sort();
        for (let i = 0; i < parents.length; i++) dfsVisit(parents[i]);
        color[k] = 'b';
        processed[k] = 1;
        ordered.push(nodes[k]);
    }
    for (const k of impacted) { if (nodes[k] && !processed[k]) dfsVisit(k); }

    // ---------- OPTIMIZED EVALUATION (True Change Tracking) ----------
    // actualChanges tracks keys whose values HAVE changed during this specific execution
    const actualChanges = new Set(Object.keys(execSet));

    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];
        const nodeKey = T.key;

        // Pruning: Run only if it's a trigger OR a parent value actually changed
        let shouldRun = actualChanges.has(nodeKey);
        if (!shouldRun) {
            for (const pKey in T.parents) {
                if (actualChanges.has(pKey)) {
                    shouldRun = true;
                    break;
                }
            }
        }

        if (!shouldRun) continue; // Skip execution overhead

        window.luckysheet_getcelldata_cache = null;
        const oldValue = sheetMap[T.index]?.[T.r]?.[T.c]?.v;
        const Rres = s.execfunction(T.calc_funcStr, T.r, T.c, T.index);
        const newValue = Rres[1];

        // Only propagate if the result is different
        if (oldValue != newValue) {
            actualChanges.add(nodeKey);
            s.execFunctionGlobalData[`${T.r}_${T.c}_${T.index}`] = { v: newValue, f: Rres[2] };
            s.groupValuesRefreshData.push({
                r: T.r, c: T.c, v: newValue, f: Rres[2],
                spe: Rres[3], index: T.index
            });
        }
    }

    s.execFunctionExist = null;
}
