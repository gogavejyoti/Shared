function getHeaderTopOffset($table, rowIndex) {
    let offset = 0;
    for (let i = 0; i < rowIndex; i++) {
        offset += $table.find('thead tr').eq(i).outerHeight();
    }
    return offset;
}

function setupStickyColumns($table, $wrapper) {
    // compute widths of first & second columns from header cells
    const $firstTh = $table.find('thead tr').first().find('th').first();
    const $secondTh = $table.find('thead tr').first().find('th').eq(1);

    // fallback widths if not measured
    const firstWidth = $firstTh.length ? $firstTh.outerWidth() : 140;
    const secondWidth = $secondTh.length ? $secondTh.outerWidth() : 150;

    // Apply left offsets and min-widths for sticky-1 and sticky-2 in both header and body cells
    $table.find('.sticky-1').each(function () {
        $(this).css({ left: 0, 'min-width': firstWidth + 'px' });
    });
    $table.find('.sticky-2').each(function () {
        $(this).css({ left: firstWidth + 'px', 'min-width': secondWidth + 'px' });
    });

    // Also ensure header th's which are sticky get same left values
    $table.find('thead th').each(function (idx) {
        if (idx === 0) $(this).css({ left: 0 });
        if (idx === 1) $(this).css({ left: firstWidth + 'px' });
    });

    // Freeze all header rows with cumulative top offset and reversed z-index order
    const totalHeaderRows = $table.find('thead tr').length;

    $table.find('thead tr').each(function(index) {
        const topOffset = getHeaderTopOffset($table, index);

        $(this).find('th').css({
            position: 'sticky',
            top: topOffset + 'px',
            'z-index': 1000 - index,  // higher z-index for first row
            background: '#f5f5f5',
        });
    });

    // Recompute on resize (debounced)
    clearTimeout(window.__vcResizeTimer);
    window.__vcResizeTimer = setTimeout(function () {
        const newFirstW = $firstTh.length ? $firstTh.outerWidth() : firstWidth;
        const newSecondW = $secondTh.length ? $secondTh.outerWidth() : secondWidth;

        $table.find('.sticky-1').css({ 'min-width': newFirstW + 'px' });
        $table.find('.sticky-2').css({ 'min-width': newSecondW + 'px', left: newFirstW + 'px' });

        $table.find('thead th').each(function (idx) {
            if (idx === 0) $(this).css({ left: 0 });
            if (idx === 1) $(this).css({ left: newFirstW + 'px' });
        });

        // Reapply sticky header top offsets on resize with reversed z-index
        $table.find('thead tr').each(function(index) {
            const topOffset = getHeaderTopOffset($table, index);

            $(this).find('th').css({
                top: topOffset + 'px',
                'z-index': 1000 - index,
            });
        });
    }, 100);
}
