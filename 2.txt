function getLookupMatchedRange(type, keyCell, tableRange, sheetIndex) {
    const sheetData = sheetMap[sheetIndex];
    if (!sheetData) return null;

    const keyVal = nr(keyCell.row, keyCell.column, sheetIndex)?.v;
    if (keyVal == null) return null;

    if (type === "VLOOKUP") {
        const col = tableRange.column[0];
        for (let r = tableRange.row[0]; r <= tableRange.row[1]; r++) {
            const v = nr(r, col, sheetIndex)?.v;
            if (v === keyVal) {
                return {
                    row: [r, r],
                    column: tableRange.column,
                    sheetIndex
                };
            }
        }
    }

    if (type === "HLOOKUP") {
        const row = tableRange.row[0];
        for (let c = tableRange.column[0]; c <= tableRange.column[1]; c++) {
            const v = nr(row, c, sheetIndex)?.v;
            if (v === keyVal) {
                return {
                    row: tableRange.row,
                    column: [c, c],
                    sheetIndex
                };
            }
        }
    }

    return null;
}


if (!(R.substr(0, 2) === '="' && R.substr(R.length - 1, 1) === '"')) {

    const upper = R.toUpperCase();

    // ---------------------------
    // 1️⃣ Handle LOOKUP first
    // ---------------------------
    if (upper.includes("VLOOKUP(") || upper.includes("HLOOKUP(")) {

        const isV = upper.includes("VLOOKUP(");
        const m = R.match(/(VLOOKUP|HLOOKUP)\s*\(([^)]+)\)/i);

        if (m) {
            const args = m[2].split(",");
            if (args.length >= 2) {

                const keyRg = s.getcellrange(args[0].trim(), T.index);
                const tableRg = s.getcellrange(args[1].trim(), T.index);

                if (keyRg && tableRg) {
                    const matched = getLookupMatchedRange(
                        isV ? "VLOOKUP" : "HLOOKUP",
                        { row: keyRg.row[0], column: keyRg.column[0] },
                        tableRg,
                        tableRg.sheetIndex
                    );

                    if (matched) {
                        formulaRanges.push(matched);
                    }
                }
            }
        }
    }

    // ---------------------------
    // 2️⃣ Normal static references
    // ---------------------------
    const tokens = R.split(fmrSplit).filter(Boolean);
    for (let ti = 0; ti < tokens.length; ti++) {
        let tk = tokens[ti].trim();
        if (!tk) continue;
        if (tk.length <= 1 && !(s.iscelldata && s.iscelldata(tk))) continue;

        const rg = s.getcellrange(tk, T.index);
        if (rg) formulaRanges.push(rg);
    }
}
