execFunctionGroup: function (e, n, t, l, a, o = false) {
    if (o) return;

    const s = this;

    // defaults
    if (a == null) a = h.flowdata;
    if (l == null) l = h.currentSheetIndex;

    // init helpers (unchanged)
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    // store explicit value if provided
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // DO NOT shift references during recalculation
    if (!o && typeof _shiftCrossSheetReference === "function") {
        _shiftCrossSheetReference({
            type: "recalc",
            sheetIndex: l
        });
    }

    // get all function cells
    let allFuncCells = [];
    if (e != null && n != null) {
        const formulaOrValue =
            (window.luckysheet_getcelldata_cache &&
                Object.keys(window.luckysheet_getcelldata_cache).join("+")) || null;
        const sheetIndices = s.getAllDependentSheetsFromSheet(l, formulaOrValue);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    // build node map
    const nodes = {};
    const sheetsInfo = Ft() || [];

    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const key = "r" + T.r + "c" + T.c + "i" + T.index;
        const formula = zl(T.r, T.c, T.index);
        if (!formula) continue;

        const ranges = [];
        s.isFunctionRange(formula, null, null, T.index, null, function (ref) {
            const rg = s.getcellrange(ref, T.index);
            if (rg) ranges.push(rg);
        });

        nodes[key] = {
            key,
            r: T.r,
            c: T.c,
            index: T.index,
            formula: formula,
            ranges,
            parents: {},
            children: {},
            color: "w"
        };
    }

    // range â†’ cell key cache
    const rangeCache = {};
    function keysForRange(R) {
        const ck =
            R.sheetIndex +
            "_" +
            R.row[0] +
            "_" +
            R.row[1] +
            "_" +
            R.column[0] +
            "_" +
            R.column[1];
        if (rangeCache[ck]) return rangeCache[ck];
        const list = [];
        for (let r = R.row[0]; r <= R.row[1]; r++) {
            for (let c = R.column[0]; c <= R.column[1]; c++) {
                list.push("r" + r + "c" + c + "i" + R.sheetIndex);
            }
        }
        rangeCache[ck] = list;
        return list;
    }

    // build dependency graph
    const startNodes = [];
    for (const k in nodes) {
        const node = nodes[k];
        for (let i = 0; i < node.ranges.length; i++) {
            const keys = keysForRange(node.ranges[i]);
            for (let j = 0; j < keys.length; j++) {
                const dep = keys[j];
                if (nodes[dep]) {
                    node.parents[dep] = 1;
                    nodes[dep].children[node.key] = 1;
                }
            }
        }
        startNodes.push(node);
    }

    // topological sort
    const visited = {};
    const ordered = [];
    const stack = startNodes.slice();

    while (stack.length) {
        const cur = stack.pop();
        if (!cur || visited[cur.key]) continue;

        if (cur.color === "b") {
            visited[cur.key] = 1;
            ordered.push(cur);
            continue;
        }

        cur.color = "b";
        stack.push(cur);

        for (const pk in cur.parents) {
            if (nodes[pk] && !visited[pk]) {
                stack.push(nodes[pk]);
            }
        }
    }

    ordered.reverse();

    /* ===============================
       ðŸ”´ CRITICAL FIXES START HERE
       =============================== */

    // HARD reset caches ONCE
    window.luckysheet_getcelldata_cache = {};
    s.execFunctionGlobalData = {};

    // PASS 1 â€” populate values
    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];
        window.luckysheet_getcelldata_cache = null;

        const res = s.execfunction(T.formula, T.r, T.c, T.index);

        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: res[1],
            f: res[2],
            spe: res[3],
            index: T.index
        });

        s.execFunctionGlobalData[T.r + "_" + T.c + "_" + T.index] = {
            v: res[1],
            f: res[2]
        };
    }

    // PASS 2 â€” stabilize dependent reads (Excel behavior)
    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];
        window.luckysheet_getcelldata_cache = null;

        const res = s.execfunction(T.formula, T.r, T.c, T.index);

        s.execFunctionGlobalData[T.r + "_" + T.c + "_" + T.index] = {
            v: res[1],
            f: res[2]
        };
    }

    s.execFunctionExist = null;
}
