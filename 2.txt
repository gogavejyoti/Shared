execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;

    const s = this;

    // Init helpers
    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    // Store explicit value
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // Shift cross-sheet refs
    if (typeof _shiftCrossSheetReference === "function") {
        _shiftCrossSheetReference({ type: "recalc", sheetIndex: l });
    }

    // Get function cells
    let allFuncCells = [];
    let sheetIndices = null;

    if (e != null && n != null) {
        const key =
            (window.luckysheet_getcelldata_cache &&
                Object.keys(window.luckysheet_getcelldata_cache).join("+")) ||
            null;
        sheetIndices = s.getAllDependentSheetsFromSheet(l, key);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    // Exec set (cells directly changed)
    const execSet = {};
    if (s.execFunctionExist == null) {
        execSet["r" + e + "c" + n + "i" + l] = 1;
    } else {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const T = s.execFunctionExist[i];
            execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
        }
    }

    // -------------------------
    // BUILD DEPENDENCY GRAPH
    // -------------------------
    const nodes = {};
    const rangeCache = {};

    function keysForRange(R) {
        const k =
            "r" +
            R.row[0] +
            "_" +
            R.row[1] +
            "_c" +
            R.column[0] +
            "_" +
            R.column[1] +
            "_i" +
            R.sheetIndex;
        if (rangeCache[k]) return rangeCache[k];

        const out = [];
        for (let r = R.row[0]; r <= R.row[1]; r++) {
            for (let c = R.column[0]; c <= R.column[1]; c++) {
                out.push({
                    key: "r" + r + "c" + c + "i" + R.sheetIndex,
                    r,
                    c,
                    sheetIndex: R.sheetIndex
                });
            }
        }
        rangeCache[k] = out;
        return out;
    }

    // Create nodes
    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const key = "r" + T.r + "c" + T.c + "i" + T.index;
        const F = zl(T.r, T.c, T.index);
        if (!F) continue;

        const ranges = [];
        const upper = F.toUpperCase();
        const fnRange =
            upper.includes("INDIRECT(") ||
            upper.includes("OFFSET(") ||
            upper.includes("INDEX(");

        if (fnRange) {
            s.isFunctionRange(F, null, null, T.index, null, function (ref) {
                const rg = s.getcellrange($.trim(ref), T.index);
                if (rg) ranges.push(rg);
            });
        } else {
            const tokens = F.split(/==|!=|<>|<=|>=|[,()=+\-/*%&^><]/).filter(Boolean);
            tokens.forEach(tk => {
                const rg = s.getcellrange($.trim(tk), T.index);
                if (rg) ranges.push(rg);
            });
        }

        nodes[key] = {
            key,
            r: T.r,
            c: T.c,
            index: T.index,
            calc_funcStr: F,
            parents: {},
            chidren: {},
            ranges
        };
    }

    // Link parents/children
    Object.values(nodes).forEach(node => {
        node.ranges.forEach(rg => {
            keysForRange(rg).forEach(ci => {
                if (nodes[ci.key]) {
                    node.parents[ci.key] = 1;
                    nodes[ci.key].chidren[node.key] = 1;
                }
            });
        });
    });

    // -------------------------
    // BUILD FULL AFFECTED SET
    // -------------------------
    const affected = {};
    Object.keys(execSet).forEach(k => (affected[k] = 1));

    function addParents(k) {
        const n = nodes[k];
        if (!n) return;
        Object.keys(n.parents).forEach(pk => {
            if (!affected[pk]) {
                affected[pk] = 1;
                addParents(pk);
            }
        });
    }

    function addChildren(k) {
        const n = nodes[k];
        if (!n) return;
        Object.keys(n.chidren).forEach(ck => {
            if (!affected[ck]) {
                affected[ck] = 1;
                addChildren(ck);
            }
        });
    }

    Object.keys(execSet).forEach(k => {
        addParents(k);
        addChildren(k);
    });

    // -------------------------
    // TOPOLOGICAL SORT (STRICT)
    // -------------------------
    const visited = {};
    const visiting = {};
    const ordered = [];

    function dfs(node) {
        if (visited[node.key]) return;
        if (visiting[node.key]) {
            throw new Error("Circular dependency at " + node.key);
        }
        visiting[node.key] = true;

        Object.keys(node.parents).forEach(pk => {
            if (affected[pk] && nodes[pk]) dfs(nodes[pk]);
        });

        visiting[node.key] = false;
        visited[node.key] = true;
        ordered.push(node);
    }

    Object.keys(affected).forEach(k => {
        if (nodes[k]) dfs(nodes[k]);
    });

    // -------------------------
    // EXECUTE IN CORRECT ORDER
    // -------------------------
    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];
        window.luckysheet_getcelldata_cache = null;

        const R = s.execfunction(
            T.calc_funcStr,
            T.r,
            T.c,
            T.index
        );

        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: R[1],
            f: R[2],
            spe: R[3],
            index: T.index
        });

        s.execFunctionGlobalData[T.r + "_" + T.c + "_" + T.index] = {
            v: R[1],
            f: R[2]
        };
    }

    s.execFunctionExist = null;
}
