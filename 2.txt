changeSheet: function (e, n, t, l) {
    if (de() || e === h.currentSheetIndex) return;
    const a = this, prevIndex = h.currentSheetIndex;
    const o = h.luckysheetfile[a.getSheetIndex(e)];

    // Clear multi-range selection if needed
    if (ne.allowUpdate) {
        $("#luckysheet-cell-main #luckysheet-multipleRange-show").empty();
        ne.multipleIndex = 0;
    }

    // Fire hooks
    if (t) Je.createHookFunction("sheetCreateAfter", { sheet: o });
    if (l) Je.createHookFunction("sheetCopyAfter", { sheet: o });
    Je.createHookFunction("sheetActivate", e, n, t);

    // Show/hide filters
    $("#luckysheet-filter-selected-sheet" + prevIndex + ", #luckysheet-filter-options-sheet" + prevIndex).hide();
    $("#luckysheet-filter-selected-sheet" + e + ", #luckysheet-filter-options-sheet" + e).show();

    window.luckysheetCurrentIndex = e;
    a.storeSheetParamALL();
    a.setCurSheet(e);

    // Pivot table handling
    if (o.isPivotTable) {
        h.luckysheetcurrentisPivotTable = true;
        if (!n) Be.changePivotTable(e);
    } else {
        h.luckysheetcurrentisPivotTable = false;
        $("#luckysheet-modal-dialog-slider-pivot").hide();
        $t(false);
        this.refreshAllPivotTable(prevIndex);
    }

    // Load or rebuild sheet data
    const loadSheetData = () => {
        if (o.data && o.load === "1") return Promise.resolve();
        return new Promise((resolve) => {
            if (!ne.loadSheetUrl || h.luckysheetcurrentisPivotTable || t) {
                o.data = a.buildGridData(o);
                o.load = "1";
                resolve();
            } else {
                $("#luckysheet-grid-window-1").append(Fr());
                const indices = a.checkLoadSheetIndex(o);
                $.post(ne.loadSheetUrl, { gridKey: ne.gridKey, index: indices.join(",") }, function (f) {
                    const m = new Function("return " + f)();
                    o.celldata = m[e.toString()];
                    o.data = a.buildGridData(o);
                    o.load = "1";

                    // preload other sheets
                    for (let y in m) {
                        if (y == e) continue;
                        const v = h.luckysheetfile[a.getSheetIndex(y)];
                        if (!v.load || v.load === "0") {
                            v.celldata = m[y];
                            v.data = a.buildGridData(v);
                            v.load = "1";
                        }
                    }
                    setTimeout(() => h.loadingObj.close(), 500);
                    resolve();
                });
            }
        });
    };

    loadSheetData().then(() => {
        a.mergeCalculation(e);
        a.setSheetParam(true);
        a.showSheet();

        setTimeout(() => {
            // optimized recalculation with global dependency graph
            p.execFunctionGroupForce(!0);
            He();
            ne.saveParam("shs", null, h.currentSheetIndex);
        }, 1);
    });

    // Restore UI & selection
    $("#luckysheet-cell-main .luckysheet-datavisual-selection-set").hide();
    $("#luckysheet-datavisual-selection-set-" + e).show();
    p.hideButton();
    Ic(e);
    W.initialFreezen(e);
    a.restoreselect();
    rc(o);
},

execFunctionGroupForce: function (e) {
    // Forces full recalculation but leverages cached dependency graph
    this.execFunctionGroup(void 0, void 0, void 0, void 0, void 0, e === true);
},

execFunctionGroup: function (e, n, t, l, a, o = !1) {
    const s = this;
    if (!s._formulaGraph) s._formulaGraph = {};
    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (!s.groupValuesRefreshData) s.groupValuesRefreshData = [];
    if (!s.execFunctionExist) s.execFunctionExist = null;

    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (l == null) l = h.currentSheetIndex;
    if (a == null) a = h.flowdata;

    // inject value if provided
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // build function nodes with cached dependency graph
    if (!s._formulaGraph.globalGraph || o) {
        const allFuncCells = s.getAllFunctionGroup() || [];
        const nodes = {}, rangeCache = {};

        function keysForRange(R) {
            const key = `r${R.row[0]}_${R.row[1]}_c${R.column[0]}_${R.column[1]}_i${R.sheetIndex}`;
            if (rangeCache[key]) return rangeCache[key];
            const arr = [];
            for (let rr = R.row[0]; rr <= R.row[1]; rr++)
                for (let cc = R.column[0]; cc <= R.column[1]; cc++)
                    arr.push({ key: `r${rr}c${cc}i${R.sheetIndex}`, r: rr, c: cc, sheetIndex: R.sheetIndex });
            rangeCache[key] = arr;
            return arr;
        }

        allFuncCells.forEach(T => {
            const nodeKey = `r${T.r}c${T.c}i${T.index}`;
            const R = zl(T.r, T.c, T.index);
            if (!R) return;

            const upper = R.toUpperCase();
            const formulaRanges = [];
            if (upper.includes("INDIRECT(") || upper.includes("OFFSET(") || upper.includes("INDEX(")) {
                this.isFunctionRange(R, null, null, T.index, null, ref => {
                    const rg = s.getcellrange($.trim(ref), T.index);
                    if (rg) formulaRanges.push(rg);
                });
            } else if (!(R.startsWith('="') && R.endsWith('"'))) {
                const tokens = R.split(/==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/).filter(Boolean);
                tokens.forEach(tk => {
                    const rg = s.getcellrange($.trim(tk), T.index);
                    if (rg) formulaRanges.push(rg);
                });
            }

            nodes[nodeKey] = { formulaArray: formulaRanges, calc_funcStr: R, key: nodeKey, r: T.r, c: T.c, index: T.index, parents: {}, chidren: {}, color: "w" };
        });

        // build dependency graph
        const y = [], execSet = {};
        if (s.execFunctionExist == null) {
            execSet[`r${e}c${n}i${l}`] = 1;
        } else s.execFunctionExist.forEach(T => execSet[`r${T.r}c${T.c}i${T.i}`] = 1);

        Object.values(nodes).forEach(node => {
            (node.formulaArray || []).forEach(rect => {
                keysForRange(rect).forEach(cellInfo => {
                    const k = cellInfo.key;
                    if (k in nodes) {
                        node.chidren[k] = 1;
                        nodes[k].parents[node.key] = 1;
                    }
                    if (!o && execSet[k]) y.push(node);
                });
            });
            if (o) y.push(node);
        });

        // topological order
        const S = {}, stack = y.slice(), ordered = [];
        while (stack.length) {
            const cur = stack.pop();
            if (!cur || S[cur.key]) continue;
            if (cur.color === "b") { ordered.push(cur); S[cur.key] = 1; continue; }
            const parentNodes = Object.keys(cur.parents || {}).map(pk => nodes[pk]).filter(Boolean);
            if (parentNodes.length === 0) { ordered.push(cur); S[cur.key] = 1; } 
            else { cur.color = "b"; stack.push(cur); parentNodes.forEach(p => stack.push(p)); }
        }
        ordered.reverse();

        s._formulaGraph.globalGraph = { nodes, ordered };
    }

    // execute formulas
    s._formulaGraph.globalGraph.ordered.forEach(T => {
        window.luckysheet_getcelldata_cache = null;
        const res = s.execfunction(T.calc_funcStr, T.r, T.c, T.index);
        s.groupValuesRefreshData.push({ r: T.r, c: T.c, v: res[1], f: res[2], spe: res[3], index: T.index });
        s.execFunctionGlobalData[T.r + "_" + T.c + "_" + T.index] = { v: res[1], f: res[2] };
    });

    s.execFunctionExist = null;
}
