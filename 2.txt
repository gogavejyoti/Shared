execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;

    const s = this;

    // Early globals setup (unchanged)
    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        Object.assign(window, {
            luckysheet_compareWith: ja,
            luckysheet_getarraydata: wc,
            luckysheet_getcelldata: nr,
            luckysheet_parseData: Ua,
            luckysheet_getValue: qn,
            luckysheet_indirect_check: xc,
            luckysheet_indirect_check_return: _c,
            luckysheet_offset_check: Cc,
            luckysheet_calcADPMM: _t,
            luckysheet_getSpecialReference: Tc,
        });
    }
    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};

    if (l == null) l = h.currentSheetIndex;

    // ── Explicit value injection ────────────────────────────────────────
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[`${e}_${n}_${l}`] = tmp[0][0];
    }

    // ── Determine which sheets & functions to consider ──────────────────
    let allFuncCells = [];
    let sheetIndices = null;

    if (e != null && n != null) {
        sheetIndices = s.getAllDependentSheetsFromSheet(l, null);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else if (s.execFunctionExist?.length > 0) {
        sheetIndices = s.getAllDependentSheetsFromSheet(s.execFunctionExist[0].i, null);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    if (allFuncCells.length === 0) {
        s.execFunctionExist = null;
        return;
    }

    // ── Sheet data lookup map (once) ────────────────────────────────────
    const sheetsInfo = Ft() || [];
    const sheetMap = {};
    for (const sh of sheetsInfo) {
        sheetMap[sh.index] = sh.data;
    }

    // ── Changed / explicit cells ────────────────────────────────────────
    const changedKeys = new Set();
    if (s.execFunctionExist?.length > 0) {
        for (const cell of s.execFunctionExist) {
            changedKeys.add(`r${cell.r}c${cell.c}i${cell.i}`);
        }
    } else if (e != null && n != null) {
        changedKeys.add(`r${e}c${n}i${l}`);
    }

    // ── Single shared range cache across all formulas ───────────────────
    const rangeCache = new Map(); // "sheet|r0_r1_c0_c1" → rect or null

    function getRange(text, sheetIdx) {
        if (!text) return null;
        const key = `${sheetIdx}|${text.trim()}`;
        if (rangeCache.has(key)) return rangeCache.get(key);

        const rect = s.getcellrange(text.trim(), sheetIdx);
        rangeCache.set(key, rect);
        return rect;
    }

    // ── Build graph nodes + dependencies ────────────────────────────────
    const nodesByKey   = {};           // key → node
    const dependents   = {};           // refKey → Set<dependent node keys>
    const volatiles    = {};           // sheetIndex → Set<node keys>

    for (const cell of allFuncCells) {
        const key = `r${cell.r}c${cell.c}i${cell.index}`;
        const formula = zl(cell.r, cell.c, cell.index) ||
                        ve.getSheetByIndex(cell.index)?.celldata
                            ?.find(x => x?.r === cell.r && x?.c === cell.c)
                            ?.v?.f;

        if (!formula) continue;

        const node = {
            key,
            r: cell.r,
            c: cell.c,
            index: cell.index,
            formula,
            parents:  new Set(),
            children: new Set(),
            color:    'w'
        };
        nodesByKey[key] = node;

        // Volatility check (fast path – only INDIRECT)
        let isVolatile = false;
        const upper = formula.toUpperCase();
        if (upper.includes('INDIRECT(')) {
            const start = upper.indexOf('INDIRECT(');
            const argStart = formula.indexOf('(', start) + 1;
            let depth = 1, i = argStart;
            while (i < formula.length && depth > 0) {
                if (formula[i] === '(') depth++;
                else if (formula[i] === ')') depth--;
                i++;
            }
            const arg = formula.slice(argStart, i - 1).trim();
            isVolatile = !arg.startsWith('"') || !arg.endsWith('"');
        }
        if (isVolatile) {
            if (!volatiles[cell.index]) volatiles[cell.index] = new Set();
            volatiles[cell.index].add(key);
        }

        // ── Dependency collection ───────────────────────────────────────
        const deps = new Set();

        // Fast common-case patterns (most spreadsheets are dominated by these)
        if (upper.startsWith('=VLOOKUP(') || upper.startsWith('=HLOOKUP(')) {
            const parts = upper.split(/[(,)]/).map(p => p.trim());
            if (parts.length >= 5) {
                const table = parts[2];
                const idxNum = parseInt(parts[3], 10);
                const rangeLk = parts[4] !== 'FALSE' && parts[4] !== '0';
                const rect = getRange(table, cell.index);
                if (rect) {
                    if (upper[1] === 'V') {
                        deps.add(`r${rect.row[0]}_${rect.row[1]}_c${rect.column[0]}_c${rect.column[0]}_i${rect.sheetIndex}`);
                        if (!rangeLk && Number.isFinite(idxNum)) {
                            const retCol = rect.column[0] + idxNum - 1;
                            deps.add(`r${rect.row[0]}_${rect.row[1]}_c${retCol}_c${retCol}_i${rect.sheetIndex}`);
                            node.deps = deps;
                            continue;
                        }
                    } else { /* HLOOKUP */ }
                }
            }
        }

        // Generic fallback — still needed, but much less frequent now
        // Avoid split+filter+trim loop → use simpler regex match
        const refLike = /[A-Z]+[0-9]+(?::[A-Z]+[0-9]+)?/g;
        let m;
        while ((m = refLike.exec(formula)) !== null) {
            const range = getRange(m[0], cell.index);
            if (range) {
                const r0 = range.row[0], r1 = range.row[1];
                const c0 = range.column[0], c1 = range.column[1];
                const si  = range.sheetIndex;
                for (let rr = r0; rr <= r1; rr++) {
                    for (let cc = c0; cc <= c1; cc++) {
                        deps.add(`r${rr}c${cc}i${si}`);
                    }
                }
            }
        }

        // Attach dependencies
        for (const ref of deps) {
            if (!dependents[ref]) dependents[ref] = new Set();
            dependents[ref].add(key);
            node.parents.add(ref);
        }
    }

    // ── Compute impacted nodes (BFS from changed + volatiles) ───────────
    const impacted = new Set();
    const queue   = [];

    for (const chKey of changedKeys) {
        // direct dependents
        if (dependents[chKey]) {
            for (const dep of dependents[chKey]) {
                if (!impacted.has(dep)) {
                    impacted.add(dep);
                    queue.push(dep);
                }
            }
        }
        // self if formula
        if (nodesByKey[chKey] && !impacted.has(chKey)) {
            impacted.add(chKey);
            queue.push(chKey);
        }
        // volatiles on same sheet
        const sheet = chKey.split('i')[1];
        if (volatiles[sheet]) {
            for (const vk of volatiles[sheet]) {
                if (!impacted.has(vk)) {
                    impacted.add(vk);
                    queue.push(vk);
                }
            }
        }
    }

    while (queue.length > 0) {
        const k = queue.shift();
        const node = nodesByKey[k];
        if (!node) continue;
        for (const child of node.children) {
            if (!impacted.has(child)) {
                impacted.add(child);
                queue.push(child);
            }
        }
    }

    if (impacted.size === 0) {
        for (const k in nodesByKey) impacted.add(k);
    }

    // ── Topological order (DFS) with cycle warning ──────────────────────
    const order = [];
    const visited = new Set();
    const recStack = new Set();

    function dfs(key) {
        if (recStack.has(key)) {
            console.warn("Calculation cycle detected");
            return;
        }
        if (visited.has(key)) return;
        recStack.add(key);
        const node = nodesByKey[key];
        if (node) {
            for (const parent of node.parents) {
                if (impacted.has(parent)) dfs(parent);
            }
            visited.add(key);
            recStack.delete(key);
            order.push(node);
        }
    }

    for (const k of impacted) {
        if (!visited.has(k)) dfs(k);
    }

    // ── Evaluation phase ────────────────────────────────────────────────
    for (const node of order) {
        window.luckysheet_getcelldata_cache = null; // preserve legacy behavior

        const oldVal = sheetMap[node.index]?.[node.r]?.[node.c]?.v;
        const res = s.execfunction(node.formula, node.r, node.c, node.index);

        if (oldVal == res[1]) continue; // no change → skip write

        s.execFunctionGlobalData[`${node.r}_${node.c}_${node.index}`] = {
            v: res[1],
            f: res[2]
        };

        s.groupValuesRefreshData.push({
            r: node.r,
            c: node.c,
            v: res[1],
            f: res[2],
            spe: res[3],
            index: node.index
        });
    }

    s.execFunctionExist = null;
}
