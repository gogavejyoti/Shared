pasteHandlerOfCopyPaste: function (e) {
    // Early exit if no valid selection
    const sel = h.luckysheet_select_save;
    if (!gr(sel, h.currentSheetIndex)) return;

    const pasteLocale = Q().paste;
    const srcSheetIndex = e.dataSheetIndex;
    const srcRange = e.copyRange[0];
    const [srcRowStart, srcRowEnd] = srcRange.row;
    const [srcColStart, srcColEnd] = srcRange.column;
    const srcRowCount = srcRowEnd - srcRowStart + 1;
    const srcColCount = srcColEnd - srcColStart + 1;
    const hasMerge = e.HasMC;

    // 1️⃣ Flatten source range data once
    let copiedData = [];
    for (let i = 0; i < e.copyRange.length; i++) {
        const range = Nt({
            row: e.copyRange[i].row,
            column: e.copyRange[i].column
        }, srcSheetIndex);
        copiedData = copiedData.concat(range);
    }

    // Handle transpose case (multi-range vertical selection)
    if (e.copyRange.length > 1 && srcRowStart === e.copyRange[1].row[0] && srcRowEnd === e.copyRange[1].row[1]) {
        copiedData = copiedData[0].map((_, col) => copiedData.map(row => row[col]));
    }

    const srcData = copiedData;
    const srcH = srcData.length;
    const srcW = srcData[0].length;

    // 2️⃣ Determine paste target range
    const lastSel = sel[sel.length - 1];
    let [tRowStart, tRowEnd] = lastSel.row;
    let [tColStart, tColEnd] = lastSel.column;

    // Snap target size to source block size
    if (((tRowEnd - tRowStart + 1) % srcH !== 0) || ((tColEnd - tColStart + 1) % srcW !== 0)) {
        tRowEnd = tRowStart + srcH - 1;
        tColEnd = tColStart + srcW - 1;
    }

    // 3️⃣ Prepare target sheet data
    let cfg = $.extend(true, {}, h.config);
    if (cfg.merge == null) cfg.merge = {};
    const flowdata = we.deepCopyFlowData(h.flowdata);
    const rowExpand = (tRowEnd + 1) - flowdata.length;
    const colExpand = (tColEnd + 1) - flowdata[0].length;
    let targetData = (rowExpand > 0 || colExpand > 0) ? il(flowdata, rowExpand, colExpand, true) : flowdata;

    // 4️⃣ Formula cache to avoid re-evaluation of identical formulas
    const formulaCache = new Map();

    // 5️⃣ Precompute borders & dataVerification map
    const srcBorders = Ur(srcSheetIndex);
    const srcDV = h.luckysheetfile[K(srcSheetIndex)].dataVerification || {};
    const targetDV = $.extend(true, {}, h.luckysheetfile[K(h.currentSheetIndex)].dataVerification || {});
    const newDV = {};

    // 6️⃣ Paste in dependency order (row-major)
    for (let r = 0; r < srcH; r++) {
        const tRow = tRowStart + r;
        const rowArr = targetData[tRow].slice(); // shallow copy row
        for (let c = 0; c < srcW; c++) {
            const tCol = tColStart + c;
            let cell = srcData[r][c] ? $.extend(true, {}, srcData[r][c]) : null;

            // Handle formula shifting & caching
            if (cell && cell.f) {
                let shiftedFormula = cell.f;
                if (r !== 0) shiftedFormula = "=" + p.functionCopy(shiftedFormula, r > 0 ? "down" : "up", Math.abs(r));
                if (c !== 0) shiftedFormula = "=" + p.functionCopy(shiftedFormula, c > 0 ? "right" : "left", Math.abs(c));

                // Cache check
                if (formulaCache.has(shiftedFormula)) {
                    const cached = formulaCache.get(shiftedFormula);
                    cell.f = cached.f;
                    cell.v = cached.v;
                    if (cached.spl) cell.spl = cached.spl;
                    if (cell.ct?.fa) cell.m = mt(cell.ct.fa, cell.v);
                } else {
                    const evalRes = p.execfunction(shiftedFormula, tRow, tCol, undefined, true);
                    cell.f = evalRes[2];
                    cell.v = evalRes[1];
                    if (evalRes[3]?.data) cell.spl = evalRes[3].data;
                    if (cell.ct?.fa) cell.m = mt(cell.ct.fa, cell.v);
                    formulaCache.set(shiftedFormula, { f: cell.f, v: cell.v, spl: cell.spl });
                }
            }

            // Clear merge info on paste target if needed
            if (rowArr[tCol] && typeof rowArr[tCol] === "object" && "mc" in rowArr[tCol]) {
                delete cfg.merge[rowArr[tCol].mc.r + "_" + rowArr[tCol].mc.c];
            }

            rowArr[tCol] = cell;

            // Border copy
            const srcKey = (srcRowStart + r) + "_" + (srcColStart + c);
            if (srcBorders[srcKey]) {
                cfg.borderInfo = cfg.borderInfo || [];
                cfg.borderInfo.push({
                    rangeType: "cell",
                    value: {
                        row_index: tRow,
                        col_index: tCol,
                        ...srcBorders[srcKey]
                    }
                });
            }

            // Data verification copy
            if (srcDV[srcKey]) {
                newDV[tRow + "_" + tCol] = $.extend(true, {}, srcDV[srcKey]);
            }
        }
        targetData[tRow] = rowArr;
    }

    // 7️⃣ Apply new DataVerification if any
    const finalDV = Object.keys(newDV).length > 0 ? Object.assign({}, targetDV, newDV) : targetDV;

    // 8️⃣ Update sheet with single refresh
    const updateOpt = {
        cfg: cfg,
        dataVerification: finalDV
    };
    Ye(targetData, h.luckysheet_select_save, updateOpt);
    tt();
}
