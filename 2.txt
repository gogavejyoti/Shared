pasteHandlerOfCopyPaste: function (e) {
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex)) return;

    const t = Q().paste;
    let cfg = $.extend(true, {}, h.config);
    cfg.merge ??= {};

    const srcSheetIndex = e.dataSheetIndex;
    const [srcRowStart, srcRowEnd] = e.copyRange[0].row;
    const [srcColStart, srcColEnd] = e.copyRange[0].column;
    const srcRows = srcRowEnd - srcRowStart + 1;
    const srcCols = srcColEnd - srcColStart + 1;

    // Step 1: Collect copied data block once
    let copiedBlock = [];
    for (let i = 0; i < e.copyRange.length; i++) {
        const block = Nt({
            row: e.copyRange[i].row,
            column: e.copyRange[i].column
        }, srcSheetIndex);
        copiedBlock = copiedBlock.concat(block);
    }

    // Handle transpose copy (multi-range horizontal)
    if (e.copyRange.length > 1 && srcRowStart === e.copyRange[1].row[0]) {
        copiedBlock = copiedBlock[0].map((_, col) => copiedBlock.map(row => row[col]));
    }

    // Remove formulas if multi-range copy
    if (e.copyRange.length > 1) {
        for (let r = 0; r < copiedBlock.length; r++) {
            for (let c = 0; c < copiedBlock[r].length; c++) {
                if (copiedBlock[r][c]?.f) {
                    delete copiedBlock[r][c].f;
                    delete copiedBlock[r][c].spl;
                }
            }
        }
    }

    // Step 2: Determine paste target
    const selection = h.luckysheet_select_save[h.luckysheet_select_save.length - 1];
    let [destRowStart, destRowEnd] = selection.row;
    let [destColStart, destColEnd] = selection.column;

    // Adjust target size to block
    if (((destRowEnd - destRowStart + 1) % srcRows) !== 0 || ((destColEnd - destColStart + 1) % srcCols) !== 0) {
        destRowEnd = destRowStart + srcRows - 1;
        destColEnd = destColStart + srcCols - 1;
    }

    // Step 3: Merge check
    if (cfg.merge && Dt(cfg, destRowStart, destRowEnd, destColStart, destColEnd)) {
        de() ? alert(t.errorNotAllowMerged) : U.info(`<i class="fa fa-exclamation-triangle"></i>${t.warning}`, t.errorNotAllowMerged);
        return;
    }

    // Step 4: Expand flowdata if needed
    let flowdata = we.deepCopyFlowData(h.flowdata);
    const addRows = destRowEnd + 1 - flowdata.length;
    const addCols = destColEnd + 1 - flowdata[0].length;
    if (addRows > 0 || addCols > 0) flowdata = il(flowdata, addRows, addCols, true);

    const rowRepeats = Math.floor((destRowEnd - destRowStart + 1) / srcRows);
    const colRepeats = Math.floor((destColEnd - destColStart + 1) / srcCols);

    // Step 5: Prepare structures for formula evaluation
    const formulaTasks = [];
    const formulaCache = new Map();  // key: adjusted formula string, value: evaluated result

    // Step 6: Paste data blocks efficiently
    for (let blockR = 0; blockR < rowRepeats; blockR++) {
        for (let blockC = 0; blockC < colRepeats; blockC++) {
            const baseR = destRowStart + blockR * srcRows;
            const baseC = destColStart + blockC * srcCols;

            for (let r = 0; r < srcRows; r++) {
                const destR = baseR + r;
                const rowArr = flowdata[destR];

                for (let c = 0; c < srcCols; c++) {
                    const destC = baseC + c;
                    const srcCell = copiedBlock[r][c];
                    if (!srcCell) {
                        rowArr[destC] = null;
                        continue;
                    }

                    const newCell = { ...srcCell };

                    if (newCell.f) {
                        // Adjust formula position
                        let shiftedFormula = newCell.f;
                        const rowShift = destR - (srcRowStart + r);
                        const colShift = destC - (srcColStart + c);

                        if (rowShift !== 0) {
                            shiftedFormula = "=" + p.functionCopy(shiftedFormula, rowShift > 0 ? "down" : "up", Math.abs(rowShift));
                        }
                        if (colShift !== 0) {
                            shiftedFormula = "=" + p.functionCopy(shiftedFormula, colShift > 0 ? "right" : "left", Math.abs(colShift));
                        }

                        newCell.f = shiftedFormula;
                        // Defer formula evaluation
                        formulaTasks.push({ r: destR, c: destC, f: shiftedFormula });
                    }

                    rowArr[destC] = newCell;
                }
            }
        }
    }

    // Step 7: Evaluate formulas with caching
    for (const task of formulaTasks) {
        const { r, c, f } = task;

        if (formulaCache.has(f)) {
            flowdata[r][c].v = formulaCache.get(f);
            continue;
        }

        try {
            const result = p.execfunction(f, r, c, undefined, true);
            flowdata[r][c].v = result[1];
            flowdata[r][c].f = result[2];
            if (result[3]?.data) flowdata[r][c].spl = result[3].data;
            formulaCache.set(f, result[1]);
        } catch (err) {
            console.error("Formula evaluation error at", r, c, f, err);
        }
    }

    // Step 8: Final apply (one render)
    const opt = { cfg: cfg, RowlChange: true };
    Ye(flowdata, h.luckysheet_select_save, opt);
}
