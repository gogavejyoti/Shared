execfunction: function (e, n, t, l, a, o) {
    const s = this;
    const d = Q().formulaMore;

    if (e.includes(s.error.r)) return [false, s.error.r, e];
    if (!s.checkBracketNum(e)) e += ")";

    if (l == null) l = h.currentSheetIndex;
    h.calculateSheetIndex = l;

    let f = s.functionParserExe(e).trim();
    if (!f || !s.testFunction(e, f)) {
        return U.info("", d.execfunctionError), [false, s.error.n, e];
    }

    // Check cache for compiled formula
    if (!s._formulaCache) s._formulaCache = new Map();
    let compiledFn = s._formulaCache.get(f);

    try {
        if (!compiledFn) {
            compiledFn = new Function("return " + f);
            s._formulaCache.set(f, compiledFn);
        }
    } catch (err) {
        const errorMsg = s.errorInfo(err);
        return [false, [s.error.n, errorMsg], e];
    }

    // Cache cell ranges
    if (!s._cellRefCache) s._cellRefCache = new Map();
    let cellRefs = s._cellRefCache.get(e);
    if (!cellRefs && f.includes("luckysheet_getcelldata")) {
        cellRefs = [...f.matchAll(/luckysheet_getcelldata\('([^']+)'\)/g)]
            .map(m => s.getcellrange(m[1]));
        s._cellRefCache.set(e, cellRefs);
    }

    if (cellRefs) {
        for (const w of cellRefs) {
            if (w.row[0] < 0 || w.column[0] < 0) return [true, s.error.r, e];
            if (w.sheetIndex === h.calculateSheetIndex &&
                n >= w.row[0] && n <= w.row[1] &&
                t >= w.column[0] && t <= w.column[1]) {
                U.info("", d.execfunctionSelfErrorResult);
                return [false, 0, e];
            }
        }
    }

    let m;
    try {
        m = compiledFn();
        if (typeof m === "string") m = m.replace(/\x7F/g, '"');
    } catch (err) {
        const errorMsg = s.errorInfo(err);
        return [false, [s.error.n, errorMsg], e];
    }

    // Handle dynamic arrays quickly
    const mType = L(m);
    let g = null, y = null;

    if (mType === "object" && m.startCell != null) {
        if (Array.isArray(m.data)) m = s.error.v;
        else if (typeof m.data === "object" && !fe(m.data.v)) m = m.data.v;
        else if (fe(m.data)) m = 0;
        else m = m.cell > 1 || m.rowl > 1 ? m.data : 0;
    } else if (mType === "array") {
        if (Array.isArray(m[0]) && m.length === 1 && m[0].length === 1) {
            m = m[0][0];
        } else {
            y = { r: n, c: t, f: e, index: l, data: m };
            m = "";
        }
    }

    if (a) s.execFunctionGroup(n, t, m, l);
    if (!o) s.insertUpdateFunctionGroup(n, t, l);

    return g ? [true, m, e, { type: "sparklines", data: g }] :
        y ? [true, m, e, { type: "dynamicArrayItem", data: y }] :
            [true, m, e];
},
