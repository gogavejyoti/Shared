execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;

    const s = this;

    // ==============================
    // ORIGINAL LOGIC (UNCHANGED)
    // ==============================
    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    if (typeof _shiftCrossSheetReference === "function") {
        _shiftCrossSheetReference({ type: "recalc", sheetIndex: l });
    }

    // ==============================
    // sheetIndices LOGIC (UNCHANGED)
    // ==============================
    let allFuncCells = [];
    let sheetIndices = null;

    if (e != null && n != null) {
        const formulaOrValue =
            (window.luckysheet_getcelldata_cache &&
                Object.keys(window.luckysheet_getcelldata_cache).join("+")) ||
            null;

        sheetIndices = s.getAllDependentSheetsFromSheet(l, formulaOrValue);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    const sheetsInfo = Ft() || [];
    const sheetMap = {};

    if (sheetIndices) {
        for (let i = 0; i < sheetsInfo.length; i++) {
            if (!sheetIndices.includes(sheetsInfo[i].index)) continue;
            sheetMap[sheetsInfo[i].index] = sheetsInfo[i].data;
        }
    } else {
        for (let i = 0; i < sheetsInfo.length; i++) {
            sheetMap[sheetsInfo[i].index] = sheetsInfo[i].data;
        }
    }

    // ==============================
    // execSet (UNCHANGED)
    // ==============================
    const execSet = {};
    if (s.execFunctionExist == null) {
        execSet["r" + e + "c" + n + "i" + l] = 1;
    } else {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const T = s.execFunctionExist[i];
            execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
        }
    }

    // ðŸ”§ FIX: detect batch mode (large drag)
    const isBatchMode =
        s.execFunctionExist &&
        s.execFunctionExist.length > 1;

    // ==============================
    // BUILD DEPENDENCY GRAPH
    // ==============================
    const nodes = {};
    const rangeToKeysCache = {};

    function keysForRange(R) {
        const key =
            "r" + R.row[0] + "_" + R.row[1] +
            "_c" + R.column[0] + "_" + R.column[1] +
            "_i" + R.sheetIndex;

        if (rangeToKeysCache[key]) return rangeToKeysCache[key];

        const list = [];
        for (let r = R.row[0]; r <= R.row[1]; r++) {
            for (let c = R.column[0]; c <= R.column[1]; c++) {
                list.push("r" + r + "c" + c + "i" + R.sheetIndex);
            }
        }
        rangeToKeysCache[key] = list;
        return list;
    }

    // ==============================
    // BUILD NODES  ðŸ”§ FIX #1
    // ==============================
    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const nodeKey = "r" + T.r + "c" + T.c + "i" + T.index;
        const R = zl(T.r, T.c, T.index);
        if (!R) continue;

        const formulaRanges = [];

        // ðŸ”¥ ALWAYS extract references (IF / IFERROR safe)
        this.isFunctionRange(R, null, null, T.index, null, function (ref) {
            const rg = s.getcellrange($.trim(ref), T.index);
            if (rg) formulaRanges.push(rg);
        });

        nodes[nodeKey] = {
            formulaArray: formulaRanges,
            calc_funcStr: R,
            key: nodeKey,
            r: T.r,
            c: T.c,
            index: T.index,
            parents: {},
            chidren: {},
            color: "w"
        };
    }

    // ==============================
    // BUILD GRAPH + SEED ðŸ”§ FIX #2
    // ==============================
    const y = [];
    const nodeKeys = Object.keys(nodes);

    for (let i = 0; i < nodeKeys.length; i++) {
        const node = nodes[nodeKeys[i]];
        const ranges = node.formulaArray || [];

        for (let ri = 0; ri < ranges.length; ri++) {
            const rect = ranges[ri];
            const keys = keysForRange(rect);

            for (let ki = 0; ki < keys.length; ki++) {
                const A = keys[ki];

                if (nodes[A]) {
                    node.chidren[A] = 1;
                    nodes[A].parents[node.key] = 1;
                }

                if (!o) {
                    if (A in execSet) {
                        y.push(node);
                    }

                    // ðŸ”¥ batch-mode safety: include all affected nodes
                    if (isBatchMode) {
                        y.push(node);
                    }
                }
            }
        }

        if (o) y.push(node);
    }

    // ==============================
    // TOPOLOGICAL SORT
    // ==============================
    const S = {};
    const stack = y.slice();
    const ordered = [];

    while (stack.length) {
        const cur = stack.pop();
        if (!cur || S[cur.key]) continue;

        if (cur.color === "b") {
            ordered.push(cur);
            S[cur.key] = 1;
            continue;
        }

        const parentKeys = Object.keys(cur.parents || {});
        if (parentKeys.length === 0) {
            ordered.push(cur);
            S[cur.key] = 1;
        } else {
            cur.color = "b";
            stack.push(cur);
            for (let i = 0; i < parentKeys.length; i++) {
                const pk = parentKeys[i];
                if (nodes[pk]) stack.push(nodes[pk]);
            }
        }
    }

    // ðŸ”§ FIX #3: DO NOT reverse (breaks chains)
    // ordered.reverse();

    // ==============================
    // EVALUATE
    // ==============================
    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];
        window.luckysheet_getcelldata_cache = null;

        const Rres = s.execfunction(T.calc_funcStr, T.r, T.c, T.index);

        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: Rres[1],
            f: Rres[2],
            spe: Rres[3],
            index: T.index
        });
    }

    s.execFunctionExist = null;
}
