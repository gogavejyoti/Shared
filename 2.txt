 execfunction: function (e, n, t, l, a, o) {
     const s = this, d = Q().formulaMore, err = s.error;

     // Fast reject: invalid range in expression
     if (e.includes(err.r)) return [false, err.r, e];

     // Ensure brackets are balanced
     if (!s.checkBracketNum(e)) e += ")";

     // Default to current sheet index
     if (l == null) l = h.currentSheetIndex;
     h.calculateSheetIndex = l;

     // Trim & pre-parse
     const f = $.trim(s.functionParserExe(e));

     // Quick reject: invalid function
     if (!f || !s.testFunction(e, f)) {
         U.info("", d.execfunctionError);
         return [false, err.n, e];
     }

     // Reset HTML index only if needed
     if (f.startsWith("luckysheet_function.") || f.startsWith("luckysheet_compareWith")) {
         s.functionHTMLIndex = 0;
     }

     // Cache globals to avoid window lookups
     window.luckysheetCurrentRow = n;
     window.luckysheetCurrentColumn = t;
     window.luckysheetCurrentIndex = l;
     window.luckysheetCurrentFunction = e;

     let m = null, g = null;

     try {
         // Optimized: only scan if string is present
         if (f.includes("luckysheet_getcelldata")) {
             const parts = f.split("luckysheet_getcelldata('");
             for (let i = 1; i < parts.length; i++) {
                 const range = parts[i].split("')")[0];
                 const cellRange = s.getcellrange(range);

                 if (cellRange.row[0] < 0 || cellRange.column[0] < 0)
                     return [true, err.r, e];

                 // Circular ref check
                 if (
                     cellRange.sheetIndex === h.calculateSheetIndex &&
                     n >= cellRange.row[0] && n <= cellRange.row[1] &&
                     t >= cellRange.column[0] && t <= cellRange.column[1]
                 ) {
                     de() ? alert(d.execfunctionSelfError) : U.info("", d.execfunctionSelfErrorResult);
                     return [false, 0, e];
                 }
             }
         }

         // Execute formula
         m = new Function("return " + f)();
         if (typeof m === "string") m = m.replace(/\x7F/g, '"');
         if (f.includes("SPLINES")) { g = m; m = ""; }

     } catch (errCaught) {
         console.log(errCaught, f);
         const k = s.errorInfo(errCaught);
         m = [err.n, k];
     }

     // Handle object return types quickly
     if (L(m) === "object" && m.startCell != null) {
         if (Array.isArray(m.data)) m = err.v;
         else if (L(m.data) === "object" && !fe(m.data.v)) m = m.data.v;
         else if (fe(m.data)) m = 0;
         else if (m.cell > 1 || m.rowl > 1 || typeof m.data === "string" || typeof m.data === "number") m = m.data;
         else m = 0;
     }

     // Handle array returns
     let y = null;
     if (Array.isArray(m)) {
         const flatTwo = !Array.isArray(m[0]) && m.length === 2 && H(m[0]);
         if (flatTwo) {
             m = m[0];
         } else if (Array.isArray(m[0]) && m.length === 1 && m[0].length === 1) {
             m = m[0][0];
         } else {
             y = { r: n, c: t, f: e, index: l, data: m };
             m = "";
         }
     }

     // Reset globals
     window.luckysheetCurrentRow = null;
     window.luckysheetCurrentColumn = null;
     window.luckysheetCurrentIndex = null;
     window.luckysheetCurrentFunction = null;

     // Execute group updates if required
     if (n != null && t != null) {
         if (a) s.execFunctionGroup(n, t, m, l);
         if (!o) s.insertUpdateFunctionGroup(n, t, l);
     }

     // Return optimized response
     if (g) return [true, m, e, { type: "sparklines", data: g }];
     if (y) return [true, m, e, { type: "dynamicArrayItem", data: y }];
     return [true, m, e];
 },
