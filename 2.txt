pasteHandlerOfCopyPaste: function(e) {
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex)) return;

    let t = Q().paste,
        l = $.extend(true, {}, h.config);
    l.merge = l.merge || {};

    const a = e.HasMC,
          o = e.RowlChange,
          s = e.dataSheetIndex,
          copyRange = e.copyRange[0],
          u = copyRange.row[0],
          d = copyRange.row[1],
          f = copyRange.column[0],
          m = copyRange.column[1];

    let g = [],
        y = false;

    // Prepare copied data
    for (let idx = 0; idx < e.copyRange.length; idx++) {
        let data = Nt({ row: e.copyRange[idx].row, column: e.copyRange[idx].column }, s);
        if (e.copyRange.length > 1) {
            if (u === e.copyRange[1].row[0] && d === e.copyRange[1].row[1]) {
                data = data[0].map((_, colIdx) => data.map(row => row[colIdx]));
                g = g.concat(data);
                y = true;
            } else if (f === e.copyRange[1].column[0] && m === e.copyRange[1].column[1]) {
                g = g.concat(data);
            }
        } else g = data;
    }

    if (y) g = g[0].map((_, colIdx) => g.map(row => row[colIdx]));

    let v = $.extend(true, [], g);

    if (e.copyRange.length > 1) {
        for (let r = 0; r < v.length; r++)
            for (let c = 0; c < v[r].length; c++)
                if (v[r][c]?.f != null) delete v[r][c].f, delete v[r][c].spl;
    }

    // Determine target range
    let w = h.luckysheet_select_save[h.luckysheet_select_save.length - 1],
        x = w.row[0],
        C = w.row[1],
        S = w.column[0],
        _ = w.column[1],
        T = (C - x + 1) % v.length,
        A = (_ - S + 1) % v[0].length;

    if (T !== 0 || A !== 0) {
        C = x + v.length - 1;
        _ = S + v[0].length - 1;
    }

    // Merge conflict check
    let R = l.merge && Dt(l, x, C, S, _);
    if (R) {
        de() ? alert(t.errorNotAllowMerged) : U.info(`<i class="fa fa-exclamation-triangle"></i>${t.warning}`, t.errorNotAllowMerged);
        return;
    }

    const I = (C - x + 1) / v.length,
          F = (_ - S + 1) / v[0].length;

    let N = we.deepCopyFlowData(h.flowdata),
        P = v.length + x - N.length,
        z = v[0].length + S - N[0].length;

    if (P > 0 || z > 0) N = il([].concat(N), P, z, true);

    const O = Ur(s),
          V = $.extend(true, {}, h.luckysheetfile[K(s)].dataVerification);

    let q = null;

    // -----------------------------
    // Ultra-fast paste loop (formulas as text only)
    // -----------------------------
    for (let se = 1; se <= I; se++) {
        for (let ie = 1; ie <= F; ie++) {
            let Y = x + (se - 1) * v.length,
                X = S + (ie - 1) * v[0].length,
                te = x + se * v.length,
                ee = S + ie * v[0].length;
            let ue = Y - u, he = X - f, formulaMap = {};

            for (let G = Y; G < te; G++) {
                let rowCopy = [].concat(N[G]);
                for (let pe = X; pe < ee; pe++) {
                    let cell = v[G - Y]?.[pe - X] ? $.extend(true, {}, v[G - Y][pe - X]) : null;
                    if (cell) {
                        // Paste formula as text only, ensure '='
                        if (cell.f != null) {
                            let formulaText = cell.f.startsWith('=') ? cell.f : '=' + cell.f;
                            formulaText = p.functionCopy(formulaText, "down", ue);
                            formulaText = p.functionCopy(formulaText, "right", he);
                            cell.f = formulaText;
                            cell.v = null;      // skip calculation now
                            cell.dirty = true;  // mark for later recalculation
                        }

                        // Multi-cell merge
                        if (a && "mc" in cell) {
                            if (cell.mc.rs != null) {
                                cell.mc.r = G;
                                cell.mc.c = pe;
                                l.merge[cell.mc.r + "_" + cell.mc.c] = cell.mc;
                                formulaMap[cell.mc.r + "_" + cell.mc.c] = [cell.mc.r, cell.mc.c];
                            } else {
                                rowCopy[pe] = { mc: { r: formulaMap[cell.mc.r + "_" + cell.mc.c][0], c: formulaMap[cell.mc.r + "_" + cell.mc.c][1] } };
                            }
                        }
                    }
                    rowCopy[pe] = cell;
                }
                N[G] = rowCopy;
            }
        }
    }

    w.row = [x, C];
    w.column = [S, _];

    // Conditional formatting & data validation
    let ce = null;
    if (e.copyRange.length == 1) {
        const sourceCF = h.luckysheetfile[K(s)].luckysheet_conditionformat_save;
        if (sourceCF?.length > 0) {
            ce = $.extend(true, [], h.luckysheetfile[K(h.currentSheetIndex)].luckysheet_conditionformat_save);
            for (let cf of sourceCF) {
                let newRanges = [];
                for (let le = 1; le <= I; le++)
                    for (let pe = 1; pe <= F; pe++) {
                        let Y = x + (le - 1) * v.length,
                            X = S + (pe - 1) * v[0].length,
                            te = x + le * v.length,
                            ee = S + pe * v[0].length;
                        for (let r of cf.cellrange) {
                            const adjusted = $e.CFSplitRange(r, { row: [u, d], column: [f, m] }, { row: [Y, te - 1], column: [X, ee - 1] }, "operatePart");
                            if (adjusted.length > 0) newRanges = newRanges.concat(adjusted);
                        }
                    }
                if (newRanges.length > 0) {
                    let cfCopy = $.extend(true, {}, cf);
                    cfCopy.cellrange = newRanges;
                    ce.push(cfCopy);
                }
            }
        }
    }

    // Final write
    const payload = { cfg: l, RowlChange: o, cdformat: ce, dataVerification: q };
    Ye(N, h.luckysheet_select_save, payload);

    // -----------------------------
    // Recalculate only visible cells after paste
    // -----------------------------
    const visible = luckysheet.getVisibleCellRange(); // visible rows & columns
    for (let r = visible.row[0]; r <= visible.row[1]; r++) {
        for (let c = visible.column[0]; c <= visible.column[1]; c++) {
            const cell = N[r][c];
            if (cell?.dirty) {
                const result = cell.f ? p.execfunction(cell.f, r, c, void 0, true) : null;
                if (result) {
                    cell.v = result[1];
                    if (cell.ct?.fa) cell.m = mt(cell.ct.fa, cell.v);
                }
                cell.dirty = false;
            }
        }
    }

    tt(); // refresh UI
}
