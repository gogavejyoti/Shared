execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;
    const s = this;

    // --- 1. Global Setup (One-time or Fast) ---
    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }
    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    // Set explicit value
    if (t != null) {
        // reuse single temp object to avoid allocations if called repeatedly
        const tmp = [[{ v: null }]]; 
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // --- 2. Data Gathering (Optimized Access) ---
    let allFuncCells = [];
    if (e != null && n != null) {
        const cache = window.luckysheet_getcelldata_cache;
        const formulaOrValue = (cache && Object.keys(cache).join("+")) || null;
        const sheetIndices = s.getAllDependentSheetsFromSheet(l, formulaOrValue);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else if (s.execFunctionExist && s.execFunctionExist.length > 0) {
        const sheetIndices = s.getAllDependentSheetsFromSheet(s.execFunctionExist[0].i, null);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    // Fast Sheet Map
    const sheetsInfo = Ft() || [];
    const sheetMap = []; // use Array for integer index access if possible, else obj
    for (let i = 0; i < sheetsInfo.length; i++) {
        sheetMap[sheetsInfo[i].index] = sheetsInfo[i].data;
    }

    // --- 3. Superfast Graph Primitives ---
    
    // Unique ID for this execution run (to avoid clearing flags on nodes)
    const RUN_ID = (s._execRunId || 0) + 1;
    s._execRunId = RUN_ID;

    // Node Registry: Map<CoordinateKey, Node>
    // We try to use a specialized key for speed.
    // IF rows < 65535, we can use integer bitmasking: (row << 16) | col
    // This avoids string concat "r_c_i" completely for the vast majority of cases.
    const _nodes = new Map(); 

    function getNode(r, c, i) {
        // High-performance key generation
        const key = (r < 65000 && c < 65000) 
            ? (i * 10000000000) + (r << 16) + c 
            : "r" + r + "c" + c + "i" + i;
        return _nodes.get(key);
    }
    
    function getOrMakeNode(r, c, i, formula = null) {
        const isInt = (r < 65000 && c < 65000);
        const key = isInt 
            ? (i * 10000000000) + (r << 16) + c 
            : "r" + r + "c" + c + "i" + i;
            
        let node = _nodes.get(key);
        if (!node) {
            node = {
                key: key,
                r: r, c: c, i: i,
                func: formula,
                // Direct pointers instead of string keys
                parents: [],  
                children: [],
                visited: 0,   // Checked against RUN_ID
                color: 0,     // 0:white, 1:gray, 2:black (for DFS)
                dirty: false
            };
            _nodes.set(key, node);
        } else if (formula && !node.func) {
            node.func = formula; // Late binding of formula
        }
        return node;
    }

    // Helper: Add dependency edge (Child depends on Parent)
    function addEdge(childNode, parentR, parentC, parentI) {
        const pNode = getOrMakeNode(parentR, parentC, parentI);
        // Avoid duplicate edges? 
        // For max speed, we might allow dupes and filter later, 
        // but checking array includes is slow for large degrees.
        // We assume the parser emits unique ranges usually.
        pNode.children.push(childNode);
        childNode.parents.push(pNode);
    }

    // --- 4. Optimized Parser & Range Expander ---
    const _rgCache = new Map();
    
    function processDependencies(node) {
        const formula = node.func;
        if (!formula) return;
        const idx = node.i;

        // --- Fast Guard Checks (IndexOF is faster than Regex) ---
        // Only run complex logic if the function Name exists in the string
        
        let processed = false;

        // Helper to add range
        const addRange = (txt, isFull) => {
            // Cache range parsing
            const cKey = idx + '|' + txt;
            let rect = _rgCache.get(cKey);
            if (!rect) {
                rect = s.getcellrange(txt, idx);
                _rgCache.set(cKey, rect);
            }
            if (!rect) return;

            // Explode range to nodes
            // *Optimization*: Don't create string keys. Use the loops to getOrMakeNode directly.
            
            // Bounds check
            const sm = sheetMap[rect.sheetIndex];
            const maxR = (sm && sm.length - 1) ?? rect.row[1];
            const endR = rect.row[1] > maxR ? maxR : rect.row[1];
            
            // To prevent self-dependency
            const selfR = node.r, selfC = node.c, selfI = node.i;
            const targetI = rect.sheetIndex;

            // Tight loop
            for (let r = rect.row[0]; r <= endR; r++) {
                for (let c = rect.column[0]; c <= rect.column[1]; c++) {
                    if (isFull && r === selfR && c === selfC && targetI === selfI) continue;
                    addEdge(node, r, c, targetI);
                }
            }
        };

        // 1. LOOKUP Exact Match Fast Path
        if (formula.indexOf('LOOKUP') !== -1) {
             // HLOOKUP
            if (formula.indexOf('HLOOKUP') !== -1) {
                const h = parseCallFast('HLOOKUP', formula);
                if (h && h.args.length >= 3) {
                    const exact = isFalseyExact(h.args[3]); // 4th arg index 3
                    const tableTxt = h.args[0];
                    if (exact) {
                        const rect = getRect(tableTxt, idx);
                        if (rect) {
                            // Header row
                            addExplicitRect(node, rect.row[0], rect.row[0], rect.column[0], rect.column[1], rect.sheetIndex);
                            // Return row
                            const ri = parseIntFast(h.args[1]);
                            if (ri !== null) {
                                const tr = rect.row[0] + (ri - 1);
                                addExplicitRect(node, tr, tr, rect.column[0], rect.column[1], rect.sheetIndex);
                                return; // DONE
                            }
                        }
                    }
                }
            }
            // VLOOKUP
            if (formula.indexOf('VLOOKUP') !== -1) {
                const v = parseCallFast('VLOOKUP', formula);
                if (v && v.args.length >= 3) {
                    const exact = isFalseyExact(v.args[3]);
                    const tableTxt = v.args[0];
                    if (exact) {
                        const rect = getRect(tableTxt, idx);
                        if (rect) {
                            // First col
                            addExplicitRect(node, rect.row[0], rect.row[1], rect.column[0], rect.column[0], rect.sheetIndex);
                            // Return col
                            const ci = parseIntFast(v.args[1]);
                            if (ci !== null) {
                                const tc = rect.column[0] + (ci - 1);
                                addExplicitRect(node, rect.row[0], rect.row[1], tc, tc, rect.sheetIndex);
                                return; // DONE
                            }
                        }
                    }
                }
            }
        }
        
        // 2. INDEX Fast Path
        if (formula.indexOf('INDEX') !== -1) {
            const i = parseCallFast('INDEX', formula);
            if (i && i.args.length >= 2) {
                const rect = getRect(i.args[0], idx);
                if (rect) {
                    const ri = parseIntFast(i.args[1]);
                    const ci = parseIntFast(i.args[2]);
                    // Exact cell
                    if (ri !== null && ci !== null) {
                        const r = rect.row[0] + ri - 1;
                        const c = rect.column[0] + ci - 1;
                        addEdge(node, r, c, rect.sheetIndex);
                        return;
                    }
                    // Row slice
                    if (ri !== null) {
                        const r = rect.row[0] + ri - 1;
                        addExplicitRect(node, r, r, rect.column[0], rect.column[1], rect.sheetIndex);
                        return;
                    }
                    // Col slice
                    if (ci !== null) {
                        const c = rect.column[0] + ci - 1;
                        addExplicitRect(node, rect.row[0], rect.row[1], c, c, rect.sheetIndex);
                        return;
                    }
                }
            }
        }

        // 3. Fallback: Tokenizer (Aggressive Split)
        // Using a loop over regex matches is faster than split for sparse tokens
        const tokenRe = /([a-zA-Z_$][a-zA-Z0-9_$]*!)?\$?[a-zA-Z]+\$?[0-9]+(:(\$?[a-zA-Z]+\$?[0-9]+))?/g;
        let match;
        while ((match = tokenRe.exec(formula)) !== null) {
            const tk = match[0];
            if (s.iscelldata(tk)) { // Lightweight check from original code
                 addRange(tk, true);
            }
        }
        
        // INDIRECT Check
        if (formula.indexOf('INDIRECT') !== -1) {
            // Mark volatile on global map
            const si = node.i;
            if (!s._volatileNodes) s._volatileNodes = {};
            if (!s._volatileNodes[si]) s._volatileNodes[si] = [];
            s._volatileNodes[si].push(node);
        }
    }

    // Helper for rect lookups
    function getRect(txt, idx) {
        const cKey = idx + '|' + txt;
        let rect = _rgCache.get(cKey);
        if (!rect) {
            rect = s.getcellrange(txt, idx);
            _rgCache.set(cKey, rect);
        }
        return rect;
    }
    
    function addExplicitRect(node, r1, r2, c1, c2, i) {
        const sm = sheetMap[i];
        const maxR = (sm && sm.length - 1) ?? r2;
        const endR = r2 > maxR ? maxR : r2;
        for (let r = r1; r <= endR; r++) {
            for (let c = c1; c <= c2; c++) {
                 addEdge(node, r, c, i);
            }
        }
    }

    function parseCallFast(name, str) {
        // Minimal parser: find Name( ... )
        const start = str.indexOf(name);
        if (start === -1) return null;
        const openP = str.indexOf('(', start);
        if (openP === -1) return null;
        
        let depth = 1;
        let lastComma = openP + 1;
        const args = [];
        const len = str.length;
        
        for (let k = openP + 1; k < len; k++) {
            const char = str.charCodeAt(k); // Using charCodeAt is slightly faster
            if (char === 40) { // (
                depth++;
            } else if (char === 41) { // )
                depth--;
                if (depth === 0) {
                    args.push(str.substring(lastComma, k).trim());
                    return { args };
                }
            } else if (char === 44 && depth === 1) { // ,
                args.push(str.substring(lastComma, k).trim());
                lastComma = k + 1;
            }
        }
        return null;
    }

    function parseIntFast(val) {
        if (!val) return null;
        if (typeof val === 'number') return val;
        // Check if string is just digits
        if (/^\d+$/.test(val)) return parseInt(val, 10);
        return null; 
    }
    
    function isFalseyExact(val) {
        if (val == null) return false;
        const s = String(val).trim().toLowerCase();
        return s === '0' || s === 'false';
    }

    // --- 5. Build Graph (The Heavy Lift) ---
    // Create nodes for ALL gathered function cells
    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        // Try to get formula cheaply
        let f = null;
        const sheet = sheetMap[T.index];
        if (sheet && sheet[T.r] && sheet[T.r][T.c]) {
            f = sheet[T.r][T.c].f;
        }
        // Fallback
        if (!f) {
             const cell = ve.getSheetByIndex(T.index)?.celldata?.find(x => x.r === T.r && x.c === T.c);
             if (cell && cell.v) f = cell.v.f;
        }
        
        if (f) {
            const node = getOrMakeNode(T.r, T.c, T.index, f);
            processDependencies(node);
        }
    }

    // --- 6. Impact Propagation (BFS with Integer Flags) ---
    // Start with the changed cell(s)
    const queue = [];
    let qHead = 0;

    function addToQueue(node) {
        if (node.visited !== RUN_ID) {
            node.visited = RUN_ID;
            queue.push(node);
        }
    }

    // Seed queue
    if (s.execFunctionExist) {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const T = s.execFunctionExist[i];
            const node = getOrMakeNode(T.r, T.c, T.i);
            addToQueue(node);
        }
    } else {
        const node = getOrMakeNode(e, n, l);
        addToQueue(node);
    }

    // Add Volatiles (INDIRECT) if they exist on the impacted sheets
    // (Simplification: If any cell on sheet L changed, trigger volatiles on L)
    // In a "Superfast" generic way, we might just add all known volatiles if we don't track sheet-dirty flags.
    if (s._volatileNodes) {
        // Just add all for safety or track by sheet. Adding all is safer for Indirect.
        for (const k in s._volatileNodes) {
             const vNodes = s._volatileNodes[k];
             for (let v = 0; v < vNodes.length; v++) addToQueue(vNodes[v]);
        }
    }

    // BFS Loop (Pointer Chasing)
    while (qHead < queue.length) {
        const node = queue[qHead++];
        const children = node.children;
        // Standard for-loop is faster than for-of
        for (let i = 0; i < children.length; i++) {
            addToQueue(children[i]);
        }
    }

    // If nothing impacted, recalc everything (fallback)
    if (queue.length === 0) {
        // Add all function nodes
        _nodes.forEach(node => {
            if (node.func) queue.push(node);
        });
    }

    // --- 7. Execution Order (DFS Topological Sort) ---
    const sorted = [];
    
    // Reset colors for DFS (using run-specific logic if needed, but here simple reset is OK 
    // since we only process the 'queue' items which are exactly the impacted set)
    // Actually, we need to mark visited for Sort distinct from BFS visited.
    // Let's use node.color: 0=unvisited, 1=visiting, 2=visited
    
    // We only need to sort the nodes that are in the `queue` (impacted set).
    // However, the `queue` contains the input cells (no formulas). Filter them.
    const toCalc = [];
    for (let i = 0; i < queue.length; i++) {
        const n = queue[i];
        if (n.func) {
            n.color = 0; 
            toCalc.push(n);
        }
    }

    function dfs(u) {
        u.color = 1; // Gray
        const parents = u.parents;
        for (let i = 0; i < parents.length; i++) {
            const p = parents[i];
            // Only follow parents that are also in the impacted set (toCalc)
            // AND are formulas. 
            // *Optimization*: Check `visited === RUN_ID`.
            if (p.visited === RUN_ID && p.func) {
                if (p.color === 1) {
                    console.warn("Cycle detected");
                } else if (p.color === 0) {
                    dfs(p);
                }
            }
        }
        u.color = 2; // Black
        sorted.push(u);
    }

    for (let i = 0; i < toCalc.length; i++) {
        if (toCalc[i].color === 0) dfs(toCalc[i]);
    }

    // --- 8. Final Evaluation ---
    // sorted is now in Topological Order (Parents first).
    
    for (let i = 0; i < sorted.length; i++) {
        const node = sorted[i];
        window.luckysheet_getcelldata_cache = null; // Clear per-cell cache
        
        // Fast old value check
        const sm = sheetMap[node.i];
        const oldVal = sm?.[node.r]?.[node.c]?.v;

        const res = s.execfunction(node.func, node.r, node.c, node.i);
        
        // Value compare
        if (oldVal == res[1]) continue;

        // Write
        const keyStr = node.r + "_" + node.c + "_" + node.i; // Unfortunately API needs string
        s.execFunctionGlobalData[keyStr] = { v: res[1], f: res[2] };
        s.groupValuesRefreshData.push({
            r: node.r, c: node.c, v: res[1], f: res[2], spe: res[3], index: node.i
        });
    }

    s.execFunctionExist = null;
}
