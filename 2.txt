using Microsoft.ML;
using Microsoft.ML.TimeSeries;
using System;
using System.Collections.Generic;
using System.Linq;

public class MetricData
{
    public float Value { get; set; }
}

public class ForecastPrediction
{
    public float[] ForecastedValues { get; set; }
}

public static class ForecastUtils
{
    public static List<float> ForecastPercentage(MLContext mlContext, List<float?> rawValues, int forecastHorizon)
    {
        if (rawValues == null || rawValues.Count == 0)
            return Enumerable.Repeat(0f, forecastHorizon).ToList();

        // Step 1: Remove invalid values (null, negative)
        var values = rawValues.Where(v => v.HasValue && v.Value >= 0).Select(v => v.Value).ToList();

        if (values.Count == 0)
            return Enumerable.Repeat(0f, forecastHorizon).ToList();

        // Step 2: Remove trailing zeros
        values = values.Reverse<float>().SkipWhile(v => v == 0).Reverse().ToList();

        // Step 3: Handle very short series
        if (values.Count < 6)
        {
            float lastVal = values.LastOrDefault();
            return Enumerable.Repeat(lastVal, forecastHorizon).ToList();
        }

        // Step 4: Prepare data
        var data = values.Select(v => new MetricData { Value = v }).ToList();
        var dataView = mlContext.Data.LoadFromEnumerable(data);

        // Step 5: Exponential Smoothing Forecast pipeline
        var pipeline = mlContext.Forecasting.ForecastByExponentialSmoothing(
            outputColumnName: nameof(ForecastPrediction.ForecastedValues),
            inputColumnName: nameof(MetricData.Value),
            horizon: forecastHorizon,
            smoothingLevel: 0.5f, // alpha, adjust for responsiveness
            trend: false,
            seasonal: false
        );

        // Step 6: Train the model
        var model = pipeline.Fit(dataView);

        // Step 7: Create forecast engine and predict
        var forecastEngine = model.CreateTimeSeriesEngine<MetricData, ForecastPrediction>(mlContext);
        var forecast = forecastEngine.Predict();

        // Step 8: Clamp output to 0â€“100% and handle NaNs
        float lastKnown = values.Last();
        var result = forecast.ForecastedValues
                             .Select(v => float.IsNaN(v) ? lastKnown : Math.Max(0f, Math.Min(100f, v)))
                             .ToList();

        return result;
    }
}
