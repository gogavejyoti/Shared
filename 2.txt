execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;
    const s = this;
    const h = window.luckysheet; // Access global state

    // 1. Setup & Defaults
    if (a == null) a = h.flowdata(); 
    if (l == null) l = h.currentSheetIndex;
    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};

    // 2. Direct Value Update (The Trigger)
    // If a specific value was passed (t), update the source cell immediately 
    // so dependencies see it.
    if (t != null && e != null && n != null) {
        if (!a[e]) a[e] = [];
        if (!a[e][n]) a[e][n] = {};
        a[e][n].v = t; 
        // Sync to the global data object Luckysheet uses
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = { v: t };
    }

    // 3. Optimized Node & Graph Logic
    const RUN_ID = (s._execRunId || 0) + 1;
    s._execRunId = RUN_ID;
    const _nodes = new Map();

    const getOrMakeNode = (r, c, i, formula = null) => {
        const key = (r < 65000 && c < 65000) ? (i * 10000000000) + (r << 16) + c : `r${r}c${c}i${i}`;
        let node = _nodes.get(key);
        if (!node) {
            node = { r, c, i, func: formula, parents: [], children: [], visited: 0, color: 0 };
            _nodes.set(key, node);
        } else if (formula && !node.func) {
            node.func = formula;
        }
        return node;
    };

    // 4. Build Graph (Gathering Dependencies)
    // We only care about functions that might be impacted
    const allFuncCells = s.getAllFunctionGroup() || [];
    const sheetsInfo = h.getluckysheetfile();
    const sheetMap = {};
    sheetsInfo.forEach(f => { sheetMap[f.index] = f.data; });

    for (let i = 0; i < allFuncCells.length; i++) {
        const fCell = allFuncCells[i];
        const sheetData = sheetMap[fCell.index];
        const cell = sheetData?.[fCell.r]?.[fCell.c];
        if (cell && cell.f) {
            const childNode = getOrMakeNode(fCell.r, fCell.c, fCell.index, cell.f);
            
            // Fast regex to find all potential cell references in formula
            const refs = cell.f.match(/([a-zA-Z_$][a-zA-Z0-9_$]*!)?\$?[a-zA-Z]+\$?[0-9]+(:(\$?[a-zA-Z]+\$?[0-9]+))?/g);
            if (refs) {
                refs.forEach(ref => {
                    const range = s.getcellrange(ref, fCell.index);
                    if (!range) return;
                    for (let r = range.row[0]; r <= range.row[1]; r++) {
                        for (let c = range.column[0]; c <= range.column[1]; c++) {
                            const pNode = getOrMakeNode(r, c, range.sheetIndex);
                            pNode.children.push(childNode);
                            childNode.parents.push(pNode);
                        }
                    }
                });
            }
        }
    }

    // 5. Impact Analysis (BFS)
    const queue = [];
    let head = 0;
    const addToQueue = (node) => {
        if (node.visited !== RUN_ID) {
            node.visited = RUN_ID;
            queue.push(node);
        }
    };

    // Seed: The cell that actually changed
    if (s.execFunctionExist) {
        s.execFunctionExist.forEach(t => addToQueue(getOrMakeNode(t.r, t.c, t.i)));
    } else if (e != null) {
        addToQueue(getOrMakeNode(e, n, l));
    }

    while (head < queue.length) {
        const curr = queue[head++];
        for (let i = 0; i < curr.children.length; i++) {
            addToQueue(curr.children[i]);
        }
    }

    // 6. Topological Sort (Ensure Parents calculate before Children)
    const sorted = [];
    const visitSort = (u) => {
        u.color = 1; // gray
        for (let i = 0; i < u.children.length; i++) {
            const v = u.children[i];
            if (v.visited === RUN_ID && v.color === 0) visitSort(v);
        }
        u.color = 2; // black
        sorted.push(u);
    };

    queue.forEach(node => { if (node.color === 0) visitSort(node); });
    sorted.reverse(); // Now dependents come after dependencies

    // 7. Execution Loop
    // This is the most important part for "References Updating"
    for (let i = 0; i < sorted.length; i++) {
        const node = sorted[i];
        if (!node.func) continue;

        // Clear formula cache to force fresh lookup of parent values
        window.luckysheet_getcelldata_cache = null;

        const result = s.execfunction(node.func, node.r, node.c, node.i);
        const newVal = result[1];

        // CRITICAL: Update the actual data sheet so the NEXT formula in the loop
        // sees this updated value when it calls its own 'execfunction'.
        const targetSheetData = sheetMap[node.i];
        if (targetSheetData && targetSheetData[node.r] && targetSheetData[node.r][node.c]) {
            targetSheetData[node.r][node.c].v = newVal;
        }

        // Store for UI Refresh
        const key = node.r + "_" + node.c + "_" + node.i;
        s.execFunctionGlobalData[key] = { v: newVal, f: node.func };
        s.groupValuesRefreshData.push({
            r: node.r, c: node.c, v: newVal, f: node.func, index: node.i
        });
    }

    s.execFunctionExist = null;
}
