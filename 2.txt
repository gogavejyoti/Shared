function _shiftCrossSheetReference({
    type,
    sheetIndex,
    rowIndex,
    rowCount = 1,
    colIndex,
    colCount = 1
}) {
    const sheets = Ft() || [];
    let changed = false;

    const REF_REGEX =
        /(?:'([^']+)'|([A-Za-z0-9_]+))!(\$?\d+:\$?\d+|\$?[A-Z]+:\$?[A-Z]+|\$?\d+|\$?[A-Z]+|\$?[A-Z]+\$?\d+(?::\$?[A-Z]+\$?\d+)?)/g;

    for (const sheet of sheets) {
        if (!sheet.data) continue;

        for (const row of sheet.data) {
            if (!row) continue;

            for (const cell of row) {
                if (!cell || typeof cell.f !== "string") continue;

                const original = cell.f;
                let refError = false;

                const updated = original.replace(REF_REGEX, (m, qs, us, ref) => {
                    const name = qs || us;
                    const target = sheets.find(s => s.name === name);
                    if (!target) return m;

                    const same = target.index === sheetIndex;

                    // ---------- ROW RANGE ----------
                    if (/^\$?\d+:\$?\d+$/.test(ref)) {
                        if (!same) return m;
                        let [a, b] = ref.split(":");
                        let s = +a.replace("$", "");
                        let e = +b.replace("$", "");
                        const sa = a[0] === "$";
                        const ea = b[0] === "$";

                        ({ s, e } = shiftRange(type, s, e, rowIndex + 1, rowCount, true));
                        if (s == null) {
                            refError = true;
                            return "#REF!";
                        }
                        return `'${name}'!${sa ? "$" : ""}${s}:${ea ? "$" : ""}${e}`;
                    }

                    // ---------- ROW ONLY ----------
                    if (/^\$?\d+$/.test(ref)) {
                        if (!same) return m;
                        let r = +ref.replace("$", "");
                        const abs = ref[0] === "$";

                        if (type === "insertRow" && r > rowIndex + 1) r += rowCount;
                        if (type === "deleteRow") {
                            if (r > rowIndex && r <= rowIndex + rowCount) {
                                refError = true;
                                return "#REF!";
                            }
                            if (r > rowIndex + rowCount) r -= rowCount;
                        }
                        return `'${name}'!${abs ? "$" : ""}${r}`;
                    }

                    // ---------- COLUMN RANGE ----------
                    if (/^\$?[A-Z]+:\$?[A-Z]+$/.test(ref)) {
                        if (!same) return m;
                        let [a, b] = ref.split(":");
                        let s = colToIdx(a.replace("$", ""));
                        let e = colToIdx(b.replace("$", ""));
                        const sa = a[0] === "$";
                        const ea = b[0] === "$";

                        ({ s, e } = shiftRange(type, s, e, colIndex, colCount, false));
                        if (s == null) {
                            refError = true;
                            return "#REF!";
                        }
                        return `'${name}'!${sa ? "$" : ""}${idxToCol(s)}:${ea ? "$" : ""}${idxToCol(e)}`;
                    }

                    // ---------- COLUMN ONLY ----------
                    if (/^\$?[A-Z]+$/.test(ref)) {
                        if (!same) return m;
                        let c = colToIdx(ref.replace("$", ""));
                        const abs = ref[0] === "$";

                        if (type === "insertCol" && c >= colIndex) c += colCount;
                        if (type === "deleteCol") {
                            if (c >= colIndex && c < colIndex + colCount) {
                                refError = true;
                                return "#REF!";
                            }
                            if (c >= colIndex + colCount) c -= colCount;
                        }
                        return `'${name}'!${abs ? "$" : ""}${idxToCol(c)}`;
                    }

                    // ---------- A1 / A1:B2 ----------
                    const parts = ref.split(":");
                    const s = parseA1(parts[0]);
                    const e = parts[1] ? parseA1(parts[1]) : s;

                    let sr = s.row, er = e.row;
                    let sc = s.col, ec = e.col;

                    if (same) {
                        ({ s: sr, e: er } = shiftRange(type, sr, er, rowIndex + 1, rowCount, true));
                        ({ s: sc, e: ec } = shiftRange(type, sc, ec, colIndex, colCount, false));
                        if (sr == null || sc == null) {
                            refError = true;
                            return "#REF!";
                        }
                    }

                    const start = buildA1(s, sc, sr);
                    const end = parts[1] ? buildA1(e, ec, er) : null;
                    return `'${name}'!${end ? start + ":" + end : start}`;
                });

                if (updated !== original) {
                    cell.f = updated;
                    changed = true;
                    if (refError) {
                        cell.v = "#REF!";
                        cell.ct = { t: "e", fa: "General" };
                    }
                }
            }
        }
    }

    if (changed) {
        if (typeof jf !== "undefined" && jf.refresh) jf.refresh();
        else if (typeof luckysheetrefreshgrid === "function") luckysheetrefreshgrid();
    }

    // ---------- helpers ----------
    function shiftRange(type, s, e, opStart, opCount, isRow) {
        const opEnd = opStart + opCount - 1;

        if ((type === "insertRow" && isRow) || (type === "insertCol" && !isRow)) {
            if (opStart < s) return { s: s + opCount, e: e + opCount };
            if (opStart >= s && opStart <= e) return { s, e: e + opCount };
            return { s, e };
        }

        if ((type === "deleteRow" && isRow) || (type === "deleteCol" && !isRow)) {
            if (opEnd < s) return { s: s - opCount, e: e - opCount };
            if (opStart > e) return { s, e };

            const overlap = Math.min(e, opEnd) - Math.max(s, opStart) + 1;
            if (overlap >= (e - s + 1)) return { s: null, e: null };
            return { s, e: e - overlap };
        }

        return { s, e };
    }

    function parseA1(r) {
        const m = /^(\$?)([A-Z]+)(\$?)(\d+)$/.exec(r);
        return {
            absCol: !!m[1],
            col: colToIdx(m[2]),
            absRow: !!m[3],
            row: +m[4]
        };
    }

    function buildA1(b, c, r) {
        return `${b.absCol ? "$" : ""}${idxToCol(c)}${b.absRow ? "$" : ""}${r}`;
    }

    function colToIdx(c) {
        let n = 0;
        for (let i = 0; i < c.length; i++) n = n * 26 + c.charCodeAt(i) - 64;
        return n - 1;
    }

    function idxToCol(n) {
        let s = "";
        for (n++; n > 0; n = Math.floor((n - 1) / 26))
            s = String.fromCharCode(65 + ((n - 1) % 26)) + s;
        return s;
    }
}
