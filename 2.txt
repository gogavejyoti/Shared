 // Build dependency graph
                const y = [];
                const nodeKeys = Object.keys(nodes);
                for (let i = 0; i < nodeKeys.length; i++) {
                    const node = nodes[nodeKeys[i]];
                    const ranges = node.formulaArray || [];
                    for (let ri = 0; ri < ranges.length; ri++) {
                        const rect = ranges[ri];
                        const keys = keysForRange(rect, sheetMap);
                        for (let ki = 0; ki < keys.length; ki++) {
                            const cellInfo = keys[ki];
                            const A = cellInfo.key;
                            if (A in nodes) {
                                //node.chidren[A] = 1;
                                //nodes[A].parents[node.key] = 1;

                                node.parents[A] = 1;
                                nodes[A].chidren[node.key] = 1;

                                //node.parents[A] = 1;          // node depends on A  
                                //nodes[A].chidren[node.key] = 1;  // A is a parent of node  
                            }
                            if (!o && (A in execSet)) y.push(node);
                        }
                    }
                    if (o) y.push(node);
                }

                // Topological sort
                const S = {};
                const stack = y.slice();
                const ordered = [];
                while (stack.length > 0) {
                    const cur = stack.pop();
                    if (!cur || S[cur.key]) continue;
                    if (cur.color === "b") {
                        ordered.push(cur);
                        S[cur.key] = 1;
                        continue;
                    }

                    const parentKeys = Object.keys(cur.parents || {});
                    const parentNodes = [];
                    for (let pi = 0; pi < parentKeys.length; pi++) {
                        const pk = parentKeys[pi];
                        if (nodes[pk]) parentNodes.push(nodes[pk]);
                    }

                    if (parentNodes.length === 0) {
                        ordered.push(cur);
                        S[cur.key] = 1;
                    } else {
                        cur.color = "b";
                        stack.push(cur);
                        for (let p = 0; p < parentNodes.length; p++) stack.push(parentNodes[p]);
                    }
                }

                ordered.reverse();


node.parents[A] = 1;       
nodes[A].chidren[node.key] = 1;  
 Example - 
Sheet_n6rGibTl0ii3_1766500200534=>D12=>=IFERROR(D10-D7,0)
Sheet_n6rGibTl0ii3_1766500200534=>D15=>=ROUND(IFERROR(D10/D7,0),2)
Sheet_n6rGibTl0ii3_1766500200534=>D10=>=IFERROR(D19+D22+D23,0)
Sheet_n6rGibTl0ii3_1766500200534=>D19=>=IF(LEN(D82)=0,(83*(1-C41))-D81+D92+D124,(83-D81+D92+D124))
Sheet_n6rGibTl0ii3_1766500200534=>D81=>=SUM(D82:D91)
Sheet_n6rGibTl0ii3_1766500200534=>D92=>=SUM(D93:D99)
Sheet_n6rGibTl0ii3_1766500200534=>D22=>=SUM(D120:D121)
Sheet_n6rGibTl0ii3_1766500200534=>D23=>=SUM(D122:D123)
Sheet_f6r5e3pC050k_1766508421290=>D7=>=AirCover_BAN!D7+AirCover_LV!D7


 node.chidren[A] = 1;
 nodes[A].parents[node.key] = 1;
 Example -
 Sheet_n6rGibTl0ii3_1766500200534=>D12=>=IFERROR(D10-D7,0)
 Sheet_n6rGibTl0ii3_1766500200534=>D15=>=ROUND(IFERROR(D10/D7,0),2)
 Sheet_f6r5e3pC050k_1766508421290=>D7=>=AirCover_BAN!D7+AirCover_LV!D7
 Sheet_f6r5e3pC050k_1766508421290=>D12=>=IFERROR(D10-D7,0)
 Sheet_f6r5e3pC050k_1766508421290=>D15=>=ROUND(IFERROR(D10/D7,0),2)

