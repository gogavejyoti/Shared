function _shiftSameSheetReference({
    type,
    sheetIndex,
    rowIndex,
    rowCount = 1,
    colIndex,
    colCount = 1
}) {
    const allSheets = Ft() || [];
    const sheet = allSheets[sheetIndex];
    if (!sheet || !sheet.data) return;

    let sheetChanged = false;

    // Matches: A1, $A$1, A1:B10, $A1:B$10
    const referenceRegex = /\$?([A-Z]+)\$?(\d+)(:\$?([A-Z]+)\$?(\d+))?/g;

    const data = sheet.data;

    for (let r = 0; r < data.length; r++) {
        if (!data[r]) continue;

        for (let c = 0; c < data[r].length; c++) {
            const cell = data[r][c];
            if (!cell || !cell.f) continue;

            const originalFormula = cell.f;
            let modifiedFormula = originalFormula;
            let errorDetected = false;

            modifiedFormula = modifiedFormula.replace(referenceRegex, function (
                match,
                startCol, startRow,
                _range,
                endCol, endRow
            ) {
                // ---- Absolute markers ----
                const startAbsCol = match.startsWith("$") ? "$" : "";
                const startAbsRow = /\$\d+/.test(match) ? "$" : "";

                let endAbsCol = "", endAbsRow = "";
                if (endCol || endRow) {
                    const rp = match.split(":")[1];
                    if (rp) {
                        endAbsCol = rp.startsWith("$") ? "$" : "";
                        endAbsRow = /\$\d+/.test(rp) ? "$" : "";
                    }
                }

                // ---- Indices ----
                let startColIndex = colLetterToIndex(startCol);
                let startRowIndex = parseInt(startRow, 10);
                let endColIndex = endCol ? colLetterToIndex(endCol) : startColIndex;
                let endRowIndex = endRow ? parseInt(endRow, 10) : startRowIndex;

                let rowDeleted = false;
                let colDeleted = false;

                /* ================= ROW OPS ================= */

                if (type === "insertRow") {
                    if (!startAbsRow && startRowIndex >= rowIndex + 1)
                        startRowIndex += rowCount;

                    if (!endAbsRow && endRowIndex >= rowIndex + 1)
                        endRowIndex += rowCount;
                }

                if (type === "deleteRow") {
                    const delStart = rowIndex + 1;
                    const delEnd   = rowIndex + rowCount;

                    // Reference inside deleted rows → #REF!
                    if (
                        (startRowIndex >= delStart && startRowIndex <= delEnd) ||
                        (endRowIndex   >= delStart && endRowIndex   <= delEnd)
                    ) {
                        rowDeleted = true;
                        errorDetected = true;
                    }
                    else {
                        // Reference below deleted rows → shift up
                        if (!startAbsRow && startRowIndex > delEnd)
                            startRowIndex -= rowCount;

                        if (!endAbsRow && endRowIndex > delEnd)
                            endRowIndex -= rowCount;
                    }
                }

                /* ================= COL OPS ================= */

                if (type === "insertCol") {
                    if (!startAbsCol && startColIndex >= colIndex)
                        startColIndex += colCount;

                    if (!endAbsCol && endColIndex >= colIndex)
                        endColIndex += colCount;
                }

                if (type === "deleteCol") {
                    const delStart = colIndex;
                    const delEnd   = colIndex + colCount - 1;

                    // Reference inside deleted columns → #REF!
                    if (
                        (startColIndex >= delStart && startColIndex <= delEnd) ||
                        (endColIndex   >= delStart && endColIndex   <= delEnd)
                    ) {
                        colDeleted = true;
                        errorDetected = true;
                    }
                    else {
                        // Reference right of deleted columns → shift left
                        if (!startAbsCol && startColIndex > delEnd)
                            startColIndex -= colCount;

                        if (!endAbsCol && endColIndex > delEnd)
                            endColIndex -= colCount;
                    }
                }

                if (rowDeleted || colDeleted) return "#REF!";

                // ---- Rebuild reference ----
                const startRef =
                    `${startAbsCol}${indexToColLetter(startColIndex)}` +
                    `${startAbsRow}${startRowIndex}`;

                if (!endCol && !endRow) return startRef;

                const endRef =
                    `${endAbsCol}${indexToColLetter(endColIndex)}` +
                    `${endAbsRow}${endRowIndex}`;

                return `${startRef}:${endRef}`;
            });

            if (modifiedFormula !== originalFormula) {
                cell.f = modifiedFormula;
                sheetChanged = true;

                if (errorDetected) {
                    cell.v = "#REF!";
                    cell.ct = { fa: "General", t: "e" };
                }
            }
        }
    }

    if (sheetChanged) {
        if (typeof jf !== "undefined" && jf.refresh)
            jf.refresh();
        else if (typeof luckysheetrefreshgrid === "function")
            luckysheetrefreshgrid();
    }

    /* ================= HELPERS ================= */

    function colLetterToIndex(col) {
        let n = 0;
        for (let i = 0; i < col.length; i++)
            n = n * 26 + (col.charCodeAt(i) - 64);
        return n - 1;
    }

    function indexToColLetter(n) {
        let s = "";
        n++;
        while (n > 0) {
            let r = (n - 1) % 26;
            s = String.fromCharCode(65 + r) + s;
            n = Math.floor((n - 1) / 26);
        }
        return s;
    }
}
