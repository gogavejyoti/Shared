execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;

    const s = this;
    if (a == null) a = h.flowdata;
    if (l == null) l = h.currentSheetIndex;

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};

    // ------------------------------
    // helpers init (unchanged)
    // ------------------------------
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    // ------------------------------
    // collect formula cells
    // ------------------------------
    let allFuncCells = s.getAllFunctionGroup() || [];

    const sheetsInfo = Ft() || [];
    const sheetMap = {};
    sheetsInfo.forEach(sh => sheetMap[sh.index] = sh.data);

    const nodes = {};
    const rangeToKeysCache = {};

    function keysForRange(R) {
        const k = `r${R.row[0]}_${R.row[1]}_c${R.column[0]}_${R.column[1]}_i${R.sheetIndex}`;
        if (rangeToKeysCache[k]) return rangeToKeysCache[k];
        const list = [];
        for (let r = R.row[0]; r <= R.row[1]; r++) {
            for (let c = R.column[0]; c <= R.column[1]; c++) {
                list.push("r" + r + "c" + c + "i" + R.sheetIndex);
            }
        }
        rangeToKeysCache[k] = list;
        return list;
    }

    // ------------------------------
    // BUILD NODES  ðŸ”§ FIX #1
    // ------------------------------
    for (const T of allFuncCells) {
        const key = "r" + T.r + "c" + T.c + "i" + T.index;
        const formula = zl(T.r, T.c, T.index);
        if (!formula) continue;

        const ranges = [];

        // ðŸ”¥ ALWAYS extract dependencies (fixes IFERROR / IF)
        s.isFunctionRange(formula, null, null, T.index, null, function (ref) {
            const rg = s.getcellrange($.trim(ref), T.index);
            if (rg) ranges.push(rg);
        });

        nodes[key] = {
            key,
            r: T.r,
            c: T.c,
            index: T.index,
            calc_funcStr: formula,
            parents: {},
            children: {}
        };
    }

    // ------------------------------
    // LINK GRAPH
    // ------------------------------
    for (const k in nodes) {
        const node = nodes[k];
        for (const rg of node.ranges || []) {
            const keys = keysForRange(rg);
            for (const depKey of keys) {
                if (nodes[depKey]) {
                    node.parents[depKey] = 1;
                    nodes[depKey].children[k] = 1;
                }
            }
        }
    }

    // ------------------------------
    // START FROM CHANGED CELL ðŸ”§ FIX #2
    // ------------------------------
    const startKey = "r" + e + "c" + n + "i" + l;
    const stack = [startKey];
    const visited = {};
    const evalList = [];

    while (stack.length) {
        const k = stack.pop();
        if (visited[k] || !nodes[k]) continue;
        visited[k] = 1;
        evalList.push(nodes[k]);
        for (const ck in nodes[k].children) stack.push(ck);
    }

    // ------------------------------
    // TOPO SORT (parent â†’ child)
    // ------------------------------
    const ordered = [];
    const temp = {};

    function dfs(node) {
        if (temp[node.key]) return;
        temp[node.key] = 1;
        for (const pk in node.parents) {
            if (nodes[pk]) dfs(nodes[pk]);
        }
        ordered.push(node);
    }

    evalList.forEach(dfs);

    // ------------------------------
    // EVALUATE ðŸ”§ FIX #3
    // ------------------------------
    for (const T of ordered) {
        window.luckysheet_getcelldata_cache = null;

        const R = s.execfunction(T.calc_funcStr, T.r, T.c, T.index);
        const sheet = sheetMap[T.index];

        // ðŸ”¥ IMMEDIATE COMMIT
        if (sheet && sheet[T.r] && sheet[T.r][T.c]) {
            sheet[T.r][T.c].v = {
                v: R[1],
                f: R[2],
                spe: R[3]
            };
        }

        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: R[1],
            f: R[2],
            spe: R[3],
            index: T.index
        });
    }

    s.execFunctionExist = null;
}
