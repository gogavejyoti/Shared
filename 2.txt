// Build dependency graph
const y = [];
const nodeKeys = Object.keys(nodes);
for (let i = 0; i < nodeKeys.length; i++) {
    const node = nodes[nodeKeys[i]];
    const ranges = node.formulaArray || [];
    for (let ri = 0; ri < ranges.length; ri++) {
        const rect = ranges[ri];
        const keys = keysForRange(rect, sheetMap);
        for (let ki = 0; ki < keys.length; ki++) {
            const cellInfo = keys[ki];
            const A = cellInfo.key;
            if (A in nodes) {
                node.parents[A] = 1;  // node depends on A
                nodes[A].children[node.key] = 1;  // A is used by node
            }
        }
    }
}

// Determine which cells need recalculation
if (o) {
    // Recalculate everything
    for (let i = 0; i < nodeKeys.length; i++) {
        y.push(nodes[nodeKeys[i]]);
    }
} else {
    // Start from cells in execSet and traverse all dependents
    const visited = {};
    const queue = [];
    
    // Add all cells from execSet to the queue
    const execKeys = Object.keys(execSet);
    for (let i = 0; i < execKeys.length; i++) {
        const key = execKeys[i];
        if (nodes[key]) {
            queue.push(nodes[key]);
        }
    }
    
    // BFS to find ALL cells affected by changes
    while (queue.length > 0) {
        const cur = queue.shift();
        if (!cur || visited[cur.key]) continue;
        
        visited[cur.key] = 1;
        y.push(cur);
        
        // Add all children (cells that depend on this cell)
        const childKeys = Object.keys(cur.children || {});
        for (let ci = 0; ci < childKeys.length; ci++) {
            const childKey = childKeys[ci];
            if (nodes[childKey] && !visited[childKey]) {
                queue.push(nodes[childKey]);
            }
        }
    }
}

// Topological sort
const S = {};
const stack = y.slice();
const ordered = [];
while (stack.length > 0) {
    const cur = stack.pop();
    if (!cur || S[cur.key]) continue;
    if (cur.color === "b") {
        ordered.push(cur);
        S[cur.key] = 1;
        continue;
    }
    const parentKeys = Object.keys(cur.parents || {});
    const parentNodes = [];
    for (let pi = 0; pi < parentKeys.length; pi++) {
        const pk = parentKeys[pi];
        if (nodes[pk]) parentNodes.push(nodes[pk]);
    }
    if (parentNodes.length === 0) {
        ordered.push(cur);
        S[cur.key] = 1;
    } else {
        cur.color = "b";
        stack.push(cur);
        for (let p = 0; p < parentNodes.length; p++) stack.push(parentNodes[p]);
    }
}
ordered.reverse();
```

**What changed:**

1. **Separated dependency graph building from selection logic** - First build the complete graph, then determine what to recalculate
2. **Start BFS from execSet cells directly** - Instead of checking `if (A in execSet)` during graph building
3. **Traverse children properly** - Use the `children` property to find ALL downstream dependents across all sheets

Now the flow is:
```
execSet = {Sheet1=>D1}

1. Queue: [Sheet1=>D1]
2. Process Sheet1=>D1 → Add its children → Queue: [Sheet2=>D7]
3. Process Sheet2=>D7 → Add its children → Queue: [Sheet2=>D10]
4. Process Sheet2=>D10 → Add its children → Queue: [Sheet2=>D15]
5. Continue until all dependents are found
