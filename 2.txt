update: async function () {
    const e = this;
    if (!gr([e.applyRange], h.currentSheetIndex) || h.allowEdit === false) return;

    const sheetIndex = h.currentSheetIndex;
    const flowdata = we.deepCopyFlowData(h.flowdata);
    const sheet = h.luckysheetfile[K(sheetIndex)];

    const cfg = $.extend(true, {}, h.config);
    cfg.borderInfo = Array.isArray(cfg.borderInfo) ? cfg.borderInfo : [];

    const borderCache = Ur();
    const dataVerification = $.extend(true, {}, sheet.dataVerification || {});

    const { direction, copyRange, applyRange } = e;

    const [srcR1, srcR2] = copyRange.row;
    const [srcC1, srcC2] = copyRange.column;
    const [dstR1, dstR2] = applyRange.row;
    const [dstC1, dstC2] = applyRange.column;

    const unit =
        direction === "down" || direction === "up"
            ? Math.max(1, srcR2 - srcR1 + 1)
            : Math.max(1, srcC2 - srcC1 + 1);

    const copied = e.getCopyData(flowdata, srcR1, srcR2, srcC1, srcC2, direction);

    const key = (r, c) => r + "_" + c;

    const pushBorder = (r, c, b) => {
        cfg.borderInfo.push({
            rangeType: "cell",
            value: {
                row_index: r,
                col_index: c,
                l: b?.l ?? null,
                r: b?.r ?? null,
                t: b?.t ?? null,
                b: b?.b ?? null
            }
        });
    };

    const formatValue = (cell) => {
        if (!cell) return;
        try {
            const [m, ct] = it(cell.v);
            cell.m = String(m);
            cell.ct = cell.ct || ct;
        } catch {
            cell.m = String(cell.v ?? "");
            cell.ct = cell.ct || { fa: "General", t: "n" };
        }
    };

    /* --------------------------------------------------
       APPLY VALUES (NO RECALC HERE)
    -------------------------------------------------- */

    if (direction === "down" || direction === "up") {
        const height = dstR2 - dstR1 + 1;

        for (let col = dstC1; col <= dstC2; col++) {
            const srcCol = copied[col - dstC1];
            const expanded = e.getApplyData(srcCol, unit, height);

            for (let r = dstR1; r <= dstR2; r++) {
                const idx =
                    direction === "down" ? r - dstR1 : dstR2 - r;
                const cell = $.extend(true, {}, expanded[idx]);

                flowdata[r] = flowdata[r] || [];
                const srcRow =
                    direction === "down"
                        ? srcR1 + (idx % unit)
                        : srcR2 - (idx % unit);

                if (cell?.f) {
                    let f = cell.f;
                    const shift = direction === "down" ? idx + 1 : -(idx + 1);
                    f = "=" + this.functionCopy(f, direction, Math.abs(shift));
                    const res = this.execfunction(f, r, col, undefined, true);
                    cell.f = res[2];
                    cell.v = res[1];
                }

                formatValue(cell);
                flowdata[r][col] = cell;

                if (borderCache[key(srcRow, col)]) {
                    pushBorder(r, col, borderCache[key(srcRow, col)]);
                }

                if (dataVerification[key(srcRow, col)]) {
                    dataVerification[key(r, col)] =
                        dataVerification[key(srcRow, col)];
                }
            }
        }
    } else {
        const width = dstC2 - dstC1 + 1;

        for (let row = dstR1; row <= dstR2; row++) {
            const srcRow = copied[row - dstR1];
            const expanded = e.getApplyData(srcRow, unit, width);

            for (let c = dstC1; c <= dstC2; c++) {
                const idx =
                    direction === "right" ? c - dstC1 : dstC2 - c;
                const cell = $.extend(true, {}, expanded[idx]);

                flowdata[row] = flowdata[row] || [];
                const srcCol =
                    direction === "right"
                        ? srcC1 + (idx % unit)
                        : srcC2 - (idx % unit);

                if (cell?.f) {
                    let f = cell.f;
                    const shift = direction === "right" ? idx + 1 : -(idx + 1);
                    f = "=" + this.functionCopy(f, direction, Math.abs(shift));
                    const res = this.execfunction(f, row, c, undefined, true);
                    cell.f = res[2];
                    cell.v = res[1];
                }

                formatValue(cell);
                flowdata[row][c] = cell;

                if (borderCache[key(row, srcCol)]) {
                    pushBorder(row, c, borderCache[key(row, srcCol)]);
                }

                if (dataVerification[key(row, srcCol)]) {
                    dataVerification[key(row, c)] =
                        dataVerification[key(row, srcCol)];
                }
            }
        }
    }

    /* --------------------------------------------------
       âœ… SINGLE, CORRECT RECALC
    -------------------------------------------------- */
    await Promise.resolve(
        this.execFunctionGroup(
            dstR1,
            dstC1,
            null,
            sheetIndex,
            flowdata
        )
    );

    /* --------------------------------------------------
       APPLY TO UI
    -------------------------------------------------- */
    Ye(flowdata, h.luckysheet_select_save, {
        cfg,
        dataVerification
    });
    tt();
}
