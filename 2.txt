public static class AssumptionSimulationUtility
{
    public static List<TimeSeriesSimulationResult> SimulateUsingTrend(
        List<AssumptionSimulator> historicalData,
        DateTime weekFrom,
        DateTime weekTo)
    {
        var results = new List<TimeSeriesSimulationResult>();
        if (historicalData == null || !historicalData.Any())
            return results;

        // Determine forecast horizon
        var futureWeeks = GenerateFutureWeeks(weekFrom, weekTo);
        var forecastHorizon = futureWeeks.Count;
        if (forecastHorizon == 0)
            return results;

        var lobGroups = historicalData
            .GroupBy(x => x.LOB)
            .ToList();

        foreach (var lobGroup in lobGroups)
        {
            var lob = lobGroup.Key;

            var shrinkageValues = lobGroup
                .OrderBy(x => x.WeekDate)
                .Where(x => x.ActualShrinkage.HasValue)
                .Select(x => x.ActualShrinkage.Value)
                .ToList();

            var attritionValues = lobGroup
                .OrderBy(x => x.WeekDate)
                .Where(x => x.ActualAttrition.HasValue)
                .Select(x => x.ActualAttrition.Value)
                .ToList();

            var shrinkageForecast = ForecastHoltLinear(shrinkageValues, forecastHorizon);
            var attritionForecast = ForecastHoltLinear(attritionValues, forecastHorizon);

            for (int i = 0; i < futureWeeks.Count; i++)
            {
                results.Add(new TimeSeriesSimulationResult
                {
                    LOB = lob,
                    WeekDate = futureWeeks[i],
                    PredictedShrinkage = shrinkageForecast.Count > i ? shrinkageForecast[i] : shrinkageForecast.LastOrDefault(),
                    PredictedAttrition = attritionForecast.Count > i ? attritionForecast[i] : attritionForecast.LastOrDefault()
                });
            }
        }

        return results;
    }

    private static List<float> ForecastHoltLinear(List<float> values, int forecastHorizon)
    {
        if (values == null || values.Count == 0)
            return Enumerable.Repeat(0f, forecastHorizon).ToList();

        // Remove invalids
        values = values.Where(v => v >= 0f).ToList();
        if (values.Count == 0) return Enumerable.Repeat(0f, forecastHorizon).ToList();

        // Remove trailing zeros
        values = values.Reverse<float>().SkipWhile(v => v == 0f).Reverse().ToList();

        float minVal = values.Min();
        float maxVal = values.Max();

        int n = values.Count;

        // Short series (<2 points) â†’ repeat last value
        if (n < 2)
        {
            float lastVal = values.Last();
            return Enumerable.Repeat(lastVal, forecastHorizon).ToList();
        }

        // Holt Linear parameters
        double alpha = 0.5; // level smoothing
        double beta = 0.3;  // trend smoothing

        // Initialize level and trend
        double level = values[0];
        double trend = values[1] - values[0];

        for (int i = 1; i < n; i++)
        {
            double prevLevel = level;
            level = alpha * values[i] + (1 - alpha) * (level + trend);
            trend = beta * (level - prevLevel) + (1 - beta) * trend;
        }

        // Forecast horizon
        var forecast = new List<float>();
        for (int h = 1; h <= forecastHorizon; h++)
        {
            double val = level + h * trend;
            val = Math.Max(minVal, Math.Min(maxVal, val)); // clamp to min/max
            forecast.Add((float)val);
        }

        return forecast;
    }

    private static List<DateTime> GenerateFutureWeeks(DateTime start, DateTime end)
    {
        var weeks = new List<DateTime>();
        var current = start;
        while (current <= end)
        {
            weeks.Add(current);
            current = current.AddDays(7);
        }
        return weeks;
    }
}
