const FORMULA_SPLIT_REGEX = /==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/;

execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;
    const s = this;

    // 1. Core Initialization
    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja; window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr; window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn; window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c; window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t; window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (!s.formulaCache) s.formulaCache = {}; 
    if (l == null) l = h.currentSheetIndex;

    // 2. Set Trigger Value
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // 3. Determine Scope
    let allFuncCells = [];
    if (e && n) {
        const cacheKey = (window.luckysheet_getcelldata_cache && Object.keys(window.luckysheet_getcelldata_cache).join("+")) || null;
        const dependentSheets = s.getAllDependentSheetsFromSheet(l, cacheKey);
        allFuncCells = s.getAllDependentFunctionGroup(dependentSheets) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }
    if (allFuncCells.length === 0) return;

    // 4. Data Structures for the Graph
    const nodes = new Map();
    const spatialIndex = new Map(); // Map<Sheet, Map<Row, Node[]>>
    const dirtySet = new Set(); // Cells that triggered the change

    const triggerHash = `${l}_${e}_${n}`;
    if (s.execFunctionExist == null) {
        dirtySet.add(triggerHash);
    } else {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const d = s.execFunctionExist[i];
            dirtySet.add(`${d.i}_${d.r}_${d.c}`);
        }
    }

    // --- PHASE 1: Node Creation & Dependency Parsing ---
    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const rawFormula = zl(T.r, T.c, T.index);
        if (!rawFormula) continue;

        const cellId = `${T.index}_${T.r}_${T.c}`;
        
        // Cache Logic: Verify by position AND string to handle dragging 100% correctly
        const cacheKey = cellId + "::" + rawFormula;
        let ranges = s.formulaCache[cacheKey];

        if (!ranges) {
            ranges = [];
            const upper = rawFormula.toUpperCase();
            if (upper.includes("INDIRECT(") || upper.includes("OFFSET(") || upper.includes("INDEX(")) {
                this.isFunctionRange(rawFormula, null, null, T.index, null, (ref) => {
                    const rg = s.getcellrange($.trim(ref), T.index);
                    if (rg) ranges.push(rg);
                });
            } else if (!(rawFormula.startsWith('="') && rawFormula.endsWith('"'))) {
                const tokens = rawFormula.split(FORMULA_SPLIT_REGEX);
                for (let ti = 0; ti < tokens.length; ti++) {
                    const tk = tokens[ti].trim();
                    if (tk.length > 1 || (tk.length === 1 && s.iscelldata && s.iscelldata(tk))) {
                        const rg = s.getcellrange(tk, T.index);
                        if (rg) ranges.push(rg);
                    }
                }
            }
            s.formulaCache[cacheKey] = ranges;
        }

        const node = {
            id: cellId, r: T.r, c: T.c, i: T.index,
            formula: rawFormula,
            ranges: ranges,
            dependents: [], // Who depends on me
            inDegree: 0,    // How many I depend on
            isTriggered: dirtySet.has(cellId)
        };
        nodes.set(cellId, node);

        // Add to Spatial Index
        if (!spatialIndex.has(T.index)) spatialIndex.set(T.index, new Map());
        const sheetRows = spatialIndex.get(T.index);
        if (!sheetRows.has(T.r)) sheetRows.set(T.r, []);
        sheetRows.get(T.r).push(node);
    }

    // --- PHASE 2: Graph Linkage (Spatial Optimization) ---
    
    for (const node of nodes.values()) {
        for (const rect of node.ranges) {
            const sheetRows = spatialIndex.get(rect.sheetIndex);
            if (!sheetRows) continue;

            for (let r = rect.row[0]; r <= rect.row[1]; r++) {
                const rowNodes = sheetRows.get(r);
                if (!rowNodes) continue;
                for (let k = 0; k < rowNodes.length; k++) {
                    const dependency = rowNodes[k];
                    if (dependency.id === node.id) continue; // Skip self
                    if (dependency.c >= rect.column[0] && dependency.c <= rect.column[1]) {
                        // Dependency -> Node (Dependency must finish for Node to start)
                        dependency.dependents.push(node);
                        node.inDegree++;
                    }
                }
            }
        }
    }

    // --- PHASE 3: Kahn's Algorithm (Topological Queue) ---
    const queue = [];
    // Start with all nodes that have 0 dependencies
    for (const node of nodes.values()) {
        if (node.inDegree === 0) queue.push(node);
    }

    const sortedOrder = [];
    let head = 0;
    while (head < queue.length) {
        const u = queue[head++];
        sortedOrder.push(u);

        for (const v of u.dependents) {
            v.inDegree--;
            if (v.inDegree === 0) queue.push(v);
        }
    }

    // --- PHASE 4: Reliable Execution ---
    window.luckysheet_getcelldata_cache = null;
    for (let i = 0; i < sortedOrder.length; i++) {
        const T = sortedOrder[i];
        
        // Reliability check: Only calculate if this cell OR one of its ancestors was dirty
        // Luckysheet usually handles "need-to-calc" flag via execfunction itself
        const Rres = s.execfunction(T.formula, T.r, T.c, T.i);
        
        s.groupValuesRefreshData.push({
            r: T.r, c: T.c, v: Rres[1], f: Rres[2], spe: Rres[3], index: T.i
        });
        s.execFunctionGlobalData[T.r + "_" + T.c + "_" + T.i] = { v: Rres[1], f: Rres[2] };
    }

    s.execFunctionExist = null;
}
