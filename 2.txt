getAllDependentSheetsFromSheet: function(sheetIndex, formulaOrValue) {
    if (!window.luckysheet_dependentsheets_cache) {
        window.luckysheet_dependentsheets_cache = {};
    }

    const allSheets = Ft() || [];
    const validSheetIndexes = new Set(allSheets.map(s => s.index));

    // Helper: recursively collect all dependents from cachedRefs
    function getRecursiveDependents(refIndexes) {
        const resultSet = new Set(refIndexes);
        const queue = [...refIndexes];

        while (queue.length > 0) {
            const current = queue.shift();
            const deps = window.luckysheet_dependentsheets_cache[current] || [];
            for (const dep of deps) {
                if (!resultSet.has(dep) && validSheetIndexes.has(dep)) {
                    resultSet.add(dep);
                    queue.push(dep);
                }
            }
        }

        return Array.from(resultSet).filter(idx => validSheetIndexes.has(idx));
    }

    // Step 1: If cache exists, expand recursively
    let cachedRefs = window.luckysheet_dependentsheets_cache[sheetIndex];
    if (cachedRefs && cachedRefs.length > 0) {
        // Filter invalid indexes
        cachedRefs = cachedRefs.filter(idx => validSheetIndexes.has(idx));

        // Expand recursively to include all indirect dependents
        const allDependents = getRecursiveDependents(cachedRefs.concat(sheetIndex));

        // Update cache for current sheet
        window.luckysheet_dependentsheets_cache[sheetIndex] = allDependents;

        // Update cache for sheets referenced in formulaOrValue
        if (formulaOrValue && typeof formulaOrValue === "string" && formulaOrValue.includes("!")) {
            const matches = formulaOrValue.matchAll(/(?:'([^']+)'|([A-Za-z0-9_]+))!/g);
            for (const match of matches) {
                const refSheetName = match[1] || match[2];
                const refSheet = allSheets.find(s => s.name === refSheetName);
                if (refSheet && refSheet.index !== sheetIndex) {
                    if (!window.luckysheet_dependentsheets_cache[refSheet.index]) {
                        window.luckysheet_dependentsheets_cache[refSheet.index] = [];
                    }
                    const depSet = new Set(window.luckysheet_dependentsheets_cache[refSheet.index]);
                    depSet.add(sheetIndex);
                    window.luckysheet_dependentsheets_cache[refSheet.index] = Array.from(depSet)
                        .filter(idx => validSheetIndexes.has(idx));
                }
            }
        }

        return allDependents;
    }

    // Step 2: Build dependency graph if cache doesn't exist
    const dependencyMap = new Map();
    for (const sheet of allSheets) {
        if (!sheet.data || !sheet.name) continue;

        const references = new Set();
        for (const row of sheet.data || []) {
            for (const cell of row || []) {
                if (!cell?.f) continue;
                for (const targetSheet of allSheets) {
                    if (!targetSheet.name || targetSheet.index === sheet.index) continue;
                    const refRegex = new RegExp(`(?:'${targetSheet.name}'|${targetSheet.name})!\\$?[A-Z]+\\$?\\d+(?::\\$?[A-Z]+\\$?\\d+)?`, 'g');
                    if (refRegex.test(cell.f)) {
                        references.add(targetSheet.index);
                    }
                }
            }
        }
        dependencyMap.set(sheet.index, references);
    }

    // Step 3: Traverse reverse dependencies
    const result = new Set([sheetIndex]);
    const queue = [sheetIndex];

    while (queue.length > 0) {
        const current = queue.shift();
        for (const [sheetIdx, refs] of dependencyMap.entries()) {
            if (refs.has(current) && !result.has(sheetIdx)) {
                result.add(sheetIdx);
                queue.push(sheetIdx);
            }
        }
    }

    // Step 4: Update caches for sheets referenced in formulaOrValue
    if (formulaOrValue && typeof formulaOrValue === "string" && formulaOrValue.includes("!")) {
        const matches = formulaOrValue.matchAll(/(?:'([^']+)'|([A-Za-z0-9_]+))!/g);
        for (const match of matches) {
            const refSheetName = match[1] || match[2];
            const refSheet = allSheets.find(s => s.name === refSheetName);
            if (refSheet && refSheet.index !== sheetIndex) {
                if (!window.luckysheet_dependentsheets_cache[refSheet.index]) {
                    window.luckysheet_dependentsheets_cache[refSheet.index] = [];
                }
                const depSet = new Set(window.luckysheet_dependentsheets_cache[refSheet.index]);
                depSet.add(sheetIndex);
                window.luckysheet_dependentsheets_cache[refSheet.index] = Array.from(depSet)
                    .filter(idx => validSheetIndexes.has(idx));
            }
        }
    }

    // Step 5: Update cache for current sheet and return
    const finalResult = Array.from(result).filter(idx => validSheetIndexes.has(idx));
    window.luckysheet_dependentsheets_cache[sheetIndex] = finalResult;

    return finalResult;
}
