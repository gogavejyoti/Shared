  INDEX: function () {
                if (arguments.length < this.m[0] || arguments.length > this.m[1])
                    return p.error.na;
                for (var e = 0; e < arguments.length; e++) {
                    var n = p.errorParamCheck(this.p, arguments[e], e);
                    if (!n[0])
                        return p.error.v
                }
                try {
                    var t = arguments[0]
                        , l = [];
                    let y = !1;
                    if (L(t) == "array") {
                        if (L(t[0]) == "array" && !M.isDyadicArr(t))
                            return p.error.v;
                        l = M.getDataDyadicArr(t)
                    } else
                        L(t) == "object" && t.startCell != null && (l = M.getCellDataDyadicArr(t, "number"),
                            y = !0);
                    var a = l.length
                        , o = l[0].length
                        , s = M.getFirstValue(arguments[1]);
                    if (H(s))
                        return s;
                    if (!B(s))
                        return p.error.v;
                    s = parseInt(s);
                    var u = M.getFirstValue(arguments[2]);
                    if (H(u))
                        return u;
                    if (s < 0 || B(u) && u < 0)
                        return p.error.v;
                    if (a == 1 && u == null && (u = s,
                        s = 1),
                        s > a || B(u) && u > o)
                        return p.error.r;
                    if (y) {
                        var d = p.getcellrange(t.startCell)
                            , f = d.row[0]
                            , m = d.column[0];
                        let v = l;
                        s == 0 || u == 0 ? (s == 0 ? (v = l[0],
                            s = 1) : v = l[s - 1],
                            B(u) ? u == 0 ? (v = v[0],
                                u = 1) : v = v[u - 1] : u = 1) : (B(s) || (s = 1),
                                    B(u) || (u = 1),
                                    v = l[s - 1][u - 1]);
                        let k = f + s - 1
                            , b = m + u - 1;
                        return {
                            sheetName: t.sheetName,
                            startCell: bt(h.calculateSheetIndex, {
                                row: [k, k],
                                column: [b, b]
                            }),
                            rowl: k,
                            coll: b,
                            data: v
                        }
                    } else
                        return B(u) ? (u = parseInt(u),
                            s <= 0 || u <= 0 ? p.error.v : l[s - 1][u - 1]) : p.error.v
                } catch (y) {
                    var g = y;
                    return g = p.errorInfo(g),
                        [p.error.v, g]
                }
            },
