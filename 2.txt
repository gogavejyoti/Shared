update: function () {
    const self = this;

    // ===============================
    // BASIC GUARDS
    // ===============================
    if (!gr([self.applyRange], h.currentSheetIndex) || h.allowEdit === false) {
        return;
    }

    const sheetIndex = h.currentSheetIndex;
    const sheet = h.luckysheetfile[K(sheetIndex)];
    const data = h.flowdata;

    // ===============================
    // CONFIG SETUP
    // ===============================
    const cfg = $.extend(true, {}, h.config);
    if (!cfg.merge) cfg.merge = {};
    if (!cfg.borderInfo) cfg.borderInfo = [];

    const borders = Ur();
    const dataVerification = $.extend(true, {}, sheet.dataVerification);

    const dir = self.direction;
    const srcRange = self.copyRange;
    const dstRange = self.applyRange;

    const src = {
        r1: srcRange.row[0],
        r2: srcRange.row[1],
        c1: srcRange.column[0],
        c2: srcRange.column[1]
    };

    const dst = {
        r1: dstRange.row[0],
        r2: dstRange.row[1],
        c1: dstRange.column[0],
        c2: dstRange.column[1]
    };

    const rowSpan = src.r2 - src.r1 + 1;
    const colSpan = src.c2 - src.c1 + 1;

    // Get template cells
    const copyData = self.getCopyData(
        data,
        src.r1, src.r2,
        src.c1, src.c2,
        dir
    );

    // Track all changed cells
    const dirtyCells = [];

    // ===============================
    // 1Ô∏è‚É£ COPY / SHIFT FORMULAS ONLY
    // (NO CALCULATION HERE)
    // ===============================
    for (let r = dst.r1; r <= dst.r2; r++) {
        for (let c = dst.c1; c <= dst.c2; c++) {

            // Source position (for border / validation mapping)
            const sr = src.r1 + (r - dst.r1) % rowSpan;
            const sc = src.c1 + (c - dst.c1) % colSpan;

            // Template cell
            let tpl;
            if (dir === "left" || dir === "right") {
                tpl = copyData[r - dst.r1][(c - dst.c1) % colSpan];
            } else {
                tpl = copyData[c - dst.c1][(r - dst.r1) % rowSpan];
            }

            if (!tpl) continue;

            const cell = tpl;

            // Shift formula text ONLY
            if (cell.f != null) {
                const shiftIndex =
                    (dir === "left" || dir === "right")
                        ? (c - dst.c1) + 1
                        : (r - dst.r1) + 1;

                cell.f = "=" + p.functionCopy(cell.f, dir, shiftIndex);
                cell.v = null;
                cell.m = null;
            }

            data[r][c] = cell;
            dirtyCells.push({ r, c, index: sheetIndex });

            // Borders
            if (borders[sr + "_" + sc]) {
                cfg.borderInfo.push({
                    rangeType: "cell",
                    value: {
                        row_index: r,
                        col_index: c,
                        ...borders[sr + "_" + sc]
                    }
                });
            }

            // Data validation
            if (dataVerification[sr + "_" + sc]) {
                dataVerification[r + "_" + c] =
                    dataVerification[sr + "_" + sc];
            }
        }
    }

    // ===============================
    // 2Ô∏è‚É£ SINGLE DEPENDENCY BUILD
    // ===============================
    window.luckysheet_getcelldata_cache = null;
    p.groupValuesRefreshData = [];

    // Build dependency graph ONCE + topo evaluate
    p.execFunctionGroup(
        null,
        null,
        null,
        sheetIndex,
        data,
        true
    );

    // ===============================
    // 3Ô∏è‚É£ APPLY CALCULATED VALUES
    // ===============================
    if (p.groupValuesRefreshData && p.groupValuesRefreshData.length > 0) {
        for (let i = 0; i < p.groupValuesRefreshData.length; i++) {
            const g = p.groupValuesRefreshData[i];
            const cell = data[g.r][g.c];
            if (!cell) continue;

            cell.v = g.v;
            cell.f = g.f;

            // Special types (sparklines / dynamic arrays)
            if (g.spe) {
                cell.spl = g.spe.data;
            }

            // Display formatting
            const V = it(g.v);
            cell.m = V[0].toString();
            cell.ct = V[1];
        }
        p.groupValuesRefreshData.length = 0;
    }

    // ===============================
    // 4Ô∏è‚É£ FINAL UI REFRESH (IMPORTANT)
    // ===============================
    const conditionFormat = $.extend(
        true,
        [],
        sheet.luckysheet_conditionformat_save
    );

    // üî¥ MUST use applyRange, NOT luckysheet_select_save
    Ye(data, [self.applyRange], {
        cfg,
        cdformat: conditionFormat,
        dataVerification
    });

    tt(); // final repaint
}
