function setupStickyColumns($table, $wrapper) {
    // Compute widths of first & second columns from first header row
    const $firstTh = $table.find('thead tr').first().find('th').first();
    const $secondTh = $table.find('thead tr').first().find('th').eq(1);

    // Fallback widths if not measured
    const firstWidth = $firstTh.length ? $firstTh.outerWidth() : 140;
    const secondWidth = $secondTh.length ? $secondTh.outerWidth() : 150;

    // Apply left offsets and min-widths for sticky-1 and sticky-2 in body cells
    $table.find('.sticky-1').each(function () {
        $(this).css({ left: 0, 'min-width': firstWidth + 'px' });
    });
    $table.find('.sticky-2').each(function () {
        $(this).css({ left: firstWidth + 'px', 'min-width': secondWidth + 'px' });
    });

    // Make first 2 columns sticky horizontally in all header rows
    $table.find('thead tr').each(function () {
        $(this).find('th').each(function (idx) {
            if (idx === 0) {
                $(this).css({
                    position: 'sticky',
                    left: 0,
                    'min-width': firstWidth + 'px',
                    'z-index': 1100, // higher than body cells
                    background: '#f5f5f5',
                });
            } else if (idx === 1) {
                $(this).css({
                    position: 'sticky',
                    left: firstWidth + 'px',
                    'min-width': secondWidth + 'px',
                    'z-index': 1100,
                    background: '#f5f5f5',
                });
            }
        });
    });

    // Freeze all header rows vertically with cumulative top offset
    let topOffset = 0;
    $table.find('thead tr').each(function (index) {
        const rowHeight = $(this).outerHeight();

        $(this).find('th').css({
            position: 'sticky',
            top: topOffset + 'px',
            'z-index': 100 + index,  // stacking order between header rows
            background: '#f5f5f5',
        });

        topOffset += rowHeight;
    });

    // Recompute on resize (debounced)
    clearTimeout(window.__vcResizeTimer);
    window.__vcResizeTimer = setTimeout(function () {
        const newFirstW = $firstTh.length ? $firstTh.outerWidth() : firstWidth;
        const newSecondW = $secondTh.length ? $secondTh.outerWidth() : secondWidth;

        // Update body sticky columns widths
        $table.find('.sticky-1').css({ 'min-width': newFirstW + 'px' });
        $table.find('.sticky-2').css({ 'min-width': newSecondW + 'px', left: newFirstW + 'px' });

        // Update sticky header columns widths and left offsets for all header rows
        $table.find('thead tr').each(function () {
            $(this).find('th').each(function (idx) {
                if (idx === 0) {
                    $(this).css({
                        left: 0,
                        'min-width': newFirstW + 'px',
                    });
                } else if (idx === 1) {
                    $(this).css({
                        left: newFirstW + 'px',
                        'min-width': newSecondW + 'px',
                    });
                }
            });
        });

        // Reapply sticky header top offsets on resize
        let newTopOffset = 0;
        $table.find('thead tr').each(function (index) {
            const rowHeight = $(this).outerHeight();

            $(this).find('th').css({
                top: newTopOffset + 'px',
            });

            newTopOffset += rowHeight;
        });
    }, 100);
}
