private static List<float> ForecastHoltLinear(List<float> values, int forecastHorizon)
{
    if (values == null || values.Count == 0)
        return Enumerable.Repeat(0f, forecastHorizon).ToList();

    // Remove invalids
    values = values.Where(v => v >= 0f).ToList();

    // Remove trailing zeros
    values = values.Reverse<float>().SkipWhile(v => v == 0f).Reverse().ToList();

    // If after cleaning we have no values, return zeros
    if (!values.Any())
        return Enumerable.Repeat(0f, forecastHorizon).ToList();

    float minVal = values.Min();
    float maxVal = values.Max();

    int n = values.Count;

    // If less than 2 points, repeat last value safely
    if (n < 2)
    {
        float lastVal = values.Last(); // safe because values.Any() is true
        return Enumerable.Repeat(lastVal, forecastHorizon).ToList();
    }

    // Holt Linear parameters
    double alpha = 0.5;
    double beta = 0.3;

    // Initialize level and trend
    double level = values[0];
    double trend = values[1] - values[0];

    for (int i = 1; i < n; i++)
    {
        double prevLevel = level;
        level = alpha * values[i] + (1 - alpha) * (level + trend);
        trend = beta * (level - prevLevel) + (1 - beta) * trend;
    }

    // Forecast
    var forecast = new List<float>();
    for (int h = 1; h <= forecastHorizon; h++)
    {
        double val = level + h * trend;
        val = Math.Max(minVal, Math.Min(maxVal, val)); // clamp
        forecast.Add((float)val);
    }

    return forecast;
}
