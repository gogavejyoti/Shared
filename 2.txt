                    $("#luckysheet-icon-excel").click(async function () {
                        try {
                            // --- Helpers ---
                            function hexToARGB(color) {
                                if (!color) return undefined;
                                if (color.startsWith("rgb")) {
                                    const nums = color.match(/\d+/g).map(Number);
                                    const [r, g, b] = nums;
                                    return "FF" + [r, g, b].map(n => n.toString(16).padStart(2, "0")).join("").toUpperCase();
                                }
                                let hex = color.replace("#", "");
                                if (hex.length === 3) hex = hex.split("").map(h => h + h).join("");
                                if (!/^[0-9A-Fa-f]{6}$/.test(hex)) {
                                    console.warn("Invalid HEX color:", color);
                                    return undefined;
                                }
                                return "FF" + hex.toUpperCase();
                            }

                            function pxToExcelWidth(px) {
                                if (!px) return 10;
                                return Math.max(3, Math.round(px / 7));
                            }

                            function normalizeFormula(formula, sheetNames) {
                                if (!formula) return formula;
                                sheetNames.forEach(name => {
                                    if (/\s/.test(name) && formula.includes(name + "!")) {
                                        const re = new RegExp(name.replace(/[-\/\\^$*+?.()|[\]{ }]/g, '\\$&') + '!', 'g');
                                        formula = formula.replace(re, `'${name}'!`);
                                    }
                                });
                                return formula;
                            }

                            const sheets = luckysheet.getAllSheets();
                            const workbook = new ExcelJS.Workbook();
                            workbook.creator = "LuckySheet";
                            workbook.created = new Date();
                            const sheetNames = sheets.map(s => s.name || 'Sheet');

                            for (let si = 0; si < sheets.length; si++) {
                                const sheet = sheets[si];
                                const ws = workbook.addWorksheet(sheet.name || `Sheet${si + 1}`);
                                const data = sheet.data || [];

                                // ðŸ”¹ Column widths (set per column; avoids resetting column props)
                                if (sheet.config?.columnlen) {
                                    for (const [colIndex, px] of Object.entries(sheet.config.columnlen)) {
                                        ws.getColumn(Number(colIndex) + 1).width = pxToExcelWidth(px);
                                    }
                                }

                                // ðŸ”¹ Fill cell data
                                for (let r = 0; r < data.length; r++) {
                                    const row = data[r] || [];
                                    for (let c = 0; c < row.length; c++) {
                                        const cell = row[c];
                                        if (!cell) continue;
                                        const cellRef = ws.getCell(r + 1, c + 1);

                                        // --- Normalize numeric, percentage, and date-like values ---
                                        if (!cell.f && cell.v !== null && cell.v !== undefined) {
                                            let val = cell.v;
                                            const strVal = String(val).trim();

                                            // Percentage "12%" â†’ 0.12
                                            if (/^-?\d+(\.\d+)?%$/.test(strVal)) {
                                                const num = parseFloat(strVal.replace('%', ''));
                                                cell.v = num / 100;
                                                cell.ct = cell.ct || {};
                                                cell.ct.fa = "0.00%";
                                            }
                                            // Numeric string â†’ number
                                            else if (/^-?\d+(\.\d+)?$/.test(strVal)) {
                                                cell.v = parseFloat(strVal);
                                            }
                                            // Date-like strings â†’ keep as text to avoid TZ shift
                                            else if (
                                                /^\d{4}[-/]\d{2}[-/]\d{2}$/.test(strVal) ||           // 2025-08-20 / 2025/08/20
                                                /^[0-9]{1,2}-[A-Za-z]{3}-[0-9]{2,4}$/.test(strVal)    // 02-Mar-25 / 02-Mar-2025
                                            ) {
                                                cell.v = strVal;
                                                cell.ct = cell.ct || {};
                                                cell.ct.fa = "@"; // Excel text format
                                            }
                                        }

                                        // --- Value / Formula
                                        if (cell.f) {
                                            let f = normalizeFormula(cell.f, sheetNames);
                                            if (f.startsWith('=')) f = f.slice(1); // see note (2) below
                                            // Fix common mis-name: MINIF -> MINIFS
                                            f = f.replace(/\bMINIF\b/gi, 'MINIFS');

                                            cellRef.value = { formula: f, result: cell.v ?? null };

                                        } else {
                                            cellRef.value = cell.v ?? null;
                                        }

                                        // --- Font
                                        if (cell.fc || cell.bl || cell.it || cell.ff || cell.fs) {
                                            cellRef.font = {};
                                            if (cell.fc) cellRef.font.color = { argb: hexToARGB(cell.fc) };
                                            if (cell.bl) cellRef.font.bold = true;
                                            if (cell.it) cellRef.font.italic = true;
                                            if (cell.ff) cellRef.font.name = cell.ff;
                                            if (cell.fs) cellRef.font.size = Number(cell.fs);
                                        }

                                        // --- Fill
                                        if (cell.bg) {
                                            cellRef.fill = {
                                                type: 'pattern',
                                                pattern: 'solid',
                                                fgColor: { argb: hexToARGB(cell.bg) }
                                            };
                                        }

                                        // --- Alignment
                                        if (cell.ht || cell.vt || cell.tb) {
                                            cellRef.alignment = {};
                                            if (cell.ht) cellRef.alignment.horizontal = cell.ht;
                                            if (cell.vt) cellRef.alignment.vertical = cell.vt;
                                            if (cell.tb) cellRef.alignment.wrapText = cell.tb === 2;
                                        }

                                        // --- Border
                                        if (cell.border) {
                                            const border = {};
                                            for (const [side, val] of Object.entries(cell.border)) {
                                                if (val?.color) {
                                                    border[side] = {
                                                        style: 'thin',
                                                        color: { argb: hexToARGB(val.color) }
                                                    };
                                                }
                                            }
                                            cellRef.border = border;
                                        }

                                        // --- Number format
                                        if (cell.ct?.fa) {
                                            const fmt = cell.ct.fa;
                                            const val = cell.v;
                                            if (typeof val === "number") {
                                                cellRef.numFmt = fmt;
                                            } else if (typeof val === "string" && fmt === "@") {
                                                cellRef.numFmt = "@";
                                            }
                                        }
                                    }
                                }

                                // ðŸ”¹ Merged cells
                                if (sheet.config?.merge) {
                                    Object.values(sheet.config.merge).forEach(m => {
                                        if (m) {
                                            try {
                                                ws.mergeCells(
                                                    m.r + 1,
                                                    m.c + 1,
                                                    m.r + (m.rowspan || 1),
                                                    m.c + (m.colspan || 1)
                                                );
                                            } catch (e) {
                                                console.warn("Merge skipped:", e);
                                            }
                                        }
                                    });
                                }

                                // ðŸ”¹ Row heights
                                if (sheet.config?.rowlen) {
                                    Object.entries(sheet.config.rowlen).forEach(([k, px]) => {
                                        ws.getRow(Number(k) + 1).height = Math.round(px / 1.3333);
                                    });
                                }

                                // ðŸ”¹ Visibility (INLINE): export hidden columns/rows as hidden
                                // Luckysheet keeps hidden indices in config.colhidden / rowhidden (0-based) â†’ ExcelJS .hidden flags (1-based)
                                if (sheet.config?.colhidden) {
                                    Object.keys(sheet.config.colhidden).forEach(k => {
                                        ws.getColumn(Number(k) + 1).hidden = true; // ExcelJS preserves hidden state on open
                                    });
                                }
                                if (sheet.config?.rowhidden) {
                                    Object.keys(sheet.config.rowhidden).forEach(k => {
                                        ws.getRow(Number(k) + 1).hidden = true;
                                    });
                                }

                                // ðŸ”¹ Hide whole sheet if Luckysheet marks it hidden
                                if (sheet.hide === 1) {
                                    ws.state = 'hidden';
                                }
                            }

                            // ðŸ”¹ Save as Excel

                            const activeIndex = sheets.findIndex(s => s.status === 1) || 0;


                            // Set the workbookâ€™s active tab (focus) to match
                            if (activeIndex >= 0) {
                                workbook.views = [{
                                    x: 0, y: 0, width: 10000, height: 20000,
                                    firstSheet: activeIndex,     // optional
                                    activeTab: activeIndex,     // <-- sets focus/tab selected on open
                                    visibility: 'visible'
                                }];
                            }



                            const buf = await workbook.xlsx.writeBuffer();
                            const fileName = (h.exportFileName || 'Export') + '.xlsx';
                            saveAs(new Blob([buf], { type: "application/octet-stream" }), fileName);
                        } catch (err) {
                            console.error("âŒ Export failed:", err);
                            alert("Export failed. See console for details.");
                        }
                    }),
