update: function () {
    let e = this;
    if (!gr([e.applyRange], h.currentSheetIndex) || h.allowEdit === !1) return;

    let n = we.deepCopyFlowData(h.flowdata),
        t = h.luckysheetfile[K(h.currentSheetIndex)],
        l = $.extend(!0, {}, h.config),
        a = Ur(),
        o = $.extend(!0, {}, t.dataVerification),
        s = e.direction,
        d = e.copyRange,
        f = d.row[0],
        m = d.row[1],
        g = d.column[0],
        y = d.column[1],
        v = e.getCopyData(n, f, m, g, y, s),
        k;

    s === "down" || s === "up"
        ? k = m - f + 1
        : k = y - g + 1;

    let b = e.applyRange,
        w = b.row[0],
        x = b.row[1],
        C = b.column[0],
        S = b.column[1];

    /* ================= LOCAL DEPENDENCY HELPERS ================= */

    function getLocalDeps(formula) {
        if (!formula) return [];
        const deps = [];
        const re = /([A-Z]+)(\d+)/g;
        let mm;
        while ((mm = re.exec(formula)) !== null) {
            const rr = parseInt(mm[2], 10) - 1;
            const cc = cl(mm[1]);
            if (rr >= w && rr <= x && cc >= C && cc <= S) {
                deps.push(rr + "_" + cc);
            }
        }
        return deps;
    }

    function topoSort(cells) {
        const nodeMap = {};
        const depMap = {};
        const visited = {};
        const visiting = {};
        const ordered = [];

        cells.forEach(c => {
            const key = c.r + "_" + c.c;
            nodeMap[key] = c;
            depMap[key] = getLocalDeps(c.D.f);
        });

        function dfs(key) {
            if (visited[key]) return;
            if (visiting[key]) return;
            visiting[key] = true;
            (depMap[key] || []).forEach(d => {
                if (nodeMap[d]) dfs(d);
            });
            visiting[key] = false;
            visited[key] = true;
            ordered.push(nodeMap[key]);
        }

        Object.keys(nodeMap).forEach(dfs);
        return ordered;
    }

    /* ================= MAIN LOGIC ================= */

    if (s === "right" || s === "left") {
        let A = S - C + 1;

        for (let R = w; R <= x; R++) {
            let I = v[R - w],
                F = e.getApplyData(I, k, A);

            const execCells = [];

            if (s === "right") {
                for (let N = C; N <= S; N++) {
                    let D = F[N - C];
                    n[R][N] = D;
                    if (D && D.f != null) {
                        execCells.push({ r: R, c: N, D: D, off: N - C + 1 });
                    }
                }
            } else {
                for (let N = S; N >= C; N--) {
                    let D = F[S - N];
                    n[R][N] = D;
                    if (D && D.f != null) {
                        execCells.push({ r: R, c: N, D: D, off: S - N + 1 });
                    }
                }
            }

            const ordered = topoSort(execCells);

            ordered.forEach(ti => {
                let z = "=" + p.functionCopy(ti.D.f, s, ti.off),
                    O = p.execfunction(z, ti.r, ti.c);

                p.execFunctionGroup(ti.r, ti.c, O[1], void 0, n);
                ti.D.f = O[2];
                ti.D.v = O[1];
            });
        }
    }

    if (s === "down" || s === "up") {
        let A = x - w + 1;

        for (let R = C; R <= S; R++) {
            let I = v[R - C],
                F = e.getApplyData(I, k, A);

            const execCells = [];

            if (s === "down") {
                for (let N = w; N <= x; N++) {
                    let D = F[N - w];
                    n[N][R] = D;
                    if (D && D.f != null) {
                        execCells.push({ r: N, c: R, D: D, off: N - w + 1 });
                    }
                }
            } else {
                for (let N = x; N >= w; N--) {
                    let D = F[x - N];
                    n[N][R] = D;
                    if (D && D.f != null) {
                        execCells.push({ r: N, c: R, D: D, off: x - N + 1 });
                    }
                }
            }

            const ordered = topoSort(execCells);

            ordered.forEach(ti => {
                let z = "=" + p.functionCopy(ti.D.f, s, ti.off),
                    O = p.execfunction(z, ti.r, ti.c);

                p.execFunctionGroup(ti.r, ti.c, O[1], void 0, n);
                ti.D.f = O[2];
                ti.D.v = O[1];
            });
        }
    }

    /* ================= FINAL UI ================= */

    let _ = $.extend(!0, [], t.luckysheet_conditionformat_save);
    let T = { cfg: l, cdformat: _, dataVerification: o };
    Ye(n, h.luckysheet_select_save, T);
    tt();
}
