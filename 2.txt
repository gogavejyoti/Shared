execFunctionGroup: function (e, n, t, l, a, o = !1) {

    if (o) return;
    const s = this;

    if (a == null) a = h.flowdata;
    if (l == null) l = h.currentSheetIndex;

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (!s.lookupRuntimeState) s.lookupRuntimeState = {}; // ★ LOOKUP CHANGE

    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    if (typeof _shiftCrossSheetReference === "function") {
        _shiftCrossSheetReference({ type: "recalc", sheetIndex: l });
    }

    let allFuncCells = [];
    let sheetIndices = null;

    if (e != null && n != null) {
        sheetIndices = s.getAllDependentSheetsFromSheet(l);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    const nodes = {};
    const rangeToKeysCache = {};

    function keysForRange(R) {
        const key = `r${R.row[0]}_${R.row[1]}_c${R.column[0]}_${R.column[1]}_i${R.sheetIndex}`;
        if (rangeToKeysCache[key]) return rangeToKeysCache[key];
        const arr = [];
        for (let r = R.row[0]; r <= R.row[1]; r++) {
            for (let c = R.column[0]; c <= R.column[1]; c++) {
                arr.push({ key: `r${r}c${c}i${R.sheetIndex}`, r, c, sheetIndex: R.sheetIndex });
            }
        }
        rangeToKeysCache[key] = arr;
        return arr;
    }

    const fmrSplit = /==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/;
    const lookupRegex = /(VLOOKUP|HLOOKUP)\s*\(([^)]+)\)/ig; // ★ LOOKUP CHANGE

    // -------------------------------
    // Build nodes
    // -------------------------------
    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const nodeKey = `r${T.r}c${T.c}i${T.index}`;
        const R = zl(T.r, T.c, T.index)
            || ve.getSheetByIndex(T.index)?.celldata?.find(x => x?.r === T.r && x?.c === T.c)?.v?.f;

        if (!R) continue;

        const formulaRanges = [];
        const lookupStates = [];

        if (!(R.startsWith('="') && R.endsWith('"'))) {

            // ---- static refs ----
            const tokens = R.split(fmrSplit).filter(Boolean);
            for (let tk of tokens) {
                tk = tk.trim();
                const rg = s.getcellrange(tk, T.index);
                if (rg) formulaRanges.push(rg);
            }

            // ★ LOOKUP CHANGE: extract lookup calls
            let m, idx = 0;
            while ((m = lookupRegex.exec(R)) !== null) {
                const args = m[2].split(",");
                if (args.length >= 2) {
                    const keyRange = s.getcellrange(args[0].trim(), T.index);
                    if (keyRange) {
                        lookupStates.push({
                            id: `${nodeKey}_L${idx++}`,
                            keyRange,
                            lastParents: new Set()
                        });
                    }
                }
            }
        }

        nodes[nodeKey] = {
            key: nodeKey,
            r: T.r,
            c: T.c,
            index: T.index,
            calc_funcStr: R,
            formulaArray: formulaRanges,
            lookupStates,               // ★ LOOKUP CHANGE
            parents: {},
            chidren: {},
            color: "w"
        };

        // ★ store lookup state
        if (lookupStates.length) {
            s.lookupRuntimeState[nodeKey] = lookupStates;
        }
    }

    // -------------------------------
    // Build dependency graph
    // -------------------------------
    const execSet = {};
    execSet[`r${e}c${n}i${l}`] = 1;

    const y = [];
    for (const k in nodes) {
        const node = nodes[k];

        // static dependencies
        for (const rg of node.formulaArray) {
            for (const c of keysForRange(rg)) {
                if (nodes[c.key]) {
                    node.chidren[c.key] = 1;
                    nodes[c.key].parents[node.key] = 1;
                }
                if (c.key in execSet) y.push(node);
            }
        }

        // ★ LOOKUP CHANGE: key cell dependency only
        for (const ls of node.lookupStates) {
            const kr = ls.keyRange;
            const keyCell = `r${kr.row[0]}c${kr.column[0]}i${kr.sheetIndex}`;
            node.parents[keyCell] = 1;
            if (nodes[keyCell]) nodes[keyCell].chidren[node.key] = 1;
            if (keyCell in execSet) y.push(node);
        }
    }

    // -------------------------------
    // Topological sort (unchanged)
    // -------------------------------
    const visited = {};
    const ordered = [];
    const stack = y.slice();

    while (stack.length) {
        const cur = stack.pop();
        if (!cur || visited[cur.key]) continue;

        if (cur.color === "b") {
            visited[cur.key] = 1;
            ordered.push(cur);
            continue;
        }

        cur.color = "b";
        stack.push(cur);

        for (const pk in cur.parents) {
            if (nodes[pk]) stack.push(nodes[pk]);
        }
    }

    ordered.reverse();

    // -------------------------------
    // Execute + dynamic lookup rewiring
    // -------------------------------
    for (const T of ordered) {

        window.luckysheet_getcelldata_cache = null;
        const Rres = s.execfunction(T.calc_funcStr, T.r, T.c, T.index);

        s.execFunctionGlobalData[`${T.r}_${T.c}_${T.index}`] = {
            v: Rres[1],
            f: Rres[2]
        };

        s.groupValuesRefreshData.push({
            r: T.r, c: T.c, v: Rres[1], f: Rres[2], spe: Rres[3], index: T.index
        });

        // ★ LOOKUP CHANGE: rewire parents
        const lStates = s.lookupRuntimeState[T.key] || [];
        for (const ls of lStates) {

            // remove old parents
            for (const p of ls.lastParents) {
                delete T.parents[p];
                if (nodes[p]) delete nodes[p].chidren[T.key];
            }

            ls.lastParents.clear();

            // discover new parents (from exec result metadata)
            if (Rres[4]?.lookupParents) {
                for (const p of Rres[4].lookupParents) {
                    T.parents[p] = 1;
                    if (nodes[p]) nodes[p].chidren[T.key] = 1;
                    ls.lastParents.add(p);
                }
            }
        }
    }

    s.execFunctionExist = null;
}
