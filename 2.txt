execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;
    const s = this;

    if (a == null) a = h.flowdata;

    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    // explicit value injection
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // --------------------------------------------------
    // COLLECT AFFECTED FORMULAS
    // --------------------------------------------------
    let allFuncCells = [];
    let sheetIndices = null;

    if (e != null && n != null) {
        sheetIndices = s.getAllDependentSheetsFromSheet(l, null);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    // --------------------------------------------------
    // EXECUTION TRIGGERS
    // --------------------------------------------------
    const execSet = {};
    if (s.execFunctionExist == null) {
        execSet["r" + e + "c" + n + "i" + l] = 1;
    } else {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const T = s.execFunctionExist[i];
            execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
        }
    }

    // --------------------------------------------------
    // BUILD FORMULA NODES
    // --------------------------------------------------
    const nodes = {};

    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const key = "r" + T.r + "c" + T.c + "i" + T.index;

        const formula =
            zl(T.r, T.c, T.index) ||
            ve.getSheetByIndex(T.index)?.celldata?.find(
                x => x?.r === T.r && x?.c === T.c
            )?.v?.f;

        if (!formula) continue;

        nodes[key] = {
            key,
            r: T.r,
            c: T.c,
            index: T.index,
            calc_funcStr: formula,
            parents: {},
            children: {},
            rangeRefs: [],
            color: 0 // 0=unvisited,1=visiting,2=done
        };

        const upper = formula.toUpperCase();
        const dynamic =
            upper.includes("INDIRECT(") ||
            upper.includes("OFFSET(") ||
            upper.includes("INDEX(");

        if (dynamic) {
            s.isFunctionRange(formula, null, null, T.index, null, ref => {
                const rg = s.getcellrange($.trim(ref), T.index);
                if (rg) nodes[key].rangeRefs.push(rg);
            });
        } else {
            const tokens = formula.split(/==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/).filter(Boolean);
            for (let ti = 0; ti < tokens.length; ti++) {
                const rg = s.getcellrange(tokens[ti].trim(), T.index);
                if (rg) nodes[key].rangeRefs.push(rg);
            }
        }
    }

    // --------------------------------------------------
    // FORMULA-TO-FORMULA DEPENDENCY (SAFE, NO CYCLES)
    // --------------------------------------------------
    for (const k in nodes) {
        const node = nodes[k];

        for (const ok in nodes) {
            if (ok === k) continue; // ðŸ”’ no self dependency
            const other = nodes[ok];

            for (let ri = 0; ri < node.rangeRefs.length; ri++) {
                const R = node.rangeRefs[ri];
                if (
                    other.index === R.sheetIndex &&
                    other.r >= R.row[0] && other.r <= R.row[1] &&
                    other.c >= R.column[0] && other.c <= R.column[1]
                ) {
                    node.parents[other.key] = 1;
                    other.children[node.key] = 1;
                }
            }
        }
    }

    // --------------------------------------------------
    // SELECT START NODES (TRIGGER + RANGE HIT)
    // --------------------------------------------------
    const startNodes = [];
    const changedKey = "r" + e + "c" + n + "i" + l;

    for (const k in nodes) {
        const node = nodes[k];

        if (execSet[changedKey]) {
            startNodes.push(node);
            continue;
        }

        for (let ri = 0; ri < node.rangeRefs.length; ri++) {
            const R = node.rangeRefs[ri];
            if (
                R.sheetIndex === l &&
                e >= R.row[0] && e <= R.row[1] &&
                n >= R.column[0] && n <= R.column[1]
            ) {
                startNodes.push(node);
                break;
            }
        }
    }

    // --------------------------------------------------
    // TOPOLOGICAL SORT (CYCLE SAFE)
    // --------------------------------------------------
    const ordered = [];
    const stack = startNodes.slice();

    while (stack.length) {
        const cur = stack.pop();
        if (!cur) continue;

        if (cur.color === 2) continue;
        if (cur.color === 1) {
            cur.color = 2;
            ordered.push(cur);
            continue;
        }

        cur.color = 1;
        stack.push(cur);

        for (const pk in cur.parents) {
            if (nodes[pk]) stack.push(nodes[pk]);
        }
    }

    ordered.reverse();

    // --------------------------------------------------
    // EXECUTE FORMULAS (CORRECT + FAST)
    // --------------------------------------------------
    window.luckysheet_getcelldata_cache = null;

    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];

        const Rres = s.execfunction(
            T.calc_funcStr,
            T.r,
            T.c,
            T.index
        );

        // invalidate cache AFTER value update
        window.luckysheet_getcelldata_cache = null;

        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: Rres[1],
            f: Rres[2],
            spe: Rres[3],
            index: T.index
        });

        s.execFunctionGlobalData[T.r + "_" + T.c + "_" + T.index] = {
            v: Rres[1],
            f: Rres[2]
        };
    }

    s.execFunctionExist = null;
},
