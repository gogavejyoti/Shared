function buildWeightedMetricsTable(data, containerId, drillMode = "GeoToLob", viewMode = "Monthly") {
    const container = document.querySelector("#" + containerId);
    container.innerHTML = '';

    // Determine period key
    const timeKey = viewMode === "Weekly" ? "weekFormat" : "monthFormat";

    // Collect and sort periods
    const periods = [...new Set(data.map(d => d[timeKey]).filter(x => x))]
        .map(p => ({ period: p, date: new Date(p) }))
        .sort((a, b) => a.date - b.date)
        .map(x => x.period);

    // Dropdowns
    const topRow = document.createElement('div');
    topRow.style.marginBottom = '8px';

    const drillSelector = document.createElement("select");
    drillSelector.className = "form-select d-inline-block me-2";
    drillSelector.style.width = "180px";
    ["GeoToLob", "LobToGeo"].forEach(mode => {
        const opt = document.createElement("option");
        opt.value = mode;
        opt.innerText = mode === "GeoToLob" ? "Geo → LOB" : "LOB → Geo";
        if (mode === drillMode) opt.selected = true;
        drillSelector.appendChild(opt);
    });

    const viewSelector = document.createElement("select");
    viewSelector.className = "form-select d-inline-block";
    viewSelector.style.width = "140px";
    ["Weekly", "Monthly"].forEach(mode => {
        const opt = document.createElement("option");
        opt.value = mode;
        opt.innerText = mode;
        if (mode === viewMode) opt.selected = true;
        viewSelector.appendChild(opt);
    });

    drillSelector.addEventListener("change", () => {
        buildWeightedMetricsTable(data, containerId, drillSelector.value, viewSelector.value);
    });
    viewSelector.addEventListener("change", () => {
        buildWeightedMetricsTable(data, containerId, drillSelector.value, viewSelector.value);
    });

    topRow.appendChild(drillSelector);
    topRow.appendChild(viewSelector);
    container.appendChild(topRow);

    // Groups
    const groups = drillMode === "GeoToLob"
        ? [...new Set(data.map(d => d.geo))]
        : [...new Set(data.map(d => d.lob))];

    // Table
    const table = document.createElement('table');
    table.className = 'table table-bordered table-hover';
    table.style.minWidth = (Math.max(1, periods.length) * 120 + 160) + 'px';

    // Header rows
    const thead = document.createElement('thead');
    const tr1 = document.createElement('tr');
    const thGroup = document.createElement('th');
    thGroup.rowSpan = 2;
    thGroup.innerText = drillMode === "GeoToLob" ? "Geo" : "LOB";
    tr1.appendChild(thGroup);

    periods.forEach(p => {
        const th = document.createElement('th');
        th.colSpan = 5;
        th.innerText = p;
        tr1.appendChild(th);
    });
    thead.appendChild(tr1);

    const tr2 = document.createElement('tr');
    periods.forEach(() => {
        ['Planned Shr.', 'Actual Shr.', 'Planned Attr.', 'Actual Attr.', 'OTF %'].forEach(h => {
            const th = document.createElement('th');
            th.innerText = h;
            th.setAttribute('nowrap', '');
            tr2.appendChild(th);
        });
    });
    thead.appendChild(tr2);
    table.appendChild(thead);

    // Body
    const tbody = document.createElement('tbody');

    // Overall Summary row
    const trSummary = document.createElement("tr");
    trSummary.className = "table-primary fw-bold";
    const tdSummary = document.createElement("td");
    tdSummary.innerText = "Overall Summary";
    trSummary.appendChild(tdSummary);

    periods.forEach(period => {
        const recs = data.filter(d => d[timeKey] === period);
        const denominator = recs.reduce((s, r) => s + (r.availableHC || 0), 0);

        const plannedShrink = denominator ? Math.round(recs.reduce((s, r) => s + ((r.availableHC || 0) * (r.plannedShrinkage || 0)), 0) / denominator) : 0;
        const actualShrink = denominator ? Math.round(recs.reduce((s, r) => s + ((r.availableHC || 0) * (r.actualShrinkage || 0)), 0) / denominator) : 0;
        const plannedAttr = denominator ? Math.round(recs.reduce((s, r) => s + ((r.availableHC || 0) * (r.plannedAttrition || 0)), 0) / denominator) : 0;
        const actualAttr = denominator ? Math.round(recs.reduce((s, r) => s + ((r.availableHC || 0) * (r.actualAttrition || 0)), 0) / denominator) : 0;

        const totalForecasted = recs.reduce((s, r) => s + (r.forecastedHours || 0), 0);
        const totalActual = recs.reduce((s, r) => s + (r.actualHours || 0), 0);
        const otf = totalActual ? Math.round((totalForecasted / totalActual) * 100) : 0;

        [plannedShrink, actualShrink, plannedAttr, actualAttr, otf].forEach((val, i) => {
            const td = document.createElement("td");
            td.innerText = val + (i < 4 ? "%" : "%");
            td.style.fontWeight = "500";
            trSummary.appendChild(td);
        });
    });
    tbody.appendChild(trSummary);

    // Drilldown rows
    groups.forEach(group => {
        const tr = document.createElement('tr');
        tr.className = 'groupRow';
        tr.style.cursor = 'pointer';
        const tdGroup = document.createElement('td');
        tdGroup.innerText = group;
        tr.appendChild(tdGroup);

        periods.forEach(period => {
            const recs = data.filter(d =>
                (drillMode === "GeoToLob" ? d.geo === group : d.lob === group) &&
                d[timeKey] === period
            );

            const denominator = recs.reduce((s, r) => s + (r.availableHC || 0), 0);
            const plannedShrink = denominator ? Math.round(recs.reduce((s, r) => s + ((r.availableHC || 0) * (r.plannedShrinkage || 0)), 0) / denominator) : 0;
            const actualShrink = denominator ? Math.round(recs.reduce((s, r) => s + ((r.availableHC || 0) * (r.actualShrinkage || 0)), 0) / denominator) : 0;
            const plannedAttr = denominator ? Math.round(recs.reduce((s, r) => s + ((r.availableHC || 0) * (r.plannedAttrition || 0)), 0) / denominator) : 0;
            const actualAttr = denominator ? Math.round(recs.reduce((s, r) => s + ((r.availableHC || 0) * (r.actualAttrition || 0)), 0) / denominator) : 0;

            const totalForecasted = recs.reduce((s, r) => s + (r.forecastedHours || 0), 0);
            const totalActual = recs.reduce((s, r) => s + (r.actualHours || 0), 0);
            const otf = totalActual ? Math.round((totalForecasted / totalActual) * 100) : 0;

            [plannedShrink, actualShrink, plannedAttr, actualAttr, otf].forEach(val => {
                const td = document.createElement("td");
                td.innerText = val + "%";
                td.style.fontWeight = "500";
                tr.appendChild(td);
            });
        });
        tbody.appendChild(tr);

        // Children
        const children = drillMode === "GeoToLob"
            ? [...new Set(data.filter(d => d.geo === group).map(d => d.lob))]
            : [...new Set(data.filter(d => d.lob === group).map(d => d.geo))];

        children.forEach(child => {
            const trChild = document.createElement("tr");
            trChild.style.background = "#f0f0f0";
            trChild.style.fontStyle = "italic";
            trChild.className = "childRow";
            trChild.style.display = "none";
            const tdChild = document.createElement("td");
            tdChild.innerText = "   └ " + child;
            tdChild.style.fontStyle = "italic";
            tdChild.style.fontSize = "0.85em";
            trChild.appendChild(tdChild);

            periods.forEach(period => {
                const recs = data.filter(d =>
                    (drillMode === "GeoToLob"
                        ? d.geo === group && d.lob === child
                        : d.lob === group && d.geo === child) &&
                    d[timeKey] === period
                );

                const denominator = recs.reduce((s, r) => s + (r.availableHC || 0), 0);
                const plannedShrink = denominator ? Math.round(recs.reduce((s, r) => s + ((r.availableHC || 0) * (r.plannedShrinkage || 0)), 0) / denominator) : 0;
                const actualShrink = denominator ? Math.round(recs.reduce((s, r) => s + ((r.availableHC || 0) * (r.actualShrinkage || 0)), 0) / denominator) : 0;
                const plannedAttr = denominator ? Math.round(recs.reduce((s, r) => s + ((r.availableHC || 0) * (r.plannedAttrition || 0)), 0) / denominator) : 0;
                const actualAttr = denominator ? Math.round(recs.reduce((s, r) => s + ((r.availableHC || 0) * (r.actualAttrition || 0)), 0) / denominator) : 0;

                const totalForecasted = recs.reduce((s, r) => s + (r.forecastedHours || 0), 0);
                const totalActual = recs.reduce((s, r) => s + (r.actualHours || 0), 0);
                const otf = totalActual ? Math.round((totalForecasted / totalActual) * 100) : 0;

                [plannedShrink, actualShrink, plannedAttr, actualAttr, otf].forEach(val => {
                    const td = document.createElement('td');
                    td.innerText = val + "%";
                    td.style.fontWeight = "500";
                    trChild.appendChild(td);
                });
            });

            tbody.appendChild(trChild);
        });

        tr.addEventListener("click", () => {
            let next = tr.nextElementSibling;
            while (next && next.classList.contains("childRow")) {
                next.style.display = (next.style.display === "none") ? "table-row" : "none";
                next = next.nextElementSibling;
            }
        });
    });

    table.appendChild(tbody);
    container.appendChild(table);
}
