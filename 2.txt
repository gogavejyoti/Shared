function copyToClipboard(text) {
    // Try modern clipboard API first
    if (navigator.clipboard && document.hasFocus()) {
        navigator.clipboard.writeText(text)
            .then(() => console.log("Copied using Clipboard API"))
            .catch(err => {
                console.warn("Clipboard API failed, using fallback:", err);
                fallbackCopy(text);
            });
    } else {
        fallbackCopy(text);
    }
}

// Fallback using a hidden textarea
function fallbackCopy(text) {
    const textarea = document.createElement("textarea");
    textarea.style.position = "fixed";
    textarea.style.opacity = "0";
    textarea.value = text;
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();

    try {
        const success = document.execCommand("copy");
        console.log(success ? "Copied with fallback" : "Fallback copy failed");
    } catch (err) {
        console.error("Fallback copy failed:", err);
    }

    document.body.removeChild(textarea);
}

const indexedRowIds = Object.keys(rowSelections)
    .map(rowId => parseInt(rowId, 10))       // Convert keys to numbers
    .sort((a, b) => a - b)                   // Sort numerically
    .reduce((acc, rowId, index) => {
        acc[index] = rowId.toString();       // Store original rowId string as value
        return acc;
    }, {});

document.addEventListener('keydown', function (e) {
    if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
        e.preventDefault();
        const grid = $('#yourPivotGrid').jqxPivotGrid('getInstance');
        const data = grid.getSelectedCellsData?.();
        if (data?.length) {
            const text = data.map(row => row.join('\t')).join('\n');
            copyToClipboard(text); // uses robust fallback
        }
    }
});




// --- CASE 1: CELL SELECTION ---
    if (cellSelections && Object.keys(cellSelections).length > 0) {
        const cellMap = {};

        Object.keys(cellSelections).forEach(key => {
            const cleanedKey = key.replace(':', '');
            const [colStr, rowStr] = cleanedKey.split('_');
            const rowIdx = parseInt(rowStr, 10);
            const colIdx = parseInt(colStr, 10);
            const cell = cellSelections[key];

            const valObj = this.source.getCellValue(
                cell.pivotRow.adapterItem,
                cell.pivotColumn.adapterItem
            );
            const value = valObj?.formattedValue ?? '';

            if (!cellMap[rowIdx]) cellMap[rowIdx] = {};
            cellMap[rowIdx][colIdx] = value;
        });

        const sortedRowIndices = Object.keys(cellMap).map(Number).sort((a, b) => a - b);
        const allColIndices = new Set();

        sortedRowIndices.forEach(rowIdx => {
            Object.keys(cellMap[rowIdx]).forEach(c => allColIndices.add(parseInt(c)));
        });

        const sortedColIndices = [...allColIndices].sort((a, b) => a - b);

        return sortedRowIndices.map(rowIdx => {
            return sortedColIndices.map(colIdx => {
                return cellMap[rowIdx][colIdx] ?? "";
            });
        });
    }


return selectedRowIndices.map(rowIdx => {
                    return datatable.values?.[rowKeyId[rowIdx]]?.cellValue ?? [];
                });


datatable.values[0].cellValue[5]


 let selectedColumnsValues = selectedColumnIndices.map(colIdx => {
                    return datatable.values?.map(row => row.cellValue[colKeyId[colIdx]]);
                });



                //let copiedArray = $.extend([], datatable.headers);
                //selectedRowValues.unshift(copiedArray);
