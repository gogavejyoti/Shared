execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;
    const s = this;

    // 1. Initialize Global Helpers
    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    // 2. Handle Initial Trigger Cell
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // 3. Collect ALL relevant formulas across sheets
    let allFuncCells = [];
    // We get all sheets that could possibly be involved in the calculation chain
    const formulaOrValue = (window.luckysheet_getcelldata_cache && Object.keys(window.luckysheet_getcelldata_cache).join("+")) || null;
    const sheetIndices = s.getAllDependentSheetsFromSheet(l, formulaOrValue);
    allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];

    const sheetsInfo = Ft() || [];
    const sheetMap = {};
    for (let i = 0; i < sheetsInfo.length; i++) {
        sheetMap[sheetsInfo[i].index] = sheetsInfo[i].data;
    }

    // 4. Build the Graph
    const nodes = {}; 
    const refToChildren = {}; 

    // Robust regex for Excel-style references (handles 'Sheet Name'!A1:B2)
    const refRegex = /((?:'[^']+'|[\w\u4e00-\u9fa5]+)!|)([A-Z]+[0-9]+(:[A-Z]+[0-9]+)?|[A-Z]+:[A-Z]+|[0-9]+:[0-9]+)/gi;

    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const nodeKey = `i${T.index}r${T.r}c${T.c}`; // Canonical Key

        const formula = zl(T.r, T.c, T.index) || 
                        ve.getSheetByIndex(T.index)?.celldata?.find(x => x?.r === T.r && x?.c === T.c)?.v?.f;
        
        if (!formula) continue;

        nodes[nodeKey] = {
            key: nodeKey,
            r: T.r, c: T.c, index: T.index,
            formula: formula,
            parents: new Set(),
            children: new Set()
        };

        // Parse references within the formula
        let match;
        while ((match = refRegex.exec(formula)) !== null) {
            const token = match[0];
            const range = s.getcellrange(token, T.index);
            if (!range) continue;

            // Expand range to individual cell keys
            const refs = keysForRange(range, sheetMap);
            refs.forEach(ref => {
                if (!refToChildren[ref.key]) refToChildren[ref.key] = new Set();
                refToChildren[ref.key].add(nodeKey);
                nodes[nodeKey].parents.add(ref.key);
            });
        }
    }

    // Connect Graph Edges (Node to Node)
    Object.keys(nodes).forEach(key => {
        nodes[key].parents.forEach(parentKey => {
            if (nodes[parentKey]) {
                nodes[parentKey].children.add(key);
            }
        });
    });

    // 5. Determine Impacted Subgraph
    const execSet = s.execFunctionExist ? 
        s.execFunctionExist.map(T => `i${T.i}r${T.r}c${T.c}`) : 
        [`i${l}r${e}c${n}`];

    const impacted = new Set();
    const visitQueue = [...execSet];

    while (visitQueue.length > 0) {
        const current = visitQueue.shift();
        // If the changed cell is a formula, add it
        if (nodes[current] && !impacted.has(current)) {
            impacted.add(current);
        }
        // Add all downstream children
        const dependents = refToChildren[current];
        if (dependents) {
            dependents.forEach(childKey => {
                if (!impacted.has(childKey)) {
                    impacted.add(childKey);
                    visitQueue.push(childKey);
                }
            });
        }
    }

    // 6. Topological Sort (Depth First Search)
    const ordered = [];
    const visited = new Set();
    const visiting = new Set(); // For cycle detection

    function topoSort(key) {
        if (visiting.has(key)) return; // Cycle detected
        if (visited.has(key)) return;

        visiting.add(key);
        const node = nodes[key];
        if (node) {
            node.parents.forEach(parentKey => {
                if (impacted.has(parentKey)) {
                    topoSort(parentKey);
                }
            });
            ordered.push(node);
        }
        visiting.delete(key);
        visited.add(key);
    }

    impacted.forEach(key => topoSort(key));

    // 7. Sequential Evaluation
    ordered.forEach(T => {
        window.luckysheet_getcelldata_cache = null;
        const Rres = s.execfunction(T.formula, T.r, T.c, T.index);

        // Update values
        s.execFunctionGlobalData[`${T.r}_${T.c}_${T.index}`] = { v: Rres[1], f: Rres[2] };
        s.groupValuesRefreshData.push({
            r: T.r, c: T.c, v: Rres[1], f: Rres[2],
            spe: Rres[3], index: T.index
        });
    });

    s.execFunctionExist = null;

    // Helper: Range to Keys
    function keysForRange(R, sheetMap) {
        const list = [];
        const maxRow = (sheetMap[R.sheetIndex] && sheetMap[R.sheetIndex].length - 1) ?? R.row[1];
        const endRow = Math.min(R.row[1], maxRow);

        for (let rr = R.row[0]; rr <= endRow; rr++) {
            for (let cc = R.column[0]; cc <= R.column[1]; cc++) {
                list.push({ key: `i${R.sheetIndex}r${rr}c${cc}`, r: rr, c: cc, idx: R.sheetIndex });
            }
        }
        return list;
    }
}
