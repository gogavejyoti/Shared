execFunctionGroup: function (e, n, t, l, a, o = !1) {
    if (o) return;
    const s = this;

    if (a == null) a = h.flowdata;

    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    if (typeof _shiftCrossSheetReference === "function") {
        _shiftCrossSheetReference({ type: "recalc", sheetIndex: l });
    }

    let allFuncCells = [];
    let sheetIndices = null;

    if (e && n) {
        const key =
            (window.luckysheet_getcelldata_cache &&
                Object.keys(window.luckysheet_getcelldata_cache).join("+")) ||
            null;
        sheetIndices = s.getAllDependentSheetsFromSheet(l, key);
        allFuncCells = s.getAllDependentFunctionGroup(sheetIndices) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    const execSet = {};
    if (s.execFunctionExist == null) {
        execSet["r" + e + "c" + n + "i" + l] = 1;
    } else {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const T = s.execFunctionExist[i];
            execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
        }
    }

    const nodes = {};
    const rangeToKeysCache = {};

    function keysForRange(R) {
        const cacheKey =
            "r" +
            R.row[0] +
            "_" +
            R.row[1] +
            "_c" +
            R.column[0] +
            "_" +
            R.column[1] +
            "_i" +
            R.sheetIndex;
        if (rangeToKeysCache[cacheKey]) return rangeToKeysCache[cacheKey];

        const list = [];
        for (let rr = R.row[0]; rr <= R.row[1]; rr++) {
            for (let cc = R.column[0]; cc <= R.column[1]; cc++) {
                list.push({
                    key: "r" + rr + "c" + cc + "i" + R.sheetIndex,
                    r: rr,
                    c: cc,
                    sheetIndex: R.sheetIndex,
                });
            }
        }
        rangeToKeysCache[cacheKey] = list;
        return list;
    }

    // Build nodes
    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const nodeKey = "r" + T.r + "c" + T.c + "i" + T.index;
        const R =
            zl(T.r, T.c, T.index) ||
            ve
                .getSheetByIndex(T.index)
                ?.celldata?.find(
                    (x) => x?.r === T.r && x?.c === T.c
                )?.v?.f;

        if (!R) continue;

        const upper = R.toUpperCase();
        const needsFunc =
            upper.indexOf("INDIRECT(") > -1 ||
            upper.indexOf("OFFSET(") > -1 ||
            upper.indexOf("INDEX(") > -1;

        const formulaRanges = [];

        if (needsFunc) {
            s.isFunctionRange(R, null, null, T.index, null, function (ref) {
                const rg = s.getcellrange($.trim(ref), T.index);
                if (rg) formulaRanges.push(rg);
            });
        } else {
            const tokens = R.split(/==|!=|<>|<=|>=|[,()=+\-/*%&^><]/).filter(Boolean);
            for (let ti = 0; ti < tokens.length; ti++) {
                const tk = tokens[ti].trim();
                if (!tk) continue;
                const rg = s.getcellrange(tk, T.index);
                if (rg) formulaRanges.push(rg);
            }
        }

        nodes[nodeKey] = {
            key: nodeKey,
            r: T.r,
            c: T.c,
            index: T.index,
            calc_funcStr: R,
            formulaArray: formulaRanges,
            parents: {},
            children: {},
            color: "w",
        };
    }

    // Build dependency graph
    const startNodes = [];
    for (const k in nodes) {
        const node = nodes[k];
        for (let i = 0; i < node.formulaArray.length; i++) {
            const keys = keysForRange(node.formulaArray[i]);
            for (let j = 0; j < keys.length; j++) {
                const A = keys[j].key;
                if (nodes[A]) {
                    node.parents[A] = 1;
                    nodes[A].children[node.key] = 1;
                }
                if (!o && A in execSet) startNodes.push(node);
            }
        }
        if (o) startNodes.push(node);
    }

    // DFS topo build
    const visited = {};
    const ordered = [];
    const stack = startNodes.slice();

    while (stack.length) {
        const cur = stack.pop();
        if (!cur || visited[cur.key]) continue;

        if (cur.color === "b") {
            visited[cur.key] = 1;
            ordered.push(cur);
            continue;
        }

        cur.color = "b";
        stack.push(cur);

        for (const pk in cur.parents) {
            if (nodes[pk]) stack.push(nodes[pk]);
        }
    }

    ordered.reverse();

    /* ==========================================================
       ðŸ”’ INLINE ORDER RE-VERIFICATION (CRITICAL FIX)
       Guarantees: parent always before dependent
    ========================================================== */
    (function reverifyOrder() {
        const pos = {};
        for (let i = 0; i < ordered.length; i++) pos[ordered[i].key] = i;

        let changed = true;
        let guard = 0;

        while (changed && guard++ < ordered.length) {
            changed = false;

            for (let i = 0; i < ordered.length; i++) {
                const node = ordered[i];
                for (const pk in node.parents) {
                    if (!(pk in pos)) continue;
                    if (pos[pk] > pos[node.key]) {
                        const pNode = ordered[pos[pk]];
                        ordered.splice(pos[pk], 1);
                        ordered.splice(i, 0, pNode);

                        for (let k = 0; k < ordered.length; k++) {
                            pos[ordered[k].key] = k;
                        }
                        changed = true;
                        break;
                    }
                }
                if (changed) break;
            }
        }
    })();

    // Execute
    for (let i = 0; i < ordered.length; i++) {
        const T = ordered[i];
        window.luckysheet_getcelldata_cache = null;

        const Rres = s.execfunction(
            T.calc_funcStr,
            T.r,
            T.c,
            T.index
        );

        s.groupValuesRefreshData.push({
            r: T.r,
            c: T.c,
            v: Rres[1],
            f: Rres[2],
            spe: Rres[3],
            index: T.index,
        });

        s.execFunctionGlobalData[
            T.r + "_" + T.c + "_" + T.index
        ] = {
            v: Rres[1],
            f: Rres[2],
        };
    }

    s.execFunctionExist = null;
}
