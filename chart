(function ($) {
    $.fn.generateDynamicChart = function (options) {
        let settings = $.extend({
            botTextContainer: null,
            userInput: '',
            data: []
        }, options);

        if (!settings.data || settings.data.length === 0) {
            console.error("No data provided for the chart.");
            return this;
        }

        // Remove unnecessary filter fields
        settings.data.forEach(item => {
            delete item.DateWeekFilter;
            delete item.DateMonthFilter;
            delete item.DateYearFilter;
        });

        let sampleItem = settings.data[0];
        let nonNumericFields = [];
        let numericFields = [];
        let percentageFields = [];
        let dateFields = [];

        // Identify column types
        Object.keys(sampleItem).forEach(key => {
            let value = sampleItem[key];
            if (/^\d{1,2}-[A-Za-z]{3}-\d{2}$/.test(value) || 
                /^[A-Za-z]{3}-\d{2}$/.test(value) ||         
                /^\d{4}-\d{2}$/.test(value)) {               
                dateFields.push(key);
            }
            else if (isNaN(value) || value === '') {
                nonNumericFields.push(key);
            }
            else {
                numericFields.push(key);
                if (key.toLowerCase().includes("percentage") || key.includes("%")) {
                    percentageFields.push(key);
                }
            }
        });

        let requiresTranspose = (dateFields.length === 1 && numericFields.length >= 1);
        let groupingFields;
        let transformedData = [];
        if (requiresTranspose) {
            let timeColumn = dateFields[0];
            groupingFields = nonNumericFields.filter(field => !dateFields.includes(field));
            let uniqueDates = [...new Set(settings.data.map(item => item[timeColumn]))];
            const getGroupKey = (item) => {
                return groupingFields.map(field => item[field]).join(" - ");
            };
            let uniqueGroups = [...new Set(settings.data.map(item => getGroupKey(item)))];

            uniqueGroups.forEach(group => {
                numericFields.forEach(metric => {
                    let transposedObject = { ...Object.fromEntries(groupingFields.map(field => [field, settings.data.find(item => getGroupKey(item) === group)[field]])) };
                    transposedObject["Metric"] = metric;
                    uniqueDates.forEach(date => {
                        let matchingItem = settings.data.find(item => item[timeColumn] === date && getGroupKey(item) === group);
                        transposedObject[date] = matchingItem ? matchingItem[metric] : 0;
                    });
                    transformedData.push(transposedObject);
                });
            });
        } else {
            transformedData = settings.data;
        }

        // Create UI elements
        let chatBox = $("#chatBox");
        let mainContainer = $("<div>").addClass("chat-result card p-3 mb-3 shadow-sm").css({
            width: "100%",
            border: "1px solid #ddd",
            borderRadius: "10px",
            padding: "15px"
        });

        let tableContainer = $("<div>").addClass("table-responsive").css({
            width: "100%",
            maxHeight: "250px",
            overflowY: "auto",
            marginBottom: "15px",
            padding: "10px",
            border: "1px solid #ccc",
            borderRadius: "5px",
            backgroundColor: "#f8f9fa"
        });

        let table = $("<table>").addClass("table table-bordered table-striped text-center").css({
            width: "100%",
            fontSize: "14px"
        });

        let thead = $("<thead>").append("<tr></tr>");
        let tbody = $("<tbody></tbody>");

        Object.keys(transformedData[0]).forEach(key => {
            thead.find("tr").append($("<th>").text(key).addClass("bg-primary text-white"));
        });

        transformedData.forEach(row => {
            let tr = $("<tr></tr>");
            Object.keys(row).forEach(key => {
                let value = row[key];
                if (key === "Metric") {
                    tr.append($("<td>").text(value));
                } else {
                    if (!isNaN(value) && percentageFields.includes(row["Metric"])) {
                        value = (parseFloat(value) || 0).toFixed(1) + "%";
                    } else if (!isNaN(value)) {
                        value = (parseFloat(value) || 0).toFixed(0);
                    }
                    tr.append($("<td>").text(value));
                }
            });
            tbody.append(tr);
        });

        table.append(thead).append(tbody);
        tableContainer.append(table);
        mainContainer.append(tableContainer);

        // Generate Chart with D3.js
        if (settings.userInput.toLowerCase().includes("show chart") || settings.userInput.toLowerCase().includes("with chart")) {
            let chartContainer = $("<div>").css({
                width: "100%",
                height: "350px",
                border: "1px solid #ccc",
                borderRadius: "5px",
                backgroundColor: "#fff",
                padding: "10px"
            });

            $('.bot-message:last').remove();
            mainContainer.append(chartContainer);
            chatBox.append(mainContainer);

            function buildChart(data, chartContainer) {
                let sampleItem = data[0];
                let nonNumericFields = [];
                let numericFields = [];
                Object.keys(sampleItem).forEach(key => {
                    if (isNaN(sampleItem[key]) || sampleItem[key] === '') {
                        nonNumericFields.push(key);
                    } else {
                        numericFields.push(key);
                    }
                });
                
                let categoryField = nonNumericFields[nonNumericFields.length - 1] || Object.keys(sampleItem)[0];
                let chartData = data.map(item => ({
                    category: item[categoryField],
                    value: parseFloat(item[numericFields[0]]) || 0
                }));

                // D3.js chart implementation
                const margin = { top: 20, right: 30, bottom: 50, left: 60 };
                const width = chartContainer.width() - margin.left - margin.right;
                const height = 320 - margin.top - margin.bottom;

                // Create SVG
                const svg = d3.select(chartContainer[0])
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                // X scale
                const x = d3.scaleBand()
                    .range([0, width])
                    .domain(chartData.map(d => d.category))
                    .padding(0.2);

                // Y scale
                const y = d3.scaleLinear()
                    .range([height, 0])
                    .domain([0, d3.max(chartData, d => d.value) * 1.1]);

                // X axis
                svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x))
                    .selectAll("text")
                    .attr("transform", "rotate(-45)")
                    .style("text-anchor", "end");

                // Y axis
                svg.append("g")
                    .call(d3.axisLeft(y)
                        .tickFormat(d => percentageFields.length > 0 ? `${d}%` : d));

                // Bars
                svg.selectAll(".bar")
                    .data(chartData)
                    .enter()
                    .append("rect")
                    .attr("class", "bar")
                    .attr("x", d => x(d.category))
                    .attr("y", d => y(d.value))
                    .attr("width", x.bandwidth())
                    .attr("height", d => height - y(d.value))
                    .attr("fill", "#4e73df");

                // Data labels
                svg.selectAll(".label")
                    .data(chartData)
                    .enter()
                    .append("text")
                    .attr("class", "label")
                    .attr("x", d => x(d.category) + x.bandwidth() / 2)
                    .attr("y", d => y(d.value) - 5)
                    .attr("text-anchor", "middle")
                    .text(d => percentageFields.length > 0 ? `${d.value.toFixed(1)}%` : Math.round(d.value))
                    .style("font-size", "12px");
            }

            // Note: Make sure D3.js is included in your project
            // <script src="https://d3js.org/d3.v7.min.js"></script>
            buildChart(transformedData, chartContainer);
        } else {
            $('.bot-message:last').remove();
            chatBox.append(mainContainer);
        }

        return this;
    };
}(jQuery));
