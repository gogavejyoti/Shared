// ============================================================
// FINAL SAFE Excel-style ordering
// (Topo correctness + DFS completeness fallback)
// ============================================================

const ordered = [];
const inDegree = {};
const queue = [];

// 1. Build inDegree ONLY from impacted parents
for (const k of impacted) {
    const node = nodes[k];
    if (!node) continue;

    let deg = 0;
    for (const p in node.parents) {
        if (impacted.has(p)) deg++;
    }
    inDegree[k] = deg;

    if (deg === 0) {
        queue.push(k);
    }
}

// 2. Kahn topo
while (queue.length) {
    const k = queue.shift();
    if (!nodes[k]) continue;

    ordered.push(nodes[k]);

    for (const c in nodes[k].children) {
        if (!impacted.has(c)) continue;

        inDegree[c]--;
        if (inDegree[c] === 0) {
            queue.push(c);
        }
    }
}

// 3. SAFETY NET â€” never drop nodes (Excel never does)
if (ordered.length !== impacted.size) {
    const scheduled = new Set(ordered.map(n => n.key));

    // DFS fallback for any unscheduled impacted nodes
    const visited = {};

    function dfsFallback(k) {
        if (visited[k]) return;
        visited[k] = true;

        const node = nodes[k];
        if (!node) return;

        for (const p in node.parents) {
            if (impacted.has(p) && !scheduled.has(p)) {
                dfsFallback(p);
            }
        }

        if (!scheduled.has(k)) {
            ordered.push(node);
            scheduled.add(k);
        }
    }

    for (const k of impacted) {
        if (!scheduled.has(k)) {
            dfsFallback(k);
        }
    }
}
