execFunctionGroup_new1: function (e, n, t, l, a, o = !1) {
    // Preserve original early return semantics
    if (o) return;

    const s = this;

    // ---------- Initialize helpers (UNCHANGED / REQUIRED) ----------
    if (a == null) a = h.flowdata;
    if (!window.luckysheet_compareWith) {
        window.luckysheet_compareWith = ja;
        window.luckysheet_getarraydata = wc;
        window.luckysheet_getcelldata = nr;
        window.luckysheet_parseData = Ua;
        window.luckysheet_getValue = qn;
        window.luckysheet_indirect_check = xc;
        window.luckysheet_indirect_check_return = _c;
        window.luckysheet_offset_check = Cc;
        window.luckysheet_calcADPMM = _t;
        window.luckysheet_getSpecialReference = Tc;
    }

    if (!s.execFunctionGlobalData) s.execFunctionGlobalData = {};
    if (l == null) l = h.currentSheetIndex;

    // ---------- Fast caches (safe, additive) ----------
    if (!s._fastCalc) {
        s._fastCalc = {
            formulaRanges: Object.create(null),
            rangeKeys: Object.create(null)
        };
    }

    // ---------- Store explicit value ----------
    if (t != null) {
        const tmp = [[{ v: null }]];
        At(0, 0, tmp, t);
        s.execFunctionGlobalData[e + "_" + n + "_" + l] = tmp[0][0];
    }

    // ---------- Get function group cells ----------
    let allFuncCells = [];
    if (e != null && n != null) {
        const fov = window.luckysheet_getcelldata_cache
            ? Object.keys(window.luckysheet_getcelldata_cache).join("+")
            : null;
        const sheets = s.getAllDependentSheetsFromSheet(l, fov);
        allFuncCells = s.getAllDependentFunctionGroup(sheets) || [];
    } else {
        allFuncCells = s.getAllFunctionGroup() || [];
    }

    // ---------- Build sheetMap ----------
    const sheetMap = {};
    const sheetsInfo = Ft() || [];
    for (let i = 0; i < sheetsInfo.length; i++) {
        sheetMap[sheetsInfo[i].index] = sheetsInfo[i].data;
    }

    // ---------- Build execSet ----------
    const execSet = {};
    if (!s.execFunctionExist) {
        execSet["r" + e + "c" + n + "i" + l] = 1;
    } else {
        for (let i = 0; i < s.execFunctionExist.length; i++) {
            const T = s.execFunctionExist[i];
            execSet["r" + T.r + "c" + T.c + "i" + T.i] = 1;
        }
    }

    // ---------- Range â†’ keys (cached, unchanged behavior) ----------
    const keysForRange = (R) => {
        const key =
            R.sheetIndex + "|" +
            R.row[0] + ":" + R.row[1] + "|" +
            R.column[0] + ":" + R.column[1];

        if (s._fastCalc.rangeKeys[key]) return s._fastCalc.rangeKeys[key];

        const sheet = sheetMap[R.sheetIndex];
        const maxRow = sheet ? sheet.length - 1 : R.row[1];
        const endRow = R.row[1] > maxRow ? maxRow : R.row[1];

        const out = [];
        for (let r = R.row[0]; r <= endRow; r++) {
            for (let c = R.column[0]; c <= R.column[1]; c++) {
                out.push("r" + r + "c" + c + "i" + R.sheetIndex);
            }
        }

        s._fastCalc.rangeKeys[key] = out;
        return out;
    };

    // ---------- Build nodes ----------
    const nodes = {};
    const refToChildren = {};
    const fmrSplit = /==|!=|<>|<=|>=|[,()=+\-/*%&\^><]/;

    for (let i = 0; i < allFuncCells.length; i++) {
        const T = allFuncCells[i];
        const nodeKey = "r" + T.r + "c" + T.c + "i" + T.index;

        const formula =
            zl(T.r, T.c, T.index) ||
            ve.getSheetByIndex(T.index)?.celldata?.find(
                x => x?.r === T.r && x?.c === T.c
            )?.v?.f;

        if (!formula) continue;

        let ranges = s._fastCalc.formulaRanges[formula];
        if (!ranges) {
            ranges = [];
            const tokens = formula.split(fmrSplit);
            for (let ti = 0; ti < tokens.length; ti++) {
                const tk = tokens[ti].trim();
                if (!tk) continue;
                const rg = s.getcellrange(tk, T.index);
                if (rg) ranges.push(rg);
            }
            s._fastCalc.formulaRanges[formula] = ranges;
        }

        nodes[nodeKey] = {
            key: nodeKey,
            r: T.r,
            c: T.c,
            index: T.index,
            parents: {},
            children: {},
            color: "w",
            formulaArray: ranges,
            calc_funcStr: formula
        };
    }

    // ---------- Dependency graph ----------
    for (const nk in nodes) {
        const node = nodes[nk];
        const ranges = node.formulaArray;

        for (let ri = 0; ri < ranges.length; ri++) {
            const refs = keysForRange(ranges[ri]);
            for (let k = 0; k < refs.length; k++) {
                const ref = refs[k];

                if (!refToChildren[ref]) refToChildren[ref] = new Set();
                refToChildren[ref].add(nk);

                if (nodes[ref]) {
                    node.parents[ref] = 1;
                    nodes[ref].children[nk] = 1;
                }
            }
        }
    }

    // ---------- Impacted ----------
    const impacted = new Set();
    const queue = [];

    for (const k in execSet) {
        if (nodes[k]) {
            impacted.add(k);
            queue.push(k);
        }
        if (refToChildren[k]) {
            for (const c of refToChildren[k]) {
                if (!impacted.has(c)) {
                    impacted.add(c);
                    queue.push(c);
                }
            }
        }
    }

    while (queue.length) {
        const k = queue.pop();
        const nnode = nodes[k];
        if (!nnode) continue;
        for (const c in nnode.children) {
            if (!impacted.has(c)) {
                impacted.add(c);
                queue.push(c);
            }
        }
    }

    if (impacted.size === 0) {
        for (const k in nodes) impacted.add(k);
    }

    // ---------- Topological order (parents first, NO sort) ----------
    const ordered = [];
    const processed = {};
    const stack = [];

    for (const k of impacted) stack.push(nodes[k]);

    while (stack.length) {
        const cur = stack.pop();
        if (!cur || processed[cur.key]) continue;

        if (cur.color === "b") {
            ordered.push(cur);
            processed[cur.key] = 1;
            continue;
        }

        cur.color = "b";
        stack.push(cur);

        for (const pk in cur.parents) {
            if (nodes[pk] && impacted.has(pk) && !processed[pk]) {
                stack.push(nodes[pk]);
            }
        }
    }

    // ---------- Precompute ----------
    const indexMap = new Map();
    const parentsList = [];

    for (let i = 0; i < ordered.length; i++) {
        indexMap.set(ordered[i].key, { idx: i, count: 0 });
        parentsList[i] = Object.keys(ordered[i].parents);
    }

    // ---------- Worklist (CORE LOGIC UNCHANGED) ----------
    const worklist = [];
    for (let i = 0; i < ordered.length; i++) worklist.push(i);
    let head = 0;

    while (head < worklist.length) {
        const i = worklist[head++];
        const T = ordered[i];

        window.luckysheet_getcelldata_cache = null;

        let oldValue;
        const sheet = sheetMap[T.index];
        if (sheet && sheet[T.r] && sheet[T.r][T.c]) {
            oldValue = sheet[T.r][T.c].v;
        }

        const R = s.execfunction(T.calc_funcStr, T.r, T.c, T.index);
        const newValue = R[1];

        if (oldValue === newValue) continue;

        s.execFunctionGlobalData[`${T.r}_${T.c}_${T.index}`] = {
            v: newValue,
            f: R[2]
        };

        s.groupValuesRefreshData.push({
            r: T.r, c: T.c, v: newValue,
            f: R[2], spe: R[3], index: T.index
        });

        // ðŸ”¥ EXACT SAME parent requeue logic
        const parents = parentsList[i];
        for (let p = 0; p < parents.length; p++) {
            const im = indexMap.get(parents[p]);
            if (im && im.idx < i && im.count < 5) {
                worklist.push(im.idx);
                im.count++;
            }
        }
    }

    s.execFunctionExist = null;
}
