(function ($) {
    $.fn.generateDynamicChart = function (options) {
        let settings = $.extend({
            botTextContainer: null,
            userInput: '',
            data: []
        }, options);

        if (!settings.data || settings.data.length === 0) {
            console.error("No data provided for the chart.");
            return this;
        }

        // Remove unnecessary filter fields
        settings.data.forEach(item => {
            delete item.DateWeekFilter;
            delete item.DateMonthFilter;
            delete item.DateYearFilter;
        });

        let sampleItem = settings.data[0];
        let nonNumericFields = [];
        let numericFields = [];
        let percentageFields = [];
        let dateFields = [];

        // Identify column types dynamically
        Object.keys(sampleItem).forEach(key => {
            let value = sampleItem[key];

            // Detect time-based columns
            if (/^\d{1,2}-[A-Za-z]{3}-\d{2}$/.test(value) || // dd-MMM-yy
                /^[A-Za-z]{3}-\d{2}$/.test(value) ||         // MMM-yy
                /^\d{4}-\d{2}$/.test(value)) {               // yyyy-MM
                dateFields.push(key);
            } 
            else if (isNaN(value) || value === '') {
                nonNumericFields.push(key);
            } 
            else {
                numericFields.push(key);
                if (key.toLowerCase().includes("percentage") || key.includes("%")) {
                    percentageFields.push(key);
                }
            }
        });

        let requiresTranspose = (dateFields.length === 1 && numericFields.length > 0);
        let transformedData = [];

        if (requiresTranspose) {
            let timeColumn = dateFields[0];

            let transposedObject = { "Metric": "Value" };
            numericFields.forEach(metric => {
                settings.data.forEach(item => {
                    if (!transposedObject[item[timeColumn]]) {
                        transposedObject[item[timeColumn]] = {};
                    }
                    transposedObject[item[timeColumn]][metric] = item[metric];
                });
            });

            transformedData = Object.entries(transposedObject)
                .map(([time, values]) => ({ Metric: time, ...values }));
        } else {
            transformedData = settings.data;
        }

        // Create UI elements
        let chatBox = $("#chatBox");
        let mainContainer = $("<div>").addClass("chat-result card p-3 mb-3 shadow-sm").css({
            width: "100%",
            border: "1px solid #ddd",
            borderRadius: "10px",
            padding: "15px"
        });

        let tableContainer = $("<div>").addClass("table-responsive").css({
            width: "100%",
            maxHeight: "250px",
            overflowY: "auto",
            marginBottom: "15px",
            padding: "10px",
            border: "1px solid #ccc",
            borderRadius: "5px",
            backgroundColor: "#f8f9fa"
        });

        let table = $("<table>").addClass("table table-bordered table-striped text-center").css({
            width: "100%",
            fontSize: "14px"
        });

        let thead = $("<thead>").append("<tr></tr>");
        let tbody = $("<tbody></tbody>");

        // Create table headers dynamically
        Object.keys(transformedData[0]).forEach(key => {
            thead.find("tr").append($("<th>").text(key).addClass("bg-primary text-white"));
        });

        // Create table rows
        transformedData.forEach(row => {
            let tr = $("<tr></tr>");
            Object.keys(row).forEach(key => {
                let value = row[key];
                if (percentageFields.includes(key)) {
                    value = (parseFloat(value) || 0).toFixed(1) + "%";
                } else if (!isNaN(value)) {
                    value = Math.round(value);
                }
                tr.append($("<td>").text(value));
            });
            tbody.append(tr);
        });

        table.append(thead).append(tbody);
        tableContainer.append(table);
        mainContainer.append(tableContainer);

        // Generate Chart if requested
        if (settings.userInput.toLowerCase().includes("show chart") || settings.userInput.toLowerCase().includes("with chart")) {
            let chartContainer = $("<div>").css({
                width: "100%",
                height: "350px",
                border: "1px solid #ccc",
                borderRadius: "5px",
                backgroundColor: "#fff",
                padding: "10px"
            });

            $('.bot-message:last').remove();
            mainContainer.append(chartContainer);
            chatBox.append(mainContainer);

            let categories = transformedData.map(item => item["Metric"]);
            let seriesData = Object.keys(transformedData[0])
                .filter(key => key !== "Metric")
                .map(key => ({
                    name: key,
                    data: transformedData.map(item => parseFloat(item[key]) || 0)
                }));

            let chartOptions = {
                chart: { type: requiresTranspose ? "line" : "bar", height: 320 },
                series: seriesData,
                xaxis: { categories: categories },
                yaxis: {
                    labels: {
                        formatter: function (value) {
                            return value.toFixed(1) + "%";
                        }
                    }
                },
                dataLabels: { enabled: true }
            };

            let chart = new ApexCharts(chartContainer[0], chartOptions);
            chart.render();
        } else {
            $('.bot-message:last').remove();
            chatBox.append(mainContainer);
        }

        return this;
    };
}(jQuery));
