            execFunctionGroup: function (e, n, t, l, a, o = !1) {
                let s = this;
                a == null && (a = h.flowdata),
                    window.luckysheet_compareWith || (window.luckysheet_compareWith = ja,
                        window.luckysheet_getarraydata = wc,
                        window.luckysheet_getcelldata = nr,
                        window.luckysheet_parseData = Ua,
                        window.luckysheet_getValue = qn,
                        window.luckysheet_indirect_check = xc,
                        window.luckysheet_indirect_check_return = _c,
                        window.luckysheet_offset_check = Cc,
                        window.luckysheet_calcADPMM = _t,
                        window.luckysheet_getSpecialReference = Tc),
                    s.execFunctionGlobalData == null && (s.execFunctionGlobalData = {});
                let u = Ft()
                    , d = u[K(h.currentSheetIndex)].dynamicArray_compute == null ? {} : u[K(h.currentSheetIndex)].dynamicArray_compute;
                if (l == null && (l = h.currentSheetIndex),
                    t != null) {
                    let k = [[{
                        v: null
                    }]];
                    At(0, 0, k, t),
                        s.execFunctionGlobalData[e + "_" + n + "_" + l] = k[0][0]
                }
                let f = s.getAllFunctionGroup()
                    , m = {}
                    , g = []
                    , y = 0;
                if (s.execvertex = {},
                    s.execFunctionExist == null)
                    for (let k = 0; k < f.length; k++) {
                        let b = f[k]
                            , w = u[K(b.index)];
                        if (w == null)
                            continue;
                        let x = w.data[b.r][b.c]
                            , C = zl(b.r, b.c, b.index);
                        x != null && x.f != null && x.f == C && (b instanceof Object || (b = new Function("return " + b)()),
                            b.color = "w",
                            b.parent = null,
                            b.chidren = {},
                            b.times = 0,
                            m["r" + b.r + "c" + b.c + "i" + b.index] = b,
                            s.isFunctionRangeSave = !1,
                            o ? s.isFunctionRangeSave = !0 : e != null && n != null && s.isFunctionRangeSelect(C, e, n, l, d),
                            s.isFunctionRangeSave && (g.push(b),
                                s.execvertex["r" + b.r + "c" + b.c + "i" + b.index] = b,
                                y++))
                    }
                else
                    for (let k = 0; k < s.execFunctionExist.length; k++) {
                        let b = s.execFunctionExist[k];
                        if (!("r" + b.r + "c" + b.c + "i" + b.i in m))
                            for (let w = 0; w < f.length; w++) {
                                let x = f[w]
                                    , C = zl(x.r, x.c, x.index);
                                x.color = "w",
                                    x.parent = null,
                                    x.chidren = {},
                                    x.times = 0,
                                    m["r" + x.r + "c" + x.c + "i" + x.index] = x,
                                    s.isFunctionRangeSave = !1,
                                    o ? s.isFunctionRangeSave = !0 : s.isFunctionRangeSelect(C, b.r, b.c, b.i, d),
                                    s.isFunctionRangeSave && (g.push(x),
                                        s.execvertex["r" + x.r + "c" + x.c + "i" + x.index] = x,
                                        y++)
                            }
                    }
                for (; g.length > 0;) {
                    let k = g.shift()
                        , b = {};
                    s.getChildrenVertex(k, m, b);
                    for (let w in m) {
                        let x = m[w];
                        if (x == null)
                            continue;
                        let C = "r" + k.r + "c" + k.c + "i" + k.index;
                        if (w in b)
                            continue;
                        s.isFunctionRangeSave = !1;
                        let S = zl(x.r, x.c, x.index);
                        s.isFunctionRangeSelect(S, k.r, k.c, k.index, d),
                            s.isFunctionRangeSave && (w in s.execvertex || (g.push(x),
                                s.execvertex[w] = x),
                                y++,
                                s.execvertex[w].chidren[C] = 1)
                    }
                }
                s.groupValuesRefreshData = [];
                let v = 0;
                for (; v < y;)
                    for (let k in s.execvertex) {
                        let b = s.execvertex[k];
                        b.color == "w" ? s.functionDFS(b) : b.color == "b" && v++
                    }
                s.execFunctionExist = null
            },
