pasteHandlerOfCopyPaste: function (e) {
    if (!gr(h.luckysheet_select_save, h.currentSheetIndex)) return;

    let t = Q().paste,
        l = $.extend(true, {}, h.config);

    l.merge == null && (l.merge = {});

    let a = e.HasMC,
        o = e.RowlChange,
        s = e.dataSheetIndex,
        u = e.copyRange[0].row[0],
        d = e.copyRange[0].row[1],
        f = e.copyRange[0].column[0],
        m = e.copyRange[0].column[1],
        g = [],
        y = false;

    for (let se = 0; se < e.copyRange.length; se++) {
        let ie = Nt({
            row: e.copyRange[se].row,
            column: e.copyRange[se].column
        }, s);

        e.copyRange.length > 1
            ? u == e.copyRange[1].row[0] && d == e.copyRange[1].row[1]
                ? (ie = ie[0].map(function (ue, he) {
                    return ie.map(function (J) {
                        return J[he];
                    });
                }),
                  g = g.concat(ie),
                  y = true)
                : f == e.copyRange[1].column[0] && m == e.copyRange[1].column[1] && (g = g.concat(ie))
            : g = ie;
    }

    y && (g = g[0].map(function (se, ie) {
        return g.map(function (ue) {
            return ue[ie];
        });
    }));

    let v = $.extend(true, [], g);

    if (e.copyRange.length > 1)
        for (let se = 0; se < v.length; se++)
            for (let ie = 0; ie < v[se].length; ie++)
                v[se][ie] != null && v[se][ie].f != null && (delete v[se][ie].f, delete v[se][ie].spl);

    let k = v.length,
        b = v[0].length,
        w = h.luckysheet_select_save[h.luckysheet_select_save.length - 1],
        x = w.row[0],
        C = w.row[1],
        S = w.column[0],
        _ = w.column[1];

    let visibleRows = [];
    for (let row = x; row <= C; row++) {
        if (!h.visibledatarow[row]) {
            visibleRows.push(row);
        }
    }

    let visibleCols = [];
    for (let col = S; col <= _; col++) {
        if (!h.visibledatacolumn[col]) {
            visibleCols.push(col);
        }
    }

    let totalVisibleRows = visibleRows.length;
    let totalVisibleCols = visibleCols.length;

    let I = Math.ceil(totalVisibleRows / k);
    let F = Math.ceil(totalVisibleCols / b);

    (I != 0 && F != 0) || (C = x + k - 1, _ = S + b - 1);

    let R = false;
    if (l.merge != null && (R = Dt(l, x, C, S, _))) {
        de()
            ? alert(t.errorNotAllowMerged)
            : U.info(`<i class="fa fa-exclamation-triangle"></i>${t.warning}`, t.errorNotAllowMerged);
        return;
    }

    let N = we.deepCopyFlowData(h.flowdata),
        D = N.length,
        E = N[0].length,
        P = k + x - D,
        z = b + S - E;

    (P > 0 || z > 0) && (N = il([].concat(N), P, z, true));

    let O = Ur(s),
        V = $.extend(true, {}, h.luckysheetfile[K(s)].dataVerification),
        q = null,
        Y = 0,
        X = 0,
        ee = 0,
        te = 0;

    for (let se = 1; se <= I; se++) {
        for (let ie = 1; ie <= F; ie++) {
            let startRowIndex = (se - 1) * k;
            let startColIndex = (ie - 1) * b;

            if (startRowIndex >= totalVisibleRows || startColIndex >= totalVisibleCols) continue;

            Y = visibleRows[startRowIndex];
            X = visibleCols[startColIndex];

            if (Y == null || X == null) continue;

            te = visibleRows[Math.min(startRowIndex + k, totalVisibleRows) - 1] + 1;
            ee = visibleCols[Math.min(startColIndex + b, totalVisibleCols) - 1] + 1;

            for (let G = Y; G < te; G++) {
                if (h.visibledatarow[G]) continue;

                let le = [].concat(N[G]);

                for (let pe = X; pe < ee; pe++) {
                    if (h.visibledatacolumn[pe]) continue;

                    if (O[u + G - Y + "_" + (f + pe - X)]) {
                        let Fe = {
                            rangeType: "cell",
                            value: {
                                row_index: G,
                                col_index: pe,
                                l: O[u + G - Y + "_" + (f + pe - X)].l,
                                r: O[u + G - Y + "_" + (f + pe - X)].r,
                                t: O[u + G - Y + "_" + (f + pe - X)].t,
                                b: O[u + G - Y + "_" + (f + pe - X)].b
                            }
                        };
                        l.borderInfo == null && (l.borderInfo = []);
                        l.borderInfo.push(Fe);
                    } else if (O[G + "_" + pe]) {
                        let Fe = {
                            rangeType: "cell",
                            value: {
                                row_index: G,
                                col_index: pe,
                                l: null,
                                r: null,
                                t: null,
                                b: null
                            }
                        };
                        l.borderInfo == null && (l.borderInfo = []);
                        l.borderInfo.push(Fe);
                    }

                    V[u + G - Y + "_" + (f + pe - X)] && (q == null && (q = $.extend(true, {}, h.luckysheetfile[K(h.currentSheetIndex)].dataVerification)),
                        q[G + "_" + pe] = V[u + G - Y + "_" + (f + pe - X)]);

                    L(le[pe]) == "object" && "mc" in le[pe] && ("rs" in le[pe].mc && delete l.merge[le[pe].mc.r + "_" + le[pe].mc.c],
                        delete le[pe].mc);

                    let oe = null;
                    if (v[G - Y] != null && v[G - Y][pe - X] != null) {
                        oe = $.extend(true, {}, v[G - Y][pe - X]);
                    }

                    if (oe != null && oe.f != null) {
                        let Fe = oe.f;
                        let rowOffset = G - u;
                        let colOffset = pe - f;

                        rowOffset > 0 && (Fe = "=" + p.functionCopy(Fe, "down", rowOffset));
                        rowOffset < 0 && (Fe = "=" + p.functionCopy(Fe, "up", Math.abs(rowOffset)));
                        colOffset > 0 && (Fe = "=" + p.functionCopy(Fe, "right", colOffset));
                        colOffset < 0 && (Fe = "=" + p.functionCopy(Fe, "left", Math.abs(colOffset)));

                        let ae = p.execfunction(Fe, G, pe, void 0, true);

                        oe.f = ae[2];
                        oe.v = ae[1];
                        oe.ct != null && oe.ct.fa != null && (oe.m = mt(oe.ct.fa, ae[1]));
                    }

                    le[pe] = $.extend(true, {}, oe);

                    if (oe != null && a && "mc" in le[pe]) {
                        if (le[pe].mc.rs != null) {
                            le[pe].mc.r = G;
                            le[pe].mc.c = pe;
                            l.merge[le[pe].mc.r + "_" + le[pe].mc.c] = le[pe].mc;
                            J[oe.mc.r + "_" + oe.mc.c] = [le[pe].mc.r, le[pe].mc.c];
                        } else {
                            le[pe] = {
                                mc: {
                                    r: J[oe.mc.r + "_" + oe.mc.c][0],
                                    c: J[oe.mc.r + "_" + oe.mc.c][1]
                                }
                            };
                        }
                    }
                }

                N[G] = le;
            }
        }
    }

    let ce = null;
    if (e.copyRange.length == 1) {
        let se = h.luckysheetfile[K(s)],
            ie = h.luckysheetfile[K(h.currentSheetIndex)],
            ue = $.extend(true, [], se.luckysheet_conditionformat_save);

        if (ue != null && ue.length > 0) {
            ce = $.extend(true, [], ie.luckysheet_conditionformat_save);
            for (let he = 0; he < ue.length; he++) {
                let J = ue[he].cellrange,
                    G = [];

                for (let le = 1; le <= I; le++) {
                    for (let pe = 1; pe <= F; pe++) {
                        Y = visibleRows[Math.min((le - 1) * k, totalVisibleRows - 1)];
                        X = visibleCols[Math.min((pe - 1) * b, totalVisibleCols - 1)];
                        te = visibleRows[Math.min(le * k - 1, totalVisibleRows - 1)] + 1;
                        ee = visibleCols[Math.min(pe * b - 1, totalVisibleCols - 1)] + 1;

                        for (let oe = 0; oe < J.length; oe++) {
                            let Fe = $e.CFSplitRange(J[oe], {
                                row: [u, d],
                                column: [f, m]
                            }, {
                                row: [Y, te - 1],
                                column: [X, ee - 1]
                            }, "operatePart");

                            Fe.length > 0 && (G = G.concat(Fe));
                        }
                    }
                }

                G.length > 0 && (ue[he].cellrange = G, ce.push(ue[he]));
            }
        }
    }

    w.row = [x, C];
    w.column = [S, _];

    if (o || P > 0 || z > 0) {
        l = yl(N, x, C, l);
        let se = {
            cfg: l,
            RowlChange: true,
            cdformat: ce,
            dataVerification: q
        };
        Ye(N, h.luckysheet_select_save, se);
    } else {
        let se = {
            cfg: l,
            cdformat: ce,
            dataVerification: q
        };
        Ye(N, h.luckysheet_select_save, se);
        tt();
    }
},
