function buildTable(selectedLOBs, selectedMetrics, weekFrom, weekTo, summaryType) {
    const fromIndex = uniqueWeeks.indexOf(weekFrom);
    const toIndex = uniqueWeeks.indexOf(weekTo);
    const weeksInRange = uniqueWeeks.slice(Math.min(fromIndex, toIndex), Math.max(fromIndex, toIndex) + 1);

    let displayKeys = [];
    let groupedByMonth = {};

    if (summaryType === 'monthly') {
        weeksInRange.forEach(week => {
            const [dd, mmm, yy] = week.split('-');
            const monthKey = `${mmm}-${yy}`;
            if (!groupedByMonth[monthKey]) groupedByMonth[monthKey] = [];
            groupedByMonth[monthKey].push(week);
        });
        displayKeys = Object.keys(groupedByMonth).sort((a, b) => new Date(`01-${a}`) - new Date(`01-${b}`));
    } else {
        displayKeys = weeksInRange;
    }

    const table = document.createElement('table');
    const thead = document.createElement('thead');
    const tbody = document.createElement('tbody');

    // ---- HEADER ROW ----
    const headerRow = document.createElement('tr');
    headerRow.innerHTML = `<th class="sticky-left">LOB</th><th class="sticky-left-2">Metric</th>`;
    displayKeys.forEach(key => {
        const th = document.createElement('th');
        th.textContent = key;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);

    // ---- OVERALL SUMMARY ----
    const overallData = {};
    selectedMetrics.forEach(metric => {
        overallData[metric] = {};
        displayKeys.forEach(key => {
            if (summaryType === 'monthly') {
                const weeksArray = groupedByMonth[key] || [];

                // Collect non-zero values across all selected LOBs for Required & Available
                const reqValues = [];
                const availValues = [];

                selectedLOBs.forEach(lob => {
                    weeksArray.forEach(week => {
                        const req = groupedData[lob]?.[week]?.['Required HC'] ?? 0;
                        const avail = groupedData[lob]?.[week]?.['Available HC'] ?? 0;
                        if (req !== 0) reqValues.push(req);
                        if (avail !== 0) availValues.push(avail);
                    });
                });

                const sumArr = arr => arr.reduce((s, v) => s + v, 0);
                const avgReq = reqValues.length ? (sumArr(reqValues) / reqValues.length) : 0;
                const avgAvail = availValues.length ? (sumArr(availValues) / availValues.length) : 0;

                // Metrics
                if (metric === 'Required HC') {
                    overallData[metric][key] = Math.round(avgReq);
                } else if (metric === 'Available HC') {
                    overallData[metric][key] = Math.round(avgAvail);
                } else if (metric === 'Delta') {
                    overallData[metric][key] = Math.round(avgAvail - avgReq);
                } else if (metric === 'Staffing %') {
                    overallData[metric][key] = avgReq === 0 ? 0 : Math.round((avgAvail / avgReq) * 100);
                } else {
                    // Other metrics: sum across selected LOBs & weeks (monthly)
                    overallData[metric][key] = selectedLOBs.reduce((sumL, lob) =>
                        sumL + weeksArray.reduce((subSum, week) => subSum + (groupedData[lob][week]?.[metric] || 0), 0)
                    , 0);
                }
            } else {
                // Weekly view (unchanged) - sum across selected LOBs
                overallData[metric][key] = selectedLOBs.reduce((sum, lob) =>
                    sum + (groupedData[lob][key]?.[metric] || 0), 0
                );
            }
        });
    });

    // Render overall summary rows
    selectedMetrics.forEach((metric, i) => {
        const row = document.createElement('tr');
        if (i === 0) {
            const tdLOB = document.createElement('td');
            tdLOB.className = 'sticky-left';
            tdLOB.setAttribute('rowspan', selectedMetrics.length);
            tdLOB.style.background = '#fff';
            tdLOB.style.color = '#000';
            tdLOB.textContent = 'Overall Summary';
            row.appendChild(tdLOB);
        }

        const tdMetric = document.createElement('td');
        tdMetric.className = 'sticky-left-2';
        tdMetric.textContent = metric;
        row.appendChild(tdMetric);

        displayKeys.forEach(key => {
            const td = document.createElement('td');
            let val = overallData[metric][key];

            let cls = '';
            if (metric === 'Delta' && val < 0) cls = 'rag-red';
            if (metric === 'Staffing %') {
                if (val < 80) cls = 'rag-red';
                else if (val < 100) cls = 'rag-amber';
                else cls = 'rag-green';
                val = `${val}%`;
            } else {
                val = Math.round(val);
                val = new Intl.NumberFormat().format(val);
            }

            td.className = cls;
            td.title = val;
            td.textContent = val;
            td.style.background = '#F5FAE1';
            row.appendChild(td);
        });

        tbody.appendChild(row);
    });

    // ---- INDIVIDUAL LOB ROWS ----
    selectedLOBs.forEach((lob, lobIndex) => {
        const lobColor = lobColors[lobIndex % lobColors.length];

        selectedMetrics.forEach((metric, i) => {
            const row = document.createElement('tr');
            if (i === 0) {
                const tdLOB = document.createElement('td');
                tdLOB.className = 'sticky-left';
                tdLOB.setAttribute('rowspan', selectedMetrics.length);
                tdLOB.style.background = lobColor;
                tdLOB.style.color = '#fff';
                tdLOB.textContent = lob;
                row.appendChild(tdLOB);
            }

            const tdMetric = document.createElement('td');
            tdMetric.className = 'sticky-left-2';
            tdMetric.textContent = metric;
            row.appendChild(tdMetric);

            displayKeys.forEach(key => {
                const td = document.createElement('td');
                const weeksArray = summaryType === 'monthly' ? groupedByMonth[key] : [key];

                let val = 0;
                if (summaryType === 'monthly') {
                    let totalReq = weeksArray.reduce((sum, week) => sum + (groupedData[lob][week]?.['Required HC'] || 0), 0);
                    let totalAvail = weeksArray.reduce((sum, week) => sum + (groupedData[lob][week]?.['Available HC'] || 0), 0);
                    let weekCount = weeksArray.length;

                    const avgReq = weekCount === 0 ? 0 : totalReq / weekCount;
                    const avgAvail = weekCount === 0 ? 0 : totalAvail / weekCount;

                    if (metric === 'Required HC') {
                        val = Math.round(avgReq);
                    } else if (metric === 'Available HC') {
                        val = Math.round(avgAvail);
                    } else if (metric === 'Delta') {
                        val = Math.round(avgAvail - avgReq);
                    } else if (metric === 'Staffing %') {
                        val = avgReq === 0 ? 0 : Math.round((avgAvail / avgReq) * 100);
                    } else {
                        // Other metrics aggregated monthly by sum
                        val = weeksArray.reduce((sum, week) => sum + (groupedData[lob][week]?.[metric] || 0), 0);
                    }
                } else {
                    // Weekly view (unchanged)
                    val = groupedData[lob][key]?.[metric] || 0;
                }

                let cls = '';
                if (metric === 'Delta' && val < 0) cls = 'rag-red';
                if (metric === 'Staffing %') {
                    if (val < 80) cls = 'rag-red';
                    else if (val < 100) cls = 'rag-amber';
                    else cls = 'rag-green';
                    val = `${val}%`;
                } else {
                    val = Math.round(val);
                    val = new Intl.NumberFormat().format(val);
                }

                td.className = cls;
                td.title = val;
                td.textContent = val;
                row.appendChild(td);
            });

            tbody.appendChild(row);
        });
    });

    table.appendChild(thead);
    table.appendChild(tbody);
    $container.empty().append(table);
}
